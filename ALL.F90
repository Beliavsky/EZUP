      PROGRAM EZUP
!
!      THIS PROGRAM IS INTENDED FOR THE PURPOSE OF HELPING CONVERT
!     FORTRAM 77 (AND EARLIER) SOURCE PROGRAMS INTO A FORM THAT IS
!     MORE OR LESS COMPATIBLE WITH FORTRAN 90. IT IS FAR FROM FLAWLESS
!     BUT DOES HANDLE SOME OF THE 'GRUNT WORK' FOR SUCH CONVERSIONS.
!     IT IS BASED ON A PROGRAM WRITTEN BY THE AUTHOR FOR RENUMBERING
!     FORTRAN PROGRAMS. IT WAS ORIGINALLY IMPLEMENTED ON A NORTHSTAR
!     MICROCOMPUTER HAVING 56 KILOBYTES OF MEMORY AND A VERSION OF THE
!     CP/M OPERATING SYSTEM.
!
      USE RENCOM
      IMPLICIT NONE
      save namflg,nfmax,intfil
!
      INTEGER(2) :: IJKLMN, MYCDEF
!     LAST MODIFICATIONS: 13 October 2009
!     BASED ON: PROGRAM REN21, VERS. 2.5 VAX/HP/ETC OF 29 APRIL 1989
!
!     PROPERTY OF AUGUST MILLER,AKA W5YGR: ALL RIGHTS RESERVED
!
!     MAY NOT BE USED AS PART OF ANY COMMERCIAL PACKAGE WITHOUT
!     EXPRESS WRITTEN PERMISSION OF THE OWNER. OTHERWISE USE IN
!     ACCORDANCE WITH THE GNU GENERAL PUBLIC LICENSE IS OK. TO CONTACT
!     THE AUTHOR SEND EMAIL TO W5YGR AT YAHOO.COM.
!
!     ---------------- COMPILATION NOTES -------------------------------
!     THIS VERSION (2.07) OF EZUP HAS BEEN COMPILED AND TESTED USING
!     1) THE MICROSOFT FORTRAN POWER STATION VERSION 4.0 COMPILER
!     2) THE LAHEY LF90 VERSION 4.5 FORTRAN COMPILER
!     3) THE GNU G95/CYGWIN FORTRAN COMPILER      COMPILER
!        WHEN COMPILED AND LINNKED WITH THE G95 COMPILER, REQUESTING
!        MORE THEN THE -O1 OPTIMAZATION HAS GENERALLY PRODUCED EXECUTABLES
!        THAT CRASH (FOR UNKNOWN REASONS),SO ONLY THE -O1 OPTION IS
!        RECOMMENDED.
!     ------------------------------------------------------------------
!     THE SOURCE CODE MAY CONTAIN MORE THAN ONE PROGRAM ELEMENT. IF SO,
!     EACH ONE WILL BE RENUMBERED IN THE SAME WAY AS THE FIRST ONE.
!!
!     ********************** USER  NOTES *******************************
!
!     THE FIRST LINE OF THE SOURCE FILE WILL ALWAYS BE IGNORED, SO
!     BE SURE THAT IT DOES NOT CONTAIN A STATEMENT LABEL !
!
!     ******************************************************************
!     DOES NOT RENUMBER ANY STATEMENTS WHICH CARRY A 'C' IN COL. # 1
!     ******************************************************************
!     IT MAY ALSO DROP CHARACTERS IN COLUMN 72 ON LONG FORTRAN LINES
!     ESPECIALLY IF NEW STATEMENT LABELS ARE LONGER THAN OLD ONES.
!     ******************************************************************
!     MAY FAIL IF ANY PART OF A STATEMENT LABEL IS ON A 'CONTINUATION
!     CARD'.
!     ******************************************************************
!     ALL "ELSE IF" AND "END IF" STATEMENTS SHOULD BE REPLACED BY
!     "ELSEIF" AND "ENDIF" STATEMENTS PRIOR TO RUNNING THIS CODE.
!     ******************************************************************
!     ANY LOWER-CASE CHARACTERS IN FORMATS, ETC <<WILL>> BE CONVERTED
!     TO UPPER-CASE BY THIS PROGRAM.
!     ******************************************************************
!     STRUCTURED PROGRAMMING INDENTATIONS WILL BE LOST! ALL FORTRAN
!     STATEMENTS WILL BE LEFT-JUSTIFIED TO COLUMN 7.
!     ******************************************************************
!     ANY SEQUENCE NUMBERS IN COLUMS 73-80 WILL BE IGNORED.
!     *****************************************************************
!
!     STATEMENTS LIKE:
!     "IF(TMP(1).EQ.'Y') GOTO 400" MAY NOT BE HANDLED CORRECTLY
!     BECAUSE LINES CONTAINING APOSTROPHES ARE GIVEN SPECIAL TREATMENT.
!
!     *****************************************************************
!     NO MORE THAN 400 DISTINGUISHABLE STATEMENT LABEL VALUES ARE
!     ALLOWED IN SINGLE PROGRAM ELEMENT. IF YOU NEED MORE THAN THAT,
!     INCREAD THE SIZE FIRST DIMENSION OF ARRAY 'LABEL'.
!     ******************************************************************
!
!      BATCH MODE INPUT FILE INFORMATION:
!
!     OPTIONS FILE=EZUP.OPT:
!
!     A FILE CARRYING RUN CONTROL INFO.
!
!     LINE 1: FORMAT(7I5),  WITH INTEGER DATA:
!       INTER, LFIRST, ISTEP, IKEEP, NDSPAC,KPTEMP,NFILES
!
!     EXPLANATIONS:
!
!       INTER    CONTROLS MODE OF OPERATION:
!        = 0 MEANS NON-INTERACTIVE MODE; OPERATE WITH DATA IN THE
!            OPTIONS FILE OR INTERNAL DEFAULTS.
!
!            THIS MODE IS HANDIEST FOR BATCH AND BACKGROUND MODES
!            UNDER MS-DOS OR UNIX.
!
!            IF INTER=0 , THEN THE PROGRAM
!            WILL LOOK FOR A SECOND DATA CARD CARRYING THE SOURCE
!            AND OUTPUT FILE NAMES. IF IT ISN'T FOUND OR IF NAMES
!            ARE 'EMPTY', THE PROGRAM WILL STOP.
!
!        = 1 MEANS THAT CONSOLE I/O IS TO BE USED FOR THESE DATA.
!
!        = 2 MEANS THAT OPTIONS FILE WILL BE USED TO GET LABEL
!            VALUES, BUT CONSOLE WILL BE USED FOR ENTERING FILE
!            NAMES
!
!       LFIRST = NUMERIC VALUE FOR FIRST LABEL OF EACH MODULE
!          ALLOWED RANGE IS 1 TO 10000; 100 IS SUGGESTED MAX.
!
!       ISTEP  = NUMERIC VALUE OF INCREMENT OR STEP BETWEEN LABELS.
!          ALLOWED RANGE IS 1 TO 10000, BUT 100 IS SUGGESTED MAX.
!
!       KEEP   = 0 MEANS THAT IT IS OK TO OVERWRITE AN EXISTING FILE
!            WHICH HAS THE NAME GIVEN FOR THE OUTPUT FILE.
!
!        = 1 MEANS <<DO NOT>> OVERWRITE AN EXISTING OUTPUT FILE.
!
!
!       NDSPAC = NUMBER OF COLUMNS TO BE USED FOR INDENTATION OF DO-LOOP
!          AND IF-THEN-ELSE BLOCKS. MAX IS 5, DEFAULT IS 2.
!
!       KPTEMP = 0 MEANS DELETE TEMPCOPY.FOR AT END OF RUN
!        = 1 MEANS DO NOT DELETE IT
!
!       NFILES = NUMBER OF SEPARATE INPUT FILES TO BE RENUMBERED IN THE
!          INTER = 0 MODE.
!
!     LINE 2: FORMAT(A32,8X,A32), WITH DATA:
!
!     FNAME1   = NAME OF INPUT (SOURCE PROGRAM) DATA FILE
!     FNAME2   = NAME TO BE USED FOR OUTPUT (RENUMBERED) FILE
!
!          THIS LINE IS REQUIRED IF VARIABLE 'INTER' IS 0 ON FIRST
!          CARD.
!
!     A SAMPLE OF A BATCH CONTROL FILE FOLLOWS:
!    0   10   10    0    3    1    2
!ATEST.FOR                   ATEST_B.OUT
!MYTEST.FOR                  MYTEST_B.OUT
!^                     ^
!1                  
! THE CARETS ^ INDICATE WHERE THE FILE NAMES **MUST** BEGIN
! NAMELY IN COLUMNS 1 AND 41. THE SAMPLE LINE CONTAINING THE TWO
! CARETS SHOULD NOT ACTUALLY BE PRESENT IN THE EZUP.OPT FILE
! --------------------------------------------------------------------
!
      LOGICAL :: EXST,LSAME
      CHARACTER(LEN=96) :: NONAME
      CHARACTER(LEN=1) :: KCHAR
      CHARACTER(LEN=1) :: YES
      CHARACTER(LEN=5) :: TMPWD,BNKWD,LABWD
      CHARACTER(LEN=80) :: TMPLIN
      CHARACTER(LEN=8) :: BOGUS1,BOGUS2,BOGCHK
!
!      INTEGER(2) :: IOPTF, LFIRST, INCRMT, INTER, KEEP, KPTEMP
      INTEGER(2) :: I,NFMAX,NAMFLG, IUHOLD, ISTEP, IDUM
      INTEGER(2) :: JJ,K,LNO,KKK,M,LFIRS,NFILS,IKEEP, NDSPAC
      INTEGER(2) :: IERR, MORE, ILEN,J,KK, LKEEP
      INTEGER(2) :: LFIRST, INCRMT
		integer idum1
      REAL :: VERSNO
! NDIF WILL BE CHARACTER REP OF NFILES USED AS PART OF THE OUTPUT
! MODULES AND INTERFACE FILENAMES
        CHARACTER(LEN=2) :: NFID
        CHARACTER(LEN=12) :: MODFIL, INTFIL 
!
! --------------------------------------------------------------------
!     A NUMBER OF PHRASES OR WORDS HAVE BEEN DEFINED AS 'KEY WORDS'.
!     THOSE ARE WORDS WHICH MAY BE ASSOCIATED WITH STATEMENT LABELS
!     OR WORDS WHICH DEFINE DATA TYPES, ETC.
!
!     ALTHOUGH THIS PROGRAM REMOVES MOST "BLANKS" OR "SPACE CODES"
!     FROM OUTPUT FILE, THAT "SPACE COMPRESSION" IS SKIPPED IF LINES
!     APPEAR TO CONTAIN ANY OF THE KEY WORDS SPECIFIED IN THE ARRAY
!     KEYWDS().
!
!
!   10 FORMAT(25(/))
!   20 FORMAT(15X,'PROGRAM EZUP: COPYRIGHT BY AUGUST MILLER'/15X,
!     1           '          ** VERSION  2.50 **           '//15X,
!     2           '     (UNREGISTERED USE IS DISHONEST)   ',5(/))
   10 FORMAT(A1)
   20 FORMAT(5(/),' ENTER VALUE FOR FIRST OF NEW LABELS (I5) : ')
   30 FORMAT(I5)
   40 FORMAT(2(/),' ENTER INCREMENT-VALUE FOR NEW LABELS : ')
   50 FORMAT(15I5)
   60 FORMAT(A32,8X,A32)
   70 FORMAT(4(/),' PROCESSING COMPLETED. '//)
   80 FORMAT(' PROCESS ANOTHER FILE (Y/N) ?')
   90 FORMAT(A80)
!
!     A LOT OF HOPES ARE INVOLVED IN DEFINING FORTRAN "KEY WORDS"
!     TO SAVE SPACE AND COMPUTATION TIME, I HAVE USED ONLY THE FIRST
!     FOUR CHARACTERS OF WORDS WITH SPECIAL MEANINGS. THIS IS SOMEWHAT
!     EQUIVALENT TO GIVING "RESERVED" STATUS TO SOME OF THEM. IT WOULD
!     BE A MODERATELY BIG JOB TO CHANGE THE SITUATION.
!
      KEYWDS(1)='CHAR'
      KEYWDS(2)='COMM'
      KEYWDS(3)='COMP'
      KEYWDS(4)='DIME'
      KEYWDS(5)='DOUB'
      KEYWDS(6)='EQUI'
      KEYWDS(7)='INTE'
      KEYWDS(8)='REAL'
      KEYWDS(9)='DATA'
      KEYWDS(10)='IMPL'
      KEYWDS(11)='EXTE'
      KEYWDS(12)='FUNC'
      KEYWDS(13)='END '
      KEYWDS(14)='ENDF'
      KEYWDS(15)='LOGI'
      KEYWDS(16)='BLOC'
      KEYWDS(17)='BACK'
      KEYWDS(18)='PARA'
      KEYWDS(19)='EXTE'
      KEYWDS(20)='INTR'
      KEYWDS(21)='REWI'
      KEYWDS(22)='WRIT'
      KEYWDS(23)='FORM'
      KEYWDS(24)='SUBR'
      KEYWDS(25)='CALL'
      KEYWDS(26)='PROG'
      KEYWDS(27)='STOP'
      KEYWDS(28)='SAVE'
      KEYWDS(29)='OPEN'
      KEYWDS(30)='RETU'
      KEYWDS(31)='INQU'
      KEYWDS(32)='ELSE'
      KEYWDS(33)='GO T'
      KEYWDS(34)='GOTO'
      KEYWDS(35)='CONT'
      KEYWDS(36)='ENDI'
      KEYWDS(37)='INCL'
      KEYWDS(38)='ENTR'
      KEYWDS(39)='ENDD'
      KEYWDS(40)='USE '
! SPARES
      KEYWDS(41)='DO '
      KEYWDS(42)='    '
      KEYWDS(43)='    '
      KEYWDS(44)='    '
      KEYWDS(45)='    '
      KEYWDS(46)='    '
      KEYWDS(47)='    '
      KEYWDS(48)='    '
      KEYWDS(49)='    '
      KEYWDS(50)='    '

      YES='Y'
      NONAME='                    '
      BNKWD='     '
      BOGUS1='IJKLMN=1'
      BOGUS2='MYCDEF=0'
!AMI  NEXT TWO FILE TYPES CHANGED FROM "OUT" TO "F90" 3 JULY 2009
        MODFIL='MODULEXX.F90'
        INTFIL='INTRFCXX.F90'
! ---------------------------------------------------------------------
!     SET LATEST VERSION ID
!
      VERSNO=2.09
!
!     SET SOME DEFAULT PARAMETERS
!
      IOPTF=0
      LFIRST=10
      INCRMT=10
      INTER=1
      KEEP=1
!## CHANGE KPTEMP FROM 0 TO 1 FOR DEBUGGING
      KPTEMP=1
      NDSPC=3
      IOIN=2
      ITMOD=21
      ITMPF=31
      ITSBR=32
      INTRFC=33
      NFMAX=1
      NFILES=0
      NDALL=0
      NAMFLG=0
      NDSPAC=3
!
!     WRITE HEADER TO SCREEN
!
      CALL HEADER(VERSNO)
!
!     CHECK FOR OPTIONS FILE
!
      INQUIRE(FILE='EZUP.OPT',EXIST=EXST)
      IF(EXST)THEN
         IOPTF=1
         OPEN(UNIT=1,FILE='EZUP.OPT',STATUS='OLD')
         READ(1,50)INTER,LFIRS,ISTEP,IKEEP,NDSPAC,KPTEMP,NFILS,LKEEP
         IF(NFILS.GT.0)NFMAX=NFILS
         IF(INTER.LT.0.OR.INTER.GT.2)THEN
      WRITE(*,*)'ERROR IN VALUE OF PARAMETER <INTER> IN OPTIONS FI&
     &LE. WILL USE 1.'
      INTER=1
         END IF
!
         IF(LFIRS.LT.0.OR.LFIRS.GT.10000)THEN
      WRITE(*,*)'VALUE OF <LFIRST> OUT OF RANGE IN OPTIONS FILE. W&
     &ILL USE 10.'
         ELSE
      LFIRST=LFIRS
         END IF
!
         IF(ISTEP.LT.0.OR.ISTEP.GT.10000)THEN
      WRITE(*,*)'VALUE OF <ISTEP> OUT OF RANGE IN OPTIONS FILE. WI&
     &LL  USE 10.'
         ELSE
      INCRMT=ISTEP
         END IF
!
         IF(KEEP.LT.0.OR.KEEP.GT.1)THEN
      WRITE(*,*)'VALUE OF PARAMETER <KEEP> IN OPTIONS FILE IS OUT &
     &OF RANGE. USING 1.'
         ELSE
      KEEP=IKEEP
         END IF
!
         IF(NDSPAC.LT.0.OR.NDSPAC.GT.5)THEN
      WRITE(*,*)'VALUE OF <NDSPAC> IN OPTIONS OUT OF RANGE. USING &
     &NDSPAC = 3.'
      NDSPC=3
         ELSE
      NDSPC=NDSPAC
         END IF
      END IF
  100 IJKLMN=1
      IF(IOPTF.EQ.1)THEN
!
!     SEE IF THERE IS SECOND CARD WITH FILE NAMES
!
         NAMFLG=1
         READ(1,60,END=410,ERR=110)FNAME1,FNAME2
         IF(FNAME1.EQ.NONAME)THEN
      WRITE(*,*)'NAME OF INPUT FILE IN OPTIONS FILE IS INVALID: ',&
     &   FNAME1
      NAMFLG=0
         END IF
!
         IF(FNAME2.EQ.NONAME)THEN
      WRITE(*,*)'NAME OF OUTPUT FILE IN OPTIONS FILE IS INVALIE: '&
     &,  FNAME2
      NAMFLG=0
         END IF
         IF(NAMFLG.EQ.0)THEN
      WRITE(*,*)'JOB ABANDONED DUE TO ERROR IN OPTIONS FILE.'
      STOP 101
         END IF
         GO TO 120
!
  110    IJKLMN=1
         NAMFLG=0
!
!       WE CAN'T USE STD RE-DIRECT DUE TO MS-FORTRAN CRASHES WHEN I
!       ATTEMPT TO BACKSPACE OR DO ENDFILE FOR UNIT 5 EVEN IF IT WAS
!       REDIRECTED TO REAL FILE IN COMMAND LINE. SO STOP HERE.
!
         WRITE(*,*)'ERROR IN OPTIONS FILE: NO I/O FILE NAMES WHEN OPTION&
     & <INTER> = 0.'
         WRITE(*,*)'UNABLE TO CONTINUE.'
         STOP 102
      END IF
!
!     CLOSE THE OPTIONS FILE
!
      CLOSE(1)
!
!     RECYCLE POINT
!
  120 IJKLMN=1
!
!     IF NAMFLG=0 WE FOUND NO FILE NAMES IN THE OPTIONS FILE
!     REASSIGN IOOUT TO LUN=3 FOR EACH PASS TO AVOILD LETTING IT
!     REMAIN LUN=6 AFTER USERS ONCE HAS ASKED FOR OUTPUT TO CONSOLE.
!
      IOOUT=3
      ITARG=0
      IF(INTER.EQ.0)GO TO  160
      IF(INTER.EQ.2)GO TO  150
!
  130 IJKLMN=1
      WRITE(*,20)
      READ(*,30,ERR=130)LFIRST
      IF(LFIRST.LE.0.OR.LFIRST.GT.10000)LFIRST=10
!
  140 IJKLMN=1
      WRITE(*,40)
      READ(*,30,ERR=140)INCRMT
      IF(INCRMT.LE.0.OR.INCRMT.GT.10000)INCRMT=10
  150 IJKLMN=1
!
!     ASK USER FOR FILE NAMES
!
      CALL GETINF(IOIN,IERR)
      IF(IERR.LT.0)STOP 103
      CALL GETOUF(IOOUT,IERR)
      IF(IERR.LT.0)STOP 104
!
!      SET ITARG =1 IF OUTPUT IS TO BE TO CONSOLE
!
      IF(IERR.EQ.1)THEN
         ITARG=1
         IOOUT=6
      END IF
      GO TO 170
!
  160 IJKLMN=1
      IF(NAMFLG.EQ.0)GO TO  170
      IF(NAMFLG.NE.1)THEN
         WRITE(*,*)'NAMFLG ERROR. RUN ABANDONED.'
         STOP 105
      END IF
!
      INQUIRE(FILE=FNAME1,EXIST=EXST)
      IF(EXST)THEN
         OPEN(UNIT=IOIN,FILE=FNAME1,STATUS='OLD',ACTION='READ')
      ELSE
         WRITE(*,*)'SPECIFIED INPUT FILE: ',FNAME1
         WRITE(*,*)'DOES NOT EXIST. JOB ABANDONED.'
         STOP 106
      END IF
!
      INQUIRE(FILE=FNAME2,EXIST=EXST)
      IF(EXST)THEN
         IF(KEEP.EQ.0)THEN
      OPEN(IOOUT,FILE='PASS1.F90',STATUS='UNKNOWN')
         ELSE
      WRITE(*,*)'OUTPUT FILE: ',FNAME2
      WRITE(*,*)'ALREADY EXISTS & OPTIONS SPECIFIED NO OVERWRITE. &
     &RUN TERMINATED.'
      STOP 107
         END IF
!      ELSE
      END IF
!
  170 IJKLMN=1
!DELETE ANY EXISTING COPY OF PASS1.F90
      OPEN(IOOUT,FILE='PASS1.F90',STATUS='UNKNOWN')
      CLOSE(IOOUT,STATUS='DELETE')
      OPEN(IOOUT,FILE='PASS1.F90',STATUS='UNKNOWN')
      WRITE(NFID,'(I2)')NFILES
         IF(NFID(1:1).EQ.' ') NFID(1:1)='0'
         MODFIL(7:8)=NFID(1:2)
         INTFIL(7:8)=NFID(1:2)
!
!     OPEN THE SCRATCH FILE
!
      INQUIRE(FILE='TEMPCOPY.FOR',EXIST=EXST)
      IF(EXST) THEN
           OPEN(4,FILE='TEMPCOPY.FOR',STATUS='UNKNOWN')
           CLOSE(4,STATUS='DELETE')
      END IF
!
      INQUIRE(FILE='SCRATCH2.TMP',EXIST=EXST)
        IF (EXST) THEN
           OPEN(ITMOD,FILE='SCRATCH2.TMP',STATUS='UNKNOWN')
           CLOSE(ITMOD,STATUS='DELETE')
        END IF
!
      INQUIRE(FILE='TEMPSUBR.TMP',EXIST=EXST)
        IF (EXST) THEN
           OPEN(ITSBR,FILE='TEMPSUBR.TMP',STATUS='UNKNOWN')
           CLOSE(ITSBR,STATUS='DELETE')
        END IF
!
      INQUIRE(FILE='INTRFACE.TMP',EXIST=EXST)
        IF (EXST) THEN
           OPEN(INTRFC,FILE='INTRFACE.TMP',STATUS='UNKNOWN')
           CLOSE(INTRFC,STATUS='DELETE')
        END IF
!
      INQUIRE(FILE='SCRATCH1.TMP',EXIST=EXST)
        IF (EXST) THEN
           OPEN(34,FILE='SCRATCH1.TMP',STATUS='UNKNOWN')
           CLOSE(34,STATUS='DELETE')
        END IF
!
!         write(*,*)'Checking existence of file: ',intfil
      INQUIRE(FILE=INTFIL,EXIST=EXST)
!         write(*,*)'exist=',exst
        IF (EXST) THEN
           OPEN(35,FILE=INTFIL,STATUS='UNKNOWN')
           CLOSE(35,STATUS='DELETE')
        END IF
!
!---------------------------------------------------------
!
      OPEN(4,FILE='TEMPCOPY.FOR',STATUS='UNKNOWN')
! DELETE PRE-EXISTING COPY OF FILE MODULES.OUT
      IMODUL=22
      OPEN(IMODUL,FILE=MODFIL,STATUS='UNKNOWN')
      NUMMOD=0
      OPEN(ITMOD,FILE='SCRATCH2.TMP',STATUS='UNKNOWN')
      DO I=1,100
         CMCHKD(I)=.FALSE.
      END DO
!
      OPEN(UNIT=ITMPF,FILE='REVISED.TMP',STATUS='UNKNOWN')
      OPEN(UNIT=ITSBR,FILE='TEMPSUBR.TMP', STATUS='UNKNOWN')
      OPEN(UNIT=INTRFC,FILE='INTRFACE.TMP', STATUS='UNKNOWN')
      OPEN(UNIT= 34,FILE='SCRATCH1.TMP', STATUS='UNKNOWN')
      OPEN(UNIT= 35,FILE=INTFIL,STATUS='UNKNOWN')
!
      REWIND ITMPF
      REWIND ITSBR
      REWIND INTRFC
      REWIND 34
      REWIND 35
!
      NFILES=NFILES+1
  190 REWIND  4
      REWIND  ITMOD
!
!     PRE20 LOOKS FOR LABELS IN COLS 1-5 AND REMOVES SPACE CODES FROM
!     MOST STATEMENTS. WRITES RESULTING CODE TO FILE 'TEMPCOPY.FOR'
!
      NDALL=NDALL+1
      IF(NDALL.GT.1)THEN
         BACKSPACE IOIN
      END IF
      NLINE=0
      CALL PRE20(MORE,LFIRST,INCRMT)
!
!     REL21 PROCESS THE FILE 'TEMPCOPY.FOR'
!     AND DOES THE ACTUAL RELABELING
!
! 10-27-95, ET SEQ: ADD NEW SCRATCH FILE FOR LABEL RE-PROCESSING
!     HERE I TEMPORARILY REDEFINED IOOUT SO THAT SUBROUTINE REL21'D
!     WRITE(IOOUT,..) STATEMENTS ACTUALLY WRITE TO THE REVISED.TMP
!     FILE (LUN=ITMPF) INSTEAD OF THE "TRUE" IOOUT FILE.
      IUHOLD=IOOUT
      REWIND  ITMPF
      IOOUT=ITMPF
!
      CALL REL21
!
!     AND NOW, RESET VALUE OF IOOUT SO THAT IOOUT POINTS TO
!     THE "TRUE" OUTPUT FILE
      IOOUT=IUHOLD
!
!     BEGIN REPROCESSING LINE BY LINE
!     IF I WANT TO DO ANYTHING WITH INTERFACE CONSTRUCTION
!     OR INTENTS, THIS IS THE PLACE TO DO THEM!!!!
!     REWIND "REVISED.TMP" AND COPY IT TO TEMPSUBR.TMP
!
!      GOTO 1830
      REWIND  ITMPF
      REWIND  ITSBR
      DO I=1,10000
         READ(ITMPF,90,END=210)TMPLIN
            IDUM=79
         CALL GETLEN(TMPLIN,IDUM,ILEN)
         WRITE(ITSBR,'(80A1)')(TMPLIN(JJ:JJ),JJ=1,ILEN)
      END DO
!1800 WRITE(ITSBR,85) TMPLIN
  210 IJKLMN=1
!
!     NOW I WANT SBVCHK TO READ FROM ITSBR
!     SBVCHK WILL TRY TO REPLACE UNKNOWN DATA TYPES IN INTENT
!     STATEMENTS AND PASS ALONG OTHER STATEMENTS TO LUN=INTRFC
!     WHEN I GET THROUG, I WILL OVERWRITE REVISED.TMP (ITMPF)
!     BY CONTENTS OF INTRFACE.TMP. I'M USING THE EXTRA FILE
!     BECAUSE I NEED TO BE ABLE TO CYCLE THROUGH REVISED.TMP MANY
!     TIMES TRYING TO LOCATE VARIABLE TYPE-DECLARATIONS
!
      REWIND  INTRFC
      REWIND  ITSBR
      CALL SBVCHK( )
! --------------------------------------------------
      REWIND  ITMPF
      REWIND  INTRFC
      DO I=1,10000
         READ(INTRFC,90,END=230)TMPLIN
            IDUM=79
         CALL GETLEN(TMPLIN,IDUM,ILEN)
      WRITE(ITMPF,'(80A1)')(TMPLIN(JJ:JJ),JJ=1,ILEN)
      END DO
! 1820 WRITE(ITMPF,85) TMPLIN
  230 IJKLMN=1
!
!     -----------------------------------------------------
!
!        THE NEXT SET OF OPERATIONS READS REVISED.TMP AND TRIES TO
!     DELETE UNUSED LABELS FROM COLUMNS 1-5
!        AND WRITES THE CURRENT PROGRAM UNIT CODE TO THE FINAL OUTPUT FI
!
      REWIND  ITMPF
      NLINE=0
      DO I=1,9999
         READ(ITMPF,90,END=350)TMPLIN
         NLINE=NLINE+1
         DO K=1,80
            IF(TMPLIN(81-K:81-K).NE.' ')THEN
               ICLEN=81-K
               GO TO 250
            END IF
         END DO
  250    IJKLMN=1
!     CHECK FOR LABEL IN COLS 1-5
         DO J=1,5
            TMPWD(J:J)=TMPLIN(J:J)
         END DO
         IF(TMPWD.EQ.BNKWD.OR.TMPLIN(1:1).EQ.'!')THEN
            WRITE(IOOUT,'(80A1)') (TMPLIN(K:K),K=1,ICLEN)
         ELSE
!     EXTRACT LABEL FOR COMPARISONS
           DO J=1,5
              LABWD(J:J)=TMPLIN(J:J)
           END DO
!     COMPARE TO THOSE IN REFERENCED LIST, BUT FIRST LOCATE THE
!     INDEX FOR THE CURRENT LABEL
         LNO=0
         DO K=1,LMAX
           LSAME=.TRUE.
           DO J=1,5
            IF(LABEL(K,J,2).NE.TMPWD(J:J))LSAME=.FALSE.
           END DO
           IF(LSAME)THEN
              LNO=K
              GO TO 300
           END IF
         END DO
  300       IJKLMN=1
         IF(LNO.EQ.0)THEN
            WRITE(IOOUT,'(80A1)') (TMPLIN(J:J),J=1,ICLEN)
            GO TO 340
         END IF
!
!     WE KNOW KNOW THE LABEL'S INDEX (LNO) AND CAN REACT ACCORDINGLY
!     FIRST, SEE IF IT IS REFERENCED. IF SO, SEND TMPLIN TO IOOUT
!
         IF(LREF(LNO))THEN
            WRITE(IOOUT,'(80A1)') (TMPLIN(J:J),J=1,ICLEN)
         ELSE
!     REMOVE THE LABEL FROM COLS (1-5)
! BUT I FIND THAT I NEED TO BE EXTRA CAUTIONS IF STMT  IS A FORMAT STMT
            TMPWD=TMPLIN(7:11)
            IF(TMPWD.EQ.'FORMA') THEN
               LSAME=.TRUE.
               WRITE(IOOUT,'(80A1)') (TMPLIN(J:J),J=1,ICLEN)
               GO TO 340
            END IF
            DO J=1,5
               TMPLIN(J:J)=' '
            END DO
!     IF THE LINE CONTAINS AN IJKLMN OR MYCDEF, THEN OMIT THE LINE
!     COMPLETELY. OTHERWISE, SEND IT TO IOOUT W/O THE LABEL
!
            LSAME=.FALSE.
            K=0
            DO J=7,ICLEN
               IF(TMPLIN(J:J).NE.' ')THEN
                  K=K+1
                  IF(K.GT.8)GO TO  330
                  BOGCHK(K:K)=TMPLIN(J:J)
               END IF
            END DO
  330       IF(BOGCHK.EQ.BOGUS1.OR.BOGCHK.EQ.BOGUS2)LSAME=.TRUE.
!
            IF(LSAME)THEN
               GO TO 340
            ELSE
               WRITE(IOOUT,'(80A1)') (TMPLIN(J:J),J=1,ICLEN)
            END IF
         END IF
!
! END OF THE ELSE PORTION (EXECUTED IF THERE IS A LABEL IN COLS 1-5)
       END IF
!NEXT STMT MANUALLY PLACED INSIDE THE LOOP 6-22-97:BUT BRINGS MANY OTHER ILLS
 340 MYCDEF=0
      END DO
!  340 MYCDEF=0
! THIS IS THE END OF THE "DO I=1,9999" LOOP THAT BEGINS NEAR LABEL 230
! -------------------------------------------------------------------
! JUMP TO HERE OCCURS AT EOF IN READING OF ITMPF AND FINAL WRITES
! OF RELABLED PROGRAM UNIT TEXT TO THE IOOUT FILE
!
! ADDITION MAY 11, 1997
! AIM IS TO RE-EXAMINE THE NEW  TEMPORARY "MODULES" FILE (SCRATCH2.TMP,
! LUN=ITMOD CREATED BY A CALLS TO "MKCMBK" DOWN IN SUBROUTINE PRE20
! WHENEVER PRE FINDS "COMMON" STMT IN SOURCE FILE (IOIN) IT CALLS
! PCOMMN TO DIG OUT COMMON BLOCK NAME (IF ANY) AND TO CONSTRUCT THE
! CORRESP NAME FOR A NEW MODULE
! PRE THEN CALLS MKCMBK TO DIG OUT VARIABLE NAMES AND ACTUALLY CONSTRUCT
! AN INITIAL FILE (SCRATCH2.FOR VIA LUN=ITMOD)
!
! AND HERE I WANT TO TRY TO REPLACE ALL "UNKNOWN :: " DATA TYPING STMTS
! BY (PERHAPS!) CORRECT TYPES DECLARED IN THE RELABELED COPY (ITMPF)
! OF THE ORIGINAL SOURCE FILE. THAT IS THE JOB OF CMVCHK
!
  350 CALL CMVCHK()
!  350 CONTINUE
!
! 1910 CLOSE(ITMPF)
!
!CCCCCCC      CLOSE (ITMPF)
!
! END ADDITION MAY 11 AND LATER
!---------------------------------------------------------------------
! APPEND LIST OF VARIABLE NAMES TO END OF THE FILE
  360 FORMAT(                                   &
     &'!'/                                &
     &'!    LIST OF APPARENT VARIABLE NAMES FOLLOWS:'/            &
     &'!    BUT,ARRAY NAMES WILL GENERALLY BE MISSING.'/          &
     &'!    AND THERE ARE SOME ERRORS LIKE END, FILE'/            &
     &'!    PICKED FROM THINGS LIKE: FILE=, END=, ETC.'/          &
     &'!')
      IF(NUMVAR.GT.0)THEN
         WRITE(IOOUT,360)
         DO KK=1,NUMVAR
          DO IJKLMN=1,16
               IF (VARLST(KK,IJKLMN).EQ.' ') THEN
             ILEN=IJKLMN-1
             GO TO 378
            END IF
            END DO
       ILEN=16
  378    MYCDEF=1  
         WRITE(IOOUT,380) (VARLST(KK,KKK),KKK=1,ILEN)
         END DO
  380    FORMAT('!     ',16A1)
         WRITE(IOOUT,390)
  390    FORMAT('! $$$$$$$$$$$$$ END OF PROGRAM UNIT $$$$$$$$$$$'/      &
     &   '!                                   ')
      END IF
!
!     ***************************************************
!     * END OF PROCESSING FOR THE CURRENT PROGRAM UNIT  *
!     ***************************************************
!
      CALL BLDNFC
      WRITE(*,400)NLINE
  400 FORMAT(6X,I5,' LINES PROCESSED.'/)
      IF(MORE.EQ.-1)GO TO  420
      GO TO 190
  410 IOPTF=0
      GO TO 440
  420 IJKLMN=1
      CLOSE(IOIN)
      CLOSE(IOOUT)
      CLOSE(35)
      IF(KPTEMP.EQ.0)THEN
         CLOSE(4,STATUS='DELETE')
         CLOSE(ITMPF,STATUS='DELETE')
         CLOSE(ITSBR,STATUS='DELETE')
         CLOSE(INTRFC,STATUS='DELETE')
         CLOSE(ITMOD,STATUS='DELETE')
         CLOSE(34,STATUS='DELETE')
         CLOSE(41,STATUS='DELETE')
         CLOSE(46,STATUS='DELETE')
     ELSE
         CLOSE(4)
!         CLOSE(ITMPF)
         CLOSE(ITSBR)
         CLOSE(INTRFC)
         CLOSE(ITMOD)
         CLOSE(34)
			CLOSE(41)
			CLOSE(46)
      END IF
!     CLOSE AND DELETE OTHER TEMPORARY FILES
!     CLOSE(ITMPF, STATUS='DELETE')
!     CLOSE THE IMOUDL FILE, BUT DELETE IT IF IT IS EMPTY
!
      REWIND  IMODUL
      M=0
      DO I=1,9999
         READ(IMODUL,90,END=430)TMPLIN
         M=M+1
      END DO
  430 IF(M.LT.3)THEN
!
! THE MODULEXX.F90 FILE CONTAINS FEWER THAN THREE CHARACTERS AND WILL
! BE IGNORED. BUT, IGNORING IT MEANS THAT POSTPROC WILL NOT BE CALLED
! AND THE INTERMEDIATE FILE "PASS1.F90" WILL NOT BE AUTOMATICALLY COPIED
! TO THE FILE NAME(FNAME2) EXPECTED BY THE USER. THUS I WILL NEED TO
! DO THAT HERE. I MAY NEED TO RE-OPEN FNAME2 TO DO THAT. SKIPPING
! POSTPROC MAY ALSO SKIP FIXUPS OF A FEW NICETIES, BUT IT WILL ALSO
! AVOID RE-COMPRESSION OF THINGS LINE "GO TO' TO "GOTO"
!
            INQUIRE(FILE='PASS1.F90',EXIST=EXST)
            IF (EXST) THEN
            OPEN(UNIT=47,FILE='PASS1.F90',STATUS='OLD')
                  OPEN(UNIT=48,FILE=FNAME2,STATUS='UNKNOWN')
                  DO I=1,9999
                  READ(47,'(A80)',END=435) TMPLIN
                  IDUM=79
                  CALL GETLEN(TMPLIN,IDUM,ILEN)
                  WRITE(48,'(80A1)')(TMPLIN(JJ:JJ),JJ=1,ILEN)
                  END DO
         ELSE
            WRITE(*,*)'THERE WAS NO PASS1.F90 FILE! POST-PROCESSING WILL&
     & BE SKIPPED.'
            GO TO 435
            END IF
  435    CLOSE(47,STATUS='DELETE')
            CLOSE(48)
         CLOSE(IMODUL,STATUS='DELETE')
      ELSE
! DO POST-PROCESSING FOR SOME DATA TYPE FIXUPS
            CLOSE(IMODUL)
!!         call reproc(modfil)
            INQUIRE(FILE='PASS1.F90',EXIST=EXST)
            IF (EXST) THEN
            idum1=46
            CALL COMMVARS(MODFIL,idum1)
            CALL POSTPROC()
            call ezclean()
         END IF
      END IF
!
!D      write(*,*)IOPTF,NFILES,INTER,NFMAX,NAMFLG
      IF(IOPTF.EQ.1.AND.NFILES.LT.NFMAX.AND.INTER.EQ.0)THEN
            GO TO  100
      END IF
      IF(INTER.EQ.0)GO TO  440
!
      WRITE(*,70)
      WRITE(*,80)
      READ(*,10)KCHAR
      CALL UC1(KCHAR)
      IF(KCHAR.EQ.YES)GO TO  120
  440 IJKLMN=1
!
		IF (KPTEMP.EQ.0) THEN
			CLOSE(UNIT=77,STATUS='DELETE')
			CLOSE(UNIT=IDUM1,STATUS='DELETE')
			CLOSE(UNIT=41,STATUS='DELETE')
			CLOSE(UNIT=43,STATUS='DELETE')
! THIS LOOKS UNNECESSARY, BUT SOME WHERE i MUST HAVE CLOSED TWO FILES
! WITHOUT DELETEING THEM - IN WHICH CASE THE ABOVE CLOSE/DELETE STMTS
! WILL HAVE NO EFFECT. SO, MAKE SURE THEY ARE DELEYTED NOW
		   open(unit=8,file='commvars.tmp',status='old')
		   close(unit=8,status='delete')
		   open(unit=9,file='varnames.tmp',status='old')
		   close(unit=9,status='DELETE')
		END IF
! THIS IS PROBABLY WHERE ALL UNITS SHOULD BE CLOSED AND SOME MAY NEED TO
! BE DELETED PER KPTEMP's VALUE IN BATCH MODE.
! THE "STOP 000" STATEMENT PRODUCES AN APPARENT ERROR MESSAGE WHEN 
! THE CYGWIN/G95 IS USED. 
!      STOP 000
      END PROGRAM EZUP
!
      SUBROUTINE PRE20(MORE,LFIRST,INCRMT)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
      INTEGER(2), INTENT(INOUT) :: MORE
      INTEGER(2), INTENT(INOUT) :: LFIRST
      INTEGER(2), INTENT(INOUT) :: INCRMT
!
!     REVISED 5-MAY-1997
!
!      VAX-FORTRAN VERSION    7-SEPT-1985 BY A. MILLER
!      MS-DOS VERSION 18-APR-1986. TAKEN FROM 1984 CP/M VERSION.
!
!     ARRAY 'LABEL' WILL CONTAIN UP TO 400 FORTRAN 5-CHARACTER LABEL
!     VALUES. THIRD INDEX =1 FOR ORIGINAL LABEL VALUE, AND THIRD
!     INDEX = 2 FOR REORDERED VALUES..BEGINNING WITH ASCII REP OF 1.
!     ALINE IS SOURCE OR INPUT BUFFER
!     CLINE IS TARGET OR OUTPUT BUFFER
!     TEXT LINE DIMENSIONED AT 82 TO ALLOW FOR LF AND OR CR CODE SPACE
!
      EXTERNAL NTOASC
      CHARACTER(LEN=1) :: VALUE(5)
      CHARACTER(LEN=1) :: ALINE(1450)
      CHARACTER(LEN=1) :: BUF(1450)
      CHARACTER(LEN=1) :: SPC
      CHARACTER(LEN=1) :: CEE
      CHARACTER(LEN=1) :: KHAR
      CHARACTER(LEN=1) :: APOST
      CHARACTER(LEN=1) :: ZERO
      CHARACTER(LEN=1) :: NINE
      CHARACTER(LEN=1) :: SPACE
      CHARACTER(LEN=1) :: CHR1
      CHARACTER(LEN=1) :: CHR2
      CHARACTER(LEN=9) :: NDCARD
      CHARACTER(LEN=4) :: WORD
      CHARACTER(LEN=1) :: ABUF(80)
      CHARACTER(LEN=1) :: EXCLAM
      CHARACTER(LEN=1) :: ALABL(5)
      CHARACTER(LEN=16) :: CMNNAM
      CHARACTER(LEN=7) :: FMTWD, FMTTST
      INTEGER(2) :: IERR
      integer LUNIN
      INTEGER(2) :: ILOW,IHI,ICAP,IEXIT,KFLAG,IDIS,NDIF,JJ
      INTEGER(2) :: LABNO,IFMT,I,J,K,INK,ITST,LC,NEWNUM,IDUM
      INTEGER(2) :: IC,IK,IM,ICOLD,IKOU,JK,IAPF,IDONT,NTEST,NAPOS
      INTEGER(2) :: NCHEK,KMAX,NFLAG,NFIRST,NLAST,NIC,NLST,LEFT,LASTNO
      REAL(4) :: ABCDEF
!
   10  FORMAT(/80A1)
   20  FORMAT(A1)
   30 FORMAT(80A1)
   40 FORMAT(1X,80A1)
   50 FORMAT(6(3X,I5))
   60 FORMAT(1X,5A1,6X,5A1)
   70 FORMAT(I5)
   80 FORMAT(128A1)
   90 FORMAT(A9)
!
      FMTWD='FORMAT('
      NDCARD='      END'
      ILOW=97
      IHI=122
      ICAP=32
      APOST=CHAR(39)
      CEE='C'
      SPC=' '
      ZERO='0'
      NINE='9'
      SPACE=CHAR(255)
      EXCLAM='!'
      IEXIT=0
      MORE=0
      ICLOLD=1450
      KFLAG=0
      IDIS=1
      NDIF=0
!
      LUNIN=IOIN
      LABNO=0
      NLINE=0
      IFMT=0
!
      DO J=1,400
         DO K=1,5
            DO I=1,2
               LABEL(J,K,I)=SPC
            END DO
         END DO
      END DO
      NUMCUR=0
!
  110 IJKLMN=1
!
!     CLEAR TEXT BUFFER
!
      DO I=1,80
         BUF(I)=SPC
      END DO
      CLINE(1)=SPC
!
!     READ IN ONE LINE OF TEXT FROM SOURCE FILE
!
!!      DO I=1,1450
!!         CLINE(I)=SPC
!!      END DO
      call clrll(cline)
      call clrll(aline)	
      CALL BUFIN(ALINE,IERR,LUNIN)
      DO I=1,ICLEN
         CLINE(I+1)=ALINE(I)
      END DO
! NEXT WAS GOTO 610 IN ORIGINAL-WHICH WAS 610 CONTINUE AFTER C EOF PROCESSING SEC
      IF(IERR.NE.0)GO TO  680
!
  150 IJKLMN=1
      KFLAG=0
      NDIF=0
      IF(ICLEN.EQ.0)THEN
         WRITE(*,160)
!
!     IGNORE THIS LINE COMPLETELY AND LOOK AT THE NEXT ONE
!     (DELETES IT FROM OUTPUT FILE)
!
         GO TO 110
      END IF
  160 FORMAT(' LENGTH = 0 IN LENGTH CHECK - BE SURE TO REMOVE', ' ALL BL&
     &ANK LINES'/' FROM SOURCE FILE'/)
!
!     PASS THROUGH ALL COMMENT CARDS W/O ANY FURTHER ADO BUT REPL C BY !
!
      KHAR=ALINE(1)
      CALL UC1(KHAR)
      IF((KHAR.EQ.CEE).OR.(KHAR.EQ.EXCLAM))THEN
         ALINE(1)=EXCLAM
         WRITE(4,30)(ALINE(I),I=1,ICLEN)
         GO TO 110
      END IF
!
!     SHOW FIRST NON-COMMENT LINE OF MODULE ON STD OUTPUT UNIT
!
      IF(IDIS.EQ.1)THEN
         WRITE(*,40)(ALINE(I),I=1,ICLEN)
         IDIS=0
      END IF
!     NLINE=NLINE+1
      ICONF(NLINE)=0
! ===================================================================
!     MAKE SOME TESTS:
! ======================================================================
!     DOES THIS LINE FORM A CONTINUATION CARD ?
!     DATA ARE PLACED IN ARRAY 'ICONF', WITH INTERPRETATIONS:
!     ---------------------------------------------------------------
!      DOES IT HAVE     IS THIS CARD A  CONTAIN  FOLLOW CARD
!      A CONT. CARD ?   CONTIN. CARD ?  APOST ?  WITH APOST ?
!     ----------------------------------------------------------------
! TRUE     1                  2              4            8     ICONF
!     ----------------------------------------------------------------
!         NO                 NO             NO           NO       0
!         YES                NO             NO           NO       1
!         NO                 YES            NO           NO       2
!         YES                YES            NO           NO       3
!         NO                 NO             YES          NO       4
!         YES                NO             YES          NO       5
!         NO                 YES            YES          NO       6
!         YES                YES            YES          NO       7
!         NO                 NO             NO           YES      8
!
!     THERE ARE MORE,BUT THEY ARE PROBABLY OF NO INTEREST.
!     ------------------------------------------------------------------
!
      IF(NLINE.GT.1)THEN
!
!     MAKES SOME TESTS AND SET SOME FLAG VALUES IN ARRAY 'ICONF'
!
! ----------------------------------------------------------------------
         KHAR=CLINE(2)
         CALL UC1(KHAR)
         IF(KHAR.NE.CEE.AND.CLINE(7).NE.SPC)THEN
!
!     THIS IS NOT A COMMENT CARD AND IT <IS> A CONTINUATION CARD (CC)
!     THEREFORE, INCREMENT ICONF VALUE OF PREVIOUS CARD TO SHOW THAT
!     'NLINE-1' HAS (IS FOLLOWED BY) A CC.
!
            ICONF(NLINE-1)=ICONF(NLINE-1)+1
!
!     AND FLAG CURRENT LINE AS A CONTINUATION CARD
!
            ICONF(NLINE)=2
         END IF
! ----------------------------------------------------------------------
!
!     DOES IT CONTAIN AN APOSTROPHES?
!
! ----------------------------------------------------------------------
!
         DO INK=2,ICLEN
            IF(CLINE(INK).EQ.APOST)THEN
!
!     INCREMENT CURRENT ICONF VALUE BY 4
!
               ICONF(NLINE)=ICONF(NLINE)+4
!
!     AND EXIT FROM CHECK
!
               GO TO 190
            END IF
         END DO
! ----------------------------------------------------------------------
  190    IJKLMN=1
! ----------------------------------------------------------------------
!     IS PREVIOUS CARD A CC. AND. DOES IT CONTAIN AN APOSTROPHE ?
!     IF IT SO, THEN ICONF(NLINE-1) SHOULD BE AT LEAST 2+4=6
!
!     HOWEVER, ALSO WANT TO NOTE CASE THAT PREVIOUS CARD WAS CC AND
!     THAT EITHER IT OR ONE PRIOR TO IT CONTAINED AN APOSTROPHE.
!     NEED TO TRACK A STRING OF CC'S UNTIL A NON-CC SHOWS UP
!
         IF(ICONF(NLINE).EQ.2.AND.ICONF(NLINE-1).EQ.1)GO TO  200
!
                        idum=2
         IF(MOD(ICONF(NLINE-1),idum).NE.0)ICONF(NLINE)=ICONF(NLINE)+8
!
!     ------------------ END OF 'IF (NLINE.GT.1) ' ------------------
      END IF
! ===================================================================
!
  200 IJKLMN=1
!
      IF(CLINE(2).EQ.CEE)GO TO  350
!
!     MIGHT WANT TO MODIFY THE FOLLOWING TO SKIP CASE CONVERSION IF
!     THE LINE IS A FORMAT STMT OR CONTAINS APOSTROPHES, SUCH AS
!     OPEN(FILE='LCASE.TXT') FOR UNIX OR OTHER CASE SENSITVE O/S.
!
!     IF THE LINE CONTAINS AN APOST OR IS PART OF A STRING OF CONTINUAT
!     CARDS WHICH CONTAIN APOSTROPHES, THEN ICONF(NLINE) .GE.4
!     USING THAT FLAG WOULD MAKE THE "WRITE"  WRITE(*,*)'PRINT THIS'
!     UNRECOGNIZABLE AS A KEYWORD, HOWEVER. IS ONE EVER LIKELY TO HAVE
!     A LABEL IN SUCH A LINE ?? WRITE(1,*)=NO,BUT WRITE(*,*,ERR)'SSS'
!     WOULD CAUSE TROUBLE WITH OUT MUCH MORE COMPLICATED ANALYSIS OF
!     THE LINES
!
!     FORCE THE ENTIRE LINE TO UPPER-CASE
!     TO BE SURE THAT KEYWORDS ARE RECOGNIZABLE - TOO BAD,
!
! ** THE FOLLOWING SEVERAL STEPS REPRESENT A SIGNIFICANT CHANGE FROM  **
! ** THE CODING IN VERSIONS PRIOR TO 1.13. THIS VERSION TAKES SPECIAL **
! ** ACTIONS TO AVOID CONVERTING CONTENTS OF FORMAT STATEMENTS TO     **
! ** UPPER CASE. THE ORIGINAL CODING READ AS FOLLOWS:                 **
!
!C     TO BE SURE THAT KEYWORDS ARE RECOGNIZABLE - TOO BAD,
!C
!      DO 190 J=1,ICLEN
!         ITST=ICHAR(ALINE(J))
!         IF(ITST.LT.ILOW.OR.ITST.GT.IHI) GOTO 190
!         ALINE(J)=CHAR(ITST-ICAP)
!         CLINE(J+1)=ALINE(J)
!  190 CONTINUE
!C
!C     LOOK FOR LABEL IN 'CARD COLUMNS' 1-5
! NOTE THAT FIRST DO LOOP RUNS FROM 1 TO 13 INSTEAD OF 1 TO ICLEN !!
!
      DO J=1,13
         ITST=ICHAR(ALINE(J))
         IF(ITST.LT.ILOW.OR.ITST.GT.IHI)GO TO  205
         ALINE(J)=CHAR(ITST-ICAP)
         CLINE(J+1)=ALINE(J)
  205 MYCDEF=0
        END DO
!
! AND THE FOLLOWING 3 BLOCKS (OR SO) DID NOT APPEAR AT ALL PRIOR TO 1.13!
!
      DO J=1,7
           FMTTST(J:J)=ALINE(J+6)
      END DO
        IF (FMTTST.EQ.FMTWD) THEN
           MYCDEF=0
             GOTO 215
        END IF

      DO J=14,ICLEN
         ITST=ICHAR(ALINE(J))
         IF(ITST.LT.ILOW.OR.ITST.GT.IHI)GO TO  210
         ALINE(J)=CHAR(ITST-ICAP)
         CLINE(J+1)=ALINE(J)
!NEXT MOVED MANUALLY INSIDE 6-21-97
  210 MYCDEF=0
      END DO
  215 IJKLMN=1
!
!     LOOK FOR LABEL IN 'CARD COLUMNS' 1-5
!
      LC=0
      DO K=1,5
         ALABL(K)=SPC
      END DO
      DO J=2,6
         I=J
         KHAR=CLINE(J)
         IF(KHAR.EQ.SPC)GO TO  240
         IF(KHAR.LT.ZERO.OR.KHAR.GT.NINE)GO TO  250
         LC=LC+1
         ALABL(LC)=KHAR
!NEXT MOVED MANUALLY INSIDE LOOP 6-21-97
  240 MYCDEF=0
      END DO
  250 IJKLMN=1
!
!   IF LC IS STILL ZERO, THERE WAS NO LABEL DEFN IN COLS 1-5
!     BUT.. IT COULD BE THE END OF A PROGRAM OR SUBROUTINE
!     I<5 MEANS THAT NON-NUMERAL KICKED US OUT OF THE LOOP, SO
!     ANY NUMBERS WHICH WERE THERE ARE ILLEGAL IN A LABEL-SENSE
!
      IF(LC.EQ.0)GO TO  350
      LABNO=LABNO+1
!
!     CONVERT ALABL() INTO RIGHT-JUSTIFIED FORM
!
      LC=5
      DO K=1,5
         VALUE(K)=SPC
      END DO
      K=LC
  280 KHAR=ALABL(K)
      IF(KHAR.EQ.SPC)GO TO  290
      VALUE(LC)=KHAR
      LC=LC-1
  290 K=K-1
      IF(K.NE.0)GO TO  280
      DO K=1,5
         ALABL(K)=VALUE(K)
         CLINE(K+1)=VALUE(K)
         ALINE(K)=CLINE(K+1)
         VALUE(K)=SPC
      END DO
!
!     USE NTOASC TO CREATE ASCII CODES OF CURRENT VALUE OF LABNO
!
      NEWNUM=(LABNO-1)*INCRMT+LFIRST
      CALL NTOASC(NEWNUM,VALUE)
!
!     ADD LATEST LABEL'S VALUE TO THE CORRESPONDENCE TABLE
!
      DO J=1,5
         LABEL(LABNO,J,2)=VALUE(J)
         LABEL(LABNO,J,1)=ALABL(J)
      END DO
!
!     IC=74
!     DO 290 K=2,73
      IC=ICLEN+2
      DO K=2,ICLEN
         IC=IC-1
         IF(CLINE(IC).NE.SPC)GO TO  330
      END DO
  330 ICLEN=IC
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
  340 FORMAT(/79A1)
  350 IJKLMN=1
!
!     DO SPACE-CHARACTER DELETIONS TO PREVENT BROKEN KEYWORDS
!
!     BEGIN GOBBLING OF SPACE-CODES IN AND TO THE RIGHT OF COL 7
!     SKIP COMPRESS FOR VERY SHORT LINES, COMMENT LINES, AND ANY
!     OTHER LINE CONTAINING AN APOSTROPHE
!
      IF(CLINE(7).NE.SPC.AND.IFMT.EQ.1)GO TO  590
!
!     IF PRESENT CARD ISN'T A CC AND THE FORMAT FLAG IS ON, TURN IT OFF
!
      IF(CLINE(7).EQ.SPC.AND.IFMT.EQ.1)IFMT=0
      IF(ICLEN.LT.8)GO TO  590
      IF(CLINE(2).EQ.CEE)GO TO  590
!
!     TEST FOR APOSTROPHE
!
!     FIND POSITION OF FIRST NON-SPC CHAR IN THE WORKING FORTRAN COLS
!     BEGINNING AT COL 7 , WHICH IS POSITION 8 OF CLINE. OBJECTIVE IS
!     TO TRY TO MOVE THE STANDARD KEYWORDS INTO COLS 8-11 OF CLINE SO
!     KEYWORD TEST CAN BE PERFORMED. THIS MAY CAUSE TROUBLE WITH FORMAT
!     CONTINUATION CARDS WHETHER STD LABELED FORMATS OR (*,*)-FORMATS
!     TO TRY TO AVOID THAT, USE A SPECIAL BUFFER AND POSTPONE THE LEFT-
!     JUSTIFICATION TO COL 8 OF CLINE UNTIL WE FIND OUT
!
      DO IK=2,7
         BUF(IK)=CLINE(IK)
      END DO
!
      DO IK=8,82
         KHAR=CLINE(IK)
         BUF(IK)=KHAR
         IM=IK
         IF(KHAR.NE.SPC)GO TO  390
      END DO
! ----------------------------------------------------------------------
!
!     ?? IS THE LINE TOTALLY BLANK ? OR WAS THERE A CR BEFORE
!     EVEN COL 7...THAT IS OFTEN THE CASE. IN ANY CASE, ABANDON
!     THE SQUEEZING AND LEAVE THE LINE ALONE
!
  380 FORMAT(' **SQUEEZE ERROR IN <PRE20>**'/' CHECK FOR BLANK LINE AT E&
     &ND OF SOURCE FILE (OR ELSEWHERE).'/' TEXT WAS:'/)
      WRITE(*,380)
      WRITE(*,340)(CLINE(K),K=1,79)
      GO TO 590
! ----------------------------------------------------------------------
  390 IJKLMN=1
!
!     COPY THE REST OF THE LINE ..WITH FIRST CHAR GOING TO COL 7
!     OF BUF()
!
      IM=IM-1
      IC=7
  400 IM=IM+1
      IC=IC+1
      KHAR=CLINE(IM)
      BUF(IC)=KHAR
      IF(IM.LE.ICLEN)GO TO  400
      ICOLD=ICLEN
      ICLEN=IC
!
!     NOW BUF() SHOULD CONTAIN "LEFT-JUSTIFIED" VERSION OF CLINE
!     JUSTIFIED TO COL 7 OF FORTRAN LINE (8 OF CLINE)
!     BUT - ICLEN APPLIES TO BUF ARRAY AND NOT TO CLINE!
!
!
!     SEARCH FOR UPTO FOUR MAGIC LETTERS. IF FOUND, ABANDON FURTHER
!     SPACE-CODE OMISSIONS.
!
      DO K=1,4
!  410 XWORD(K)=BUF(K+7)
         WORD(K:K)=BUF(K+7)
      END DO
!
!     NEVER, NEVER, NEVER SQUEEZE A FORMAT STATEMENT THAT
!
      IF(WORD.EQ.KEYWDS(23))IFMT=1
!
!     DON'T SQUEEZE COMMON BLOCKS OR CONTIN.CARDS FOR THEM:
!
!      IF(WORD.EQ.KEYWDS(2))IFMT=1
!
!     OR WRITE COMMANDS THAT CONTAININ APOSTROPHES
!
      IF(WORD.EQ.KEYWDS(22).AND.ICONF(NLINE).GE.4)IFMT=1
!
!     OR DATA STMTS THAT CONTAIN APOSTROPHES
!
      KFLAG=0
      IF(WORD.EQ.KEYWDS(9).AND.ICONF(NLINE).GE.4)IFMT=1
!
!
      IF(WORD.EQ.KEYWDS(32))THEN
!
! WE HAVE 'ELSE' OR 'ELSEIF' OR 'ELSE IF'
! IS ONE OF THE NEXT TWO CHARACTERS AN "I" ?
!
         IF(ICLEN.EQ.11)THEN
!   IT MUST BE PLAIN "ELSE"
            ABCDEF=2
         ELSE
!   LINE IS LONGER THAN THAT, FIND NEXT NON-BLANK CHAR
            IF(BUF(12).EQ.'I'.AND.BUF(13).EQ.'F')THEN
! WE HAVE AN ELSEIF AND NEED TO INSERT A SPACE! THEN SKIP MORE COMPRESSI
					CALL CLRABF(ABUF)
               DO I=12,ICLEN
                  ABUF(I+1)=BUF(I)
               END DO
               BUF(12)=' '
               ICLEN=ICLEN+1
               DO I=13,ICLEN
                  BUF(I)=ABUF(I)
               END DO
               IFMT=1
               GO TO 480
            END IF
! BUT WE STILL MIGHT HAVE A SPACE FOLLOWING ELSE BEFORE IF
            ABCDEF=7
            DO I=12,ICLEN
               IF(BUF(I).NE.SPC)GO TO  470
            J=I
            END DO
  470       IF(BUF(J+1).EQ.'I'.AND.BUF(J+2).EQ.'F')THEN
               IFMT=1
               GO TO 480
            END IF
         END IF
! END OF IF(WORD.EQ.KEYWDS(32) SUB BLOCKS:
      END IF
!
! -------------------------------------
! KEYWDS(13) <-> 'END ';  (36) <-> 'ENDI'
!
  480 IJKLMN=1
!
      IF(WORD.EQ.KEYWDS(34))THEN
!  IT IS GOTO AND NEEDS INSERTION OF A SPACE CODE AFTER THE GO
         ABCDEF=12
      END IF
!
!       IF(WORD.EQ.KEYWDS(13).OR.WORD.EQ.KEYWDS(36))THEN
      IF(WORD.EQ.KEYWDS(13).OR.WORD.EQ.KEYWDS(36).OR.WORD.EQ.KEYWDS(39))&
     &THEN
!
! WE MAY HAVE AN 'END' CARD, OR AN 'END IF' STATEMENT TO DEAL WITH
! 05-22-97:OOPS! MIGHT ALSO HAVE "END DO" IN SOURCE!!
!     SEE IF THERE IS ANYTHING ELSE ON THE LINE - SUCH AS "IF"
!
         IKOU=0
         IF(ICLEN.LE.10)THEN
!
!         THERE IS NO MORE TEXT, SO I GUESS I HAVE A VALID END-STMT
!     BUT CLINE MAY NOT BE LEFT JUSTIFIED SO FIXIT BEFORE EXIT
!
            DO I=1,72
               IF(I.LE.10)THEN
                  CLINE(I)=BUF(I)
               ELSE
                  CLINE(I)=SPC
               END IF
               IF(I.GT.1)ALINE(I-1)=CLINE(I)
            END DO
            MORE=1
            GO TO 630
         ELSE
            DO JK=11,ICLEN
!
               IF(IKOU.EQ.0)THEN
                  IF(BUF(JK).EQ.SPC.OR.BUF(JK).EQ.SPACE)GO TO  500
                  CHR1=BUF(JK)
                  IKOU=1
                  GO TO 500
               END IF
!
               IF(IKOU.EQ.1)THEN
                  IF(BUF(JK).EQ.SPC.OR.BUF(JK).EQ.SPACE)GO TO  500
                  IKOU=2
                  CHR2=BUF(JK)
                  GO TO 510
               END IF
  500       IJKLMN=1
            END DO
         END IF
!
!     TEST FOR ENDIF
!
  510    IJKLMN=1
         IF(IKOU.EQ.2)THEN
            IF(CHR1.EQ.'I'.AND.CHR2.EQ.'F')THEN
               NDIF=1
               CLINE(8)='E'
               CLINE(9)='N'
               CLINE(10)='D'
               CLINE(11)=' '
               CLINE(12)='I'
               CLINE(13)='F'
               DO JJ=8,13
               ALINE(JJ-1)=CLINE(JJ)
               END DO
               ICLEN=13
               GO TO 630
            END IF
            IF(CHR1.EQ.'D'.AND.CHR2.EQ.'O')THEN
               NDIF=1
               CLINE(8)='E'
               CLINE(9)='N'
               CLINE(10)='D'
               CLINE(11)=' '
               CLINE(12)='D'
               CLINE(13)='O'
               ICLEN=13
               DO JJ=8,13
               ALINE(JJ-1)=CLINE(JJ)
               END DO
               GO TO 630
            END IF
         ELSE
            NDIF=0
         END IF
! 5-22-97: THERE IS THE ENDDO POSSIBLIITY!!!
         IF(NDIF.EQ.0)THEN
            MORE=1
            GO TO 630
         END IF
      END IF
!
!     IF WE ARE LOOKING AT AN END-OF-MODULE STMT, BYPASS MANY STEPS
!
      IF(MORE.EQ.1)GO TO  630
!
!     NOW IF 'NDIF=1' WE ARE LOOKING AT AND 'ENDIF' AND NEED TO COMPRESS
!     IT EVEN THOUGH KFLAG WAS SET ERRONEOUSLY TO 1 BY 'END '
!
!
! 24 JUL 2009: MAYBE I SHOULD USE 40 OR 50 INSTEAD OF 31 IN NEXT LINE???
      DO K=1,31
!     IF(WORD.EQ.KEYWDS(K)) GOTO 440
!
!     I AM GOING TO USE ANOTHER DADBURN FLAG...THIS TIME TO PERMIT
!     LEFTJUSTIFY OF CLINE TO COL 7 IF WE JUST HAD A KEYWORD ..THIS
!     MIGHT NOT FIXUP THE PROBLEMS WITH COMPLICATED ')' TYPE OF EXPRESSI
!     USED BY RALPH STEINHOFF, ET AL HOWEVER
!
!     NO, IT DOESN'T - DADBURNIT !!! MY PRESENT SCHEMES CANT DIG-OUT
!     LABELS FROM LINES LIKE:
!
!      IF(CARD(IPOS:IPOS).EQ.'(')GOTO21
!      READ(8,'A',END=65)
!
         IF(WORD.NE.KEYWDS(K))GO TO  540
         KFLAG=1
         GO TO 550
 !NEXT LINE MANUALLY MOVED INSIDE THE LOOP 6-21
  540 MYCDEF=0
      END DO
  550 IJKLMN=1
!
!     NOW IF 'NDIF=1' WE ARE LOOKING AT AND 'ENDIF' AND NEED TO COMPRESS
!     IT EVEN THOUGH KFLAG WAS SET ERRONEOUSLY TO 1 BY 'END '
!
      IF(NDIF.EQ.1.AND.KFLAG.EQ.1)KFLAG=0
!
!     APPARENTLY FOUND NO KEYWDS, SO COMPRESS ALL REMAINING
!     SPACE CODES IN THE LINE. START AT COL 11
!
!     CLEAR CLINE TO SPACE CODES
!     BUT TRY TO MINIMIZE WORK DONE - ONLY PART OF THE IME WILL NOT
!     BE OVERWRITTEN IN NEXT STEPS
!
      IF(ICLEN.LT.ICOLD)THEN
         DO I=ICLEN,ICOLD
!  470    CLINE(I)=SPC
            CLINE(I)=SPC
            IF(I.GT.1)ALINE(I-1)=CLINE(I)
         END DO
         END IF
!
!     RECOPY BUF INTO CLINE TO LEFT-JUSTIFY CLINE
!
         DO IK=2,ICLEN
            CLINE(IK)=BUF(IK)
            ALINE(IK-1)=CLINE(IK)
         END DO
!
!     TRY SKIPPING AROUND THE COMPRESSION STEP IF IFMT=1
!
         IF(IFMT.EQ.1)GO TO  590
!
!     SKIP COMPRESSION ON KFLAG APPLIES TO FIRST 22 KEYWDS AT PRESENT
!     HOWEVER,I <<DO>> WANT TO COMPRESS 'ENDIF'
!
         IF(KFLAG.EQ.1)GO TO  590
!
!     IAPF IS AN APOSTROPHE FLAG-DON'T DELETE SPC CODES BETWEEN APOSTS!
!
         IAPF=0
!
!     LETS TRY STARTING AT CLINE(8) WHICH IS ALINE(7)
         IK=7
         IC=7
  570    IK=IK+1
         KHAR=CLINE(IK)
         IF(IK.GT.ICLEN)GO TO  580
         IF(KHAR.EQ.APOST)IAPF=IAPF+1
                  idum=2
         IDONT=MOD(IAPF,idum)
!
!     IDONT=0 MEANS HAVE COLLECTED EVEN NUMBER OF APOSTS...OK TO BEGIN
!     OMITTING SPC CODES
!
         IF(IDONT.EQ.0.AND.KHAR.EQ.SPC)GO TO  570
!
         IC=IC+1
         CLINE(IC)=KHAR
         IF(IC.GT.1)ALINE(IC-1)=CLINE(IC)
         GO TO 570
  580    IF(IC.LT.ICLEN)ICLEN=IC
  590    IJKLMN=1
!
!     NOW WE HAVE LOOKED IN BUF() FOR KEY WORDS AND ARRIVE HERE IF ONE
!     WAS FOUND, INWHICH CASE CLINE WAS NOT SQUEEZED TO REMOVE SPC CODES
!     IF THE LINE ITSELD CONTAINS APOST'S BUT DIDN'T CARRY A KEY WORD
!     THEN I WANT TOLEAVE THEM INCOMPRESSIBLE. THERE IS NO SIMPLE WAY TO
!     KNOW WHETHER SPC CODES ARE WANTED OR ARE SURPLUS
!
!     FOR A STANDARD LABELED FORMAT, RETAIN ALL SPC CODES:
!
         IF(IFMT.EQ.1.AND.ICONF(NLINE).LT.4)GO TO  610
!
!     AND HAZZARD A GUESS ABOUT THE OTHER CASES
!
!     REPLACE STANDARD SPC CODES BY SPECIAL CODE 0FFH IN LINES
!     WHICH CONTAIN APOSTROPHES. USE THESE TO  BLOCK COMPRESSION
!     IN LINE LENGTH SEARCHES IN REL2 AND SCRP
!
         NTEST=ICONF(NLINE)
         IF(NTEST.EQ.0)GO TO  610
                  idum=8
         IF(NTEST.GE.8)NTEST=MOD(NTEST,idum)
                  idum=4
         IF(NTEST.GE.4)NTEST=MOD(NTEST,idum)
!
!     IF NTEST IS 0, THEN 4 IS A PART OF ICONF SUM, SO THERE ARE
!     APSOTROPHES IN NLINE
!
!
         IF(NTEST.EQ.0)THEN
!
!     DO THE REPLACEMENT BUT ONLY IN COLS 8-73 (RECALL OFFSET BY 1)
!     HOWEVER, ICLEN MAY WELL HAVE SKIPPED OVER WHAT SHOULD HAVE BEEN
!     A SIGNIFICANT SPC CODE AT RH END OF A CARD CONTAINING FORMAT
!     INFORMATION, EITHER  LABELED OR VIA (*,*)'PRINT THIS' SETUP.
!     SO FILL OUT THE WHOLE LINE IF WE HAVE A LABELED FORMAT:
!
!     ASSUME (NOT NECESSSARILY CORRECT) THAT (*,*)'AKJSDAKSDH' KIND
!     OF LINES ARE COMPELTE AT ICLEN IF THEY CONTAIN AN EVEN NUMBER
!     OF APOSTROPHES. NEED TO FIND OUT!
!
            NAPOS=0
            DO K=2,ICLEN
               IF(CLINE(K).EQ.APOST)NAPOS=NAPOS+1
            END DO
                        idum=2
            NCHEK=MOD(NAPOS,idum)
!
!     IF NCHEK IS ZERO, NAPOS IS EVEN. SKIP BACK FILLS:
!
            IF(NCHEK.EQ.0)GO TO  610
!
!       DO BACK FILLS ONLY IF ICLEN IS LESS THAN 72
!
            IF(ICLEN.LT.72)THEN
               DO K=ICLEN+1,73
!  530       CLINE(K)=SPACE
                  CLINE(K)=SPC
                  IF(K.GT.1)ALINE(K-1)=CLINE(IC)
               END DO
!
            END IF
        END IF
  610       IJKLMN=1
            KMAX=ICLEN
!
            DO K=8,KMAX
               IF(CLINE(K).EQ.SPC)THEN
                  CLINE(K)=SPACE
                  ALINE(K-1)=CLINE(K)
               END IF
            END DO
  630       IJKLMN=1
  640       FORMAT(80A1)
  650       FORMAT(5X,I1,72A1)
!
            IF(WORD.EQ.KEYWDS(2))THEN
               CALL PCOMMN(CMNNAM,NFLAG)
!     WHAT NOW? CREATE A NEW SPECIAL MODULE FILE
!     WHICH WILL BE PLACED AT BEGINNING OF CURRENT MODULE
!     ? AND WHAT ABOUT INTERFACE STATEMENTS ??
               CALL MKCMBK(CMNNAM,NFLAG)
!     ADD THIS MODULE TO THE CURMOD ARRAY
               NUMCUR=NUMCUR+1
               CURMOD(NUMCUR)=CMNNAM
!  BUT! REMEMBER THAT I NEED TO INSERT  'USE' STMTS INTO
!  TEMPCOPY.FOR!!
!  AND, AVOID MULTIPLE DEFINITIONS OF MODULES!!!
!
               GO TO 670
            END IF
!
!
!     TEST LINE LENGTH AND WRITE OUTPUT LINE. APPEND CONTINUATION CARDS
!     AS NEEDED. USE DIFFERENT FORMATS FOR SCREEN AND FILE WRITING
!
            NFIRST=2
            NLAST=73
            NIC=1
            IF(ICLEN.LE.72)NLAST=ICLEN
            NLST=NLAST
!
!     NLST SHOULD POINT TO FINAL NON-SPC CHAR POSITION LESS THAN NLAST
!
!            WRITE(*,640)(CLINE(K),K=NFIRST,NLST)
            WRITE(4,640)(CLINE(K),K=NFIRST,NLST)
!
!     PRINT CCARDS AS NEEDED
!
  660       LEFT=ICLEN-NLAST
            IF(LEFT.LE.0)GO TO  670
            NFIRST=NLAST+1
            idum=nfirst+65
            NLAST=MIN(ICLEN,idum)
            NLST=NLAST
            WRITE(4,650)NIC,(CLINE(K),K=NFIRST,NLST)
            NIC=NIC+1
            IF(NIC.GT.9)NIC=1
            GO TO 660
!
  670       IJKLMN=1
!
            IF(IEXIT.NE.0)GO TO  710
!
            IF(MORE.EQ.1)GO TO  720
            IF(IERR.EQ.0)GO TO  110
!     ===============================
!     END OF STANDARD PROCESSING LOOP
!     ===============================
!
!     EOF PROCESSING SECTION
!     -----------------------------------------------------------------
  680       IJKLMN=1
            IF(IERR.EQ.-1)THEN
!
!     SET SPECIAL ERROR CODE TO ALLOW DOUBLE PASS OF "STD. PROCESSING"
!
               IERR=-5
!
!     LOOP BACK TO HANDLE VALID ALINE() ARAY
!
               GO TO 150
            END IF
!
            IF(IERR.EQ.-2)THEN
               IEXIT=2
               GO TO 150
            END IF
!
            IF(IERR.EQ.-3)THEN
               IEXIT=3
               GO TO 150
            END IF
!
            IF(IERR.EQ.-4)THEN
               WRITE(4,90) NDCARD
               GO TO 750
            END IF
!
!     SECOND PASS ERROR PROCESSING FOR THE ORIGINAL IERR = -1 CASE
!
            IF(IERR.EQ.-5)THEN
!
!     PROCESS APPARENTLY VALID CONBUF WHOSE READ SET EOF AND IERR=-1
!
               IEXIT=1
               IC=73
               DO  I=1,72
!  620    ALINE(I)=CONBUF(I)
                  ALINE(I)=CONBUF(I:I)
                  CLINE(I+1)=CONBUF(I:I)
                  END DO
!                 CONTINUE
                  DO I=1,72
                     KHAR=ALINE(I)
                     IC=IC-1
                     IF(KHAR.NE.SPC.AND.KHAR.NE.SPACE)GO TO  700
                  END DO
  700             ICLEN=IC
                  GO TO 150
               END IF
! ---------------------------------------------------------------------
!     PSEUDO EXIT PROCESSING (AFTER ONE LAST PASS AT STD. PROCESSING)
! ---------------------------------------------------------------------
  710          IJKLMN=1
               IF(IEXIT.EQ.1)THEN
                  WRITE(*,*)'END OF FILE WITHOUT MODULE END STATEMENT. E&
     &ND STATEMENT APPENDED (TYPE=2).'
                  WRITE(4,90) NDCARD
                  GO TO 750
               END IF
!
               IF(IEXIT.EQ.2)GO TO  750
               IF(IEXIT.EQ.3)THEN
                  WRITE(4,90) NDCARD
                  GO TO 750
               END IF
!
!     SET END OF FILE FLAG FOR DRIVER
!
  720          MORE=1
!
!     RETURN WHEN END-STMT FOUND, BUT NOT EOF...END OF A MODULE
!
  730          IJKLMN=1
               LASTNO=LABNO
               LMAX=LASTNO
!
!     PRINT SOME OF LABEL TABLE
!     DO 411 LABNO=1,LASTNO
! 411 WRITE(*,60)(LABEL(LABNO,J,1),J=1,5),(LABEL(LABNO,K,2),K=1,5)
!
               RETURN
!
!     ------------------------------------------------------------------
!
!     END OF INPUT FILE REACHED
!     SET FLAG TO TELL MAIN THAT THERE ARE NO MORE ROUTINES TO HANDLE
!
  750          MORE=-1
               GO TO 730
      END SUBROUTINE PRE20
! **********************************************************************
      SUBROUTINE RESQEZ(NFIRST,NLST)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN
      INTEGER(2), INTENT(INOUT) :: NFIRST
      INTEGER(2), INTENT(INOUT) :: NLST
!
!     17-MAR-1989
!
!     LOCATES RIGHT MOST NON-SPACE CHARACTER IN ARRAY CLINE
!     STARTING FROM COLUMN=NFIRST. RETURNS RESULT VIA NLAST, THAT IS
!     RIGHT-MOST NON-SPACE CHAR IS IN CLINE(NLST)
!
      CHARACTER(LEN=1) :: SPC
      INTEGER(2) :: ITOP,K,KMAX,IC
!
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
!      DATA SPC /' '/
!
      SPC=' '
      ITOP=NLST+1
      KMAX=NLST-NFIRST+1
      DO K=1,KMAX
         IC=ITOP-K
         IF(CLINE(IC).NE.SPC)GO TO  20
      END DO
   20 IJKLMN=1
      NLST=IC
      RETURN
      END SUBROUTINE RESQEZ
! **********************************************************************
      SUBROUTINE SCRP
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
!
!     REVISED 27 MAR 1989
!      30 AUG 1985.REVISED 12 APR 1986 FOR MS-DOS VERSION
!     5-JAN-1989: DELETED INSERTION OF SOME EXTRA SPC CODES
! **********************************************************************
!     SEARCH FOR OLD/ REPLACE WITH NEW FORTRAN LABELS IN ARRAY CLINE()
! **********************************************************************
      CHARACTER(LEN=1) :: OUTBUF(1450)
      CHARACTER(LEN=1) :: SPACE
      CHARACTER(LEN=1) :: TMPLAB(5)
      CHARACTER(LEN=1) :: OLDLAB(5)
      CHARACTER(LEN=1) :: NEWLAB(5)
      CHARACTER(LEN=1) :: KHAR
      CHARACTER(LEN=1) :: SPC
      INTEGER(2) :: LEN,NEWLEN,IOMIT,IK,ISCERR,ITRF,K,L,LNO,M
      INTEGER(2) :: MATCH,ISTOP,ISTART,J,IC,I1,I2,IADD,JMIN,IS
      INTEGER(2) :: NSPARE,ITOP,I,KK,KKK,J1,J2
      REAL(4) :: ZZZ
!
!     PURPOSE IS TO SEARCH THRU LABEL TABLE AND REPLACE
!     OLD LABEL BY THE NEW ONE. THE LOCATION OF THE OLD
!     ONE IS INDICATED BY THE INTEGERS FIRST AND LAST.
!     IBEG = COL OF CLINE IN WHICH 1-ST CHAR OF OLD LABEL APPEARS
!     IFIN =          ''           LAST          ''
!
!
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   10 FORMAT(1X,80A1)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   20 FORMAT(' NO MATCH FOUND FOR LABEL -->',5A1)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   30 FORMAT(' OLD = ',5A1,2X,'. MATCH = ',5A1,2X,'==>',5A1)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   40 FORMAT(' FATAL ERROR IN SCRP OF UNKNOWN ORIGIN.'/' ISCERR = ',I4/'&
     &  IBEG = ',I5,'.  IFIN = ',I5,'.   LN = ',I5,' I1 = ',I3,'.  I2 = &
     &',I3/' J1 = ',I5,'. LEN = ',I5,'. NEWLEN = ',I5,/' LEN = ',I5,'. N&
     &EWLEN = ',I5,'. IOMIT = ',I5,'. IS = ',I5,/' ICLEN = ',I5,', IC = &
     &',I5,', MATCH = ',I5/' K = ',I5,',  M = ',I5,', L = ',I5,', LNO = &
     &',I5/' LMAX = ',I5)
!
      SPC=CHAR(32)
      SPACE=CHAR(255)
      J1=0
      LEN=0
      NEWLEN=0
      IOMIT=0
      IK=0
      ISCERR=-1
!
!     INITIALIZE TRUNCATION WARNING FLAG ITRF
!
      ITRF=0
!
!     TRANSFER OLD LABEL FROM ARRAY LABL INTO OLDLAB()
!
      DO K=1,1450
      OUTBUF(K)=SPC
      END DO
      DO K=1,5
      OLDLAB(K)=LABL(LN,K)
      END DO
!
!     AND BEGIN SEARCH
!     BUT, BE AWARE THAT OLD LABEL MAY BE ON A CONTINUATION CARD IN SOME
!     CASES.
!
      IF(LMAX.GT.400)THEN
         ISCERR=1
         GO TO 400
      END IF
      DO L=1,LMAX
         LNO=L
         DO K=1,5
         TMPLAB(K)=LABEL(L,K,1)
         END DO
         MATCH=1
         DO M=1,5
            IF(OLDLAB(M).NE.TMPLAB(M))MATCH=0
         END DO
         IF(MATCH.EQ.1)GO TO  100
!
!     SEE IF THE CURRENT LINE HAS A CONTINUATION CARD. IF IT DOES, READ
!     THE NEXT CARD IN TO CONBUF AND BACKSPACE THE INPUT FILE. THEN NEED
!     TO SEARC 'CONBUF' FOR THE REST OF THE LABEL. IN MOST CASES, THE
!     LEADING NUMERICAL VALUES ON CC WILL BE PART OF AN ERRONEOUS LABEL
!     FOUND BY REL2. IN EXTREME CASES, CONTINUATION CARDS MAY CONTAIN
!     SEVERAL LABELS. THAT WILL BE A REAL PAIN ! LIKELIEST FOR
!
!     GOTO (NN,NN,NNM,MMM,............................................13
!    &23,3004), IDV
!
!     WHERE OLDLAB='13' IS THOUGHT TO BE LABEL INSTEAD OF '1323',
!     AND LABEL 3004 WILL BE MISSED COMPLETELY!
!
!
      END DO
      WRITE(*,20)(OLDLAB(K),K=1,5)
      ISCERR=2
      GO TO 400
  100 IJKLMN=1
      DO K=1,5
      NEWLAB(K)=LABEL(LNO,K,2)
      END DO
!
!     DO WE HAVE A SPECIAL TYPE OF LABEL REQUIRING INSERTION OF
!     SPACE-CODES FOR READABILITY ?
!
      IF(LTYPE.EQ.2.OR.LTYPE.EQ.3)THEN
!
!     THE LINE CONTAINS A GOTO AND WE NEED TO CLEAN IT UP
!
!        WRITE(*,*)(CLINE(K),K=1,ICLEN)
! COPY UP THROUGH THE "O" IN GO INTO OUTBUF
         ISTOP=IBEG-3
         DO K=1,ISTOP
         OUTBUF(K)=CLINE(K)
         END DO
! ADD SPACE
         OUTBUF(ISTOP+1)=SPC
! COPY THE REST
         ISTART=ISTOP+1
         DO K=ISTART,ICLEN
         OUTBUF(K+1)=CLINE(K)
         END DO
         ICLEN=ICLEN+1
         IBEG=IBEG+1
         IFIN=IFIN+1
! RECOPY
         DO K=1,ICLEN
         CLINE(K)=OUTBUF(K)
         END DO
!        WRITE(*,*)(CLINE(K),K=1,ICLEN)
      END IF
!
      IF(LTYPE.EQ.3)GO TO  150
      IF(LTYPE.EQ.6)GO TO  200
      GO TO 230
  150 IJKLMN=1
!
!     FIRST COPY CLINE(1)...CLINE(FIRST-5) INTO OUTBUF
!
!      ISTOP=IBEG-5
      ISTOP=IBEG-1
      IC=1
  160 OUTBUF(IC)=CLINE(IC)
      IC=IC+1
      IF(IC.GT.1450)THEN
         ISCERR=3
         GO TO 400
      END IF
      IF(IC.LE.ISTOP)GO TO  160
!
!     NOW SHIFT CLINE(IBEG-4)...CLINE(ICLEN) TO RIGHT BY ONE POS.
!
      IC=ICLEN
      ICLEN=ICLEN+1
      IF(ICLEN.GT.1450)ITRF=ITRF+1
!      ISTOP=IBEG-4
      ISTOP=IBEG
!
!     INSERT THE SPC CODE
!
      OUTBUF(ISTOP)=SPACE
!
  170 OUTBUF(IC+1)=CLINE(IC)
      IC=IC-1
      IF(IC.LE.0)THEN
         ISCERR=4
         GO TO 400
      END IF
      IF(IC.GE.ISTOP)GO TO  170
!
!     SHIFT VALUES OF FIRST AND LAST
!
      IBEG=IBEG+1
      IFIN=IFIN+1
      ICLEN=ICLEN+1
      IF(ICLEN.GT.1450)ITRF=ITRF+1
!
!     NOW RE-COPY THE TEXT INTO CLINE
!
  180 IJKLMN=1
      IF(ICLEN.LE.0.OR.ICLEN.GT.1450)THEN
         ISCERR=5
         GO TO 400
      END IF
      DO J=1,ICLEN
      CLINE(J)=OUTBUF(J)
      END DO
!
!     AND PROCEDE WITH REPLACEMENT
!
      GO TO 230
  200 IJKLMN=1
!
!     PUT A SPC-CODE BEFORE DO-LOOP PARAMETER (LTYPE=6)
!     FIRST COPY CLINE(1)...CLINE(LAST) INTO OUTBUF
!
      IC=1
  210 OUTBUF(IC)=CLINE(IC)
      IC=IC+1
      IF(IC.GT.1450)THEN
         ISCERR=6
         GO TO 400
      END IF
      IF(IC.LE.IFIN)GO TO  210
!
!     SHIFT TEXT TO RIGHT BY ONE POSITION
!
      ISTOP=IFIN+1
      IC=ICLEN
      ICLEN=ICLEN+1
      IF(ICLEN.GT.1450)ITRF=ITRF+1
  220 OUTBUF(IC+1)=CLINE(IC)
      IC=IC-1
      IF(IC.LE.0)THEN
         ISCERR=7
         GO TO 400
      END IF
      IF(IC.GE.ISTOP)GO TO  220
!
!     STICK IN SPC
!
      OUTBUF(IFIN+1)=SPACE
!
!     AND ...
!
      GO TO 180
  230 IJKLMN=1
!
!     BEGIN REPLACEMENT
!
      LEN=IFIN-IBEG+1
!
!     LEN IS # OF CHARS IN OLD LABEL
!     NEWLEN IS # OF CHARS IN NEW LABEL
!
!     MUST FIND NEWLEN-HERE
!
      I1=90
      I2=0
      DO J=1,5
         K=J
         KHAR=NEWLAB(J)
         IF(LTYPE.GT.1)LREF(LNO)=.TRUE.
         IF(KHAR.EQ.SPC)GO TO  240
         IF(K.LT.I1)I1=K
         IF(K.GT.I2)I2=K
! NEXT LINE MANUALLY PLACED INSIDE THE DO_LOOP 6-20-97
  240 MYCDEF=0
      END DO
      NEWLEN=I2-I1+1
!     COMPARE
!     NEXT LE WAS LT
      IF(LEN.LE.NEWLEN)GO TO  270
      IF(LEN.GT.NEWLEN)GO TO  320
!
!     I GUESS THEY ARE OF THE SAME LENGTH, SO CAN DO DIRECT
!     SUBSTITUTIONS.
!
      J1=IBEG
      J2=IFIN
      IK=I1-1
      DO J=J1,J2
         IK=IK+1
      CLINE(J)=NEWLAB(IK)
      END DO
      IF(LTYPE.GT.1)LREF(LNO)=.TRUE.
      GO TO 410
  270 IJKLMN=1
      IF(IFIN.LE.5)GO TO  380
!
!     LEN IS LESS THAT NEWLEN. WILL HAVE TO INSERT CHARACTERS
!     SOMEWHERE!
!
      IF(LTYPE.EQ.3.OR.LTYPE.EQ.6.OR.LTYPE.EQ.2)THEN
         IADD=NEWLEN-LEN+1
      ELSE
         IADD=NEWLEN-LEN
      END IF
!
!     WILL OFTEN INSERT 1 SPC-CODE AHEAD OF NEW LABEL
!     AND MUST MOVE CHARS IN CLINE TO RIGHT BY IADD-COLUMNS
!     TO MAKE ROOM.
!     J1 POINTS TO 1-ST CHAR TO SHIFT TO RIGHT
!     JMIN IS FINAL CHAR TO BE RIGHT-SHIFTED
!     'IS' POINTS TO WHERE CHAR IN CLINE(J1) WILL BE PLACED
!
      J1=ICLEN
      JMIN=IFIN+1
      IS=ICLEN+IADD
      ICLEN=IS
      IF(ICLEN.GT.1450)ITRF=ITRF+1
  280 IJKLMN=1
      CLINE(IS)=CLINE(J1)
      IS=IS-1
      IF(IS.LE.0)THEN
         ISCERR=8
         GO TO 400
      END IF
      J1=J1-1
      IF(J1.LT.JMIN)GO TO  290
      GO TO 280
  290 IJKLMN=1
!
!     NOW INSERT THE SPC AND THE NEW LABEL
!
      IF(LTYPE.EQ.3.OR.LTYPE.EQ.6.OR.LTYPE.EQ.2)THEN
         J1=IBEG
         CLINE(J1)=SPACE
      ELSE
         J1=IBEG-1
      END IF
      IS=I1-1
!
  300 J1=J1+1
      IS=IS+1
      IF(IS.GT.1450)THEN
         ISCERR=9
         GO TO 400
      END IF
      IF(LTYPE.EQ.6)THEN
         CLINE(J1)=SPC
      ELSE
         CLINE(J1)=NEWLAB(IS)
         LREF(LNO)=.TRUE.
      END IF
      IF(IS.EQ.I2)GO TO  310
!
! HERE IS THE PLACE TO RECOMPRESS AND REMOVE THE EXTRA "NEWLEN" SPACE CO
! STARTING AT ???
      GO TO 300
  310 IJKLMN=1
!
!     LAST INSERTION WAS IN COL J1 OF CLINE. PASS THE INFO BACK TO
!     THE CALLER THRU 'LAST'.
!
      IFIN=J1
      IF(LTYPE.GT.1)LREF(LNO)=.TRUE.
      GO TO 410
  320 IJKLMN=1
!
!     HERE IF LEN>NEWLEN. CAN KEEP EXTRA SPACES OR COMPRESS
!
!     WILL TRY TO KEEP 1 SPACE AHEAD OF THE NUMERALS AND
!     DROP ANY OTHERS. THIS WILL SHORTEN CLINE.
!
!      BUT, KEEP ANY SPACES IF THIS LABEL IS IN COLS 1-5
!
      NSPARE=LEN-NEWLEN
      IF(IFIN.LE.5)GO TO  380
      IF(LTYPE.EQ.3.OR.LTYPE.EQ.6.OR.LTYPE.EQ.2)THEN
         IOMIT=LEN-NEWLEN-1
      ELSE
!
         IOMIT=LEN-NEWLEN
      END IF
!
!     IOMIT IS # OF OLD COLUMNS TO BE OMITTED IN SHIFT OF
!     CLINE TO THE LEFT. THE FIRST OLD NON-LABEL CHARACTER
!     TO BE RETAINED IS THE ONE IN COLUMN LAST+1. IT WILL NOW
!     MOVE OVER INTO COLUMN LAST-IOMIT.
!
      IS=I1-1
      IF(LTYPE.EQ.3.OR.LTYPE.EQ.6.OR.LTYPE.EQ.2)THEN
         J1=IBEG
!
!     INSERT THE FIRST SPACE-CODE AT FIRST
!
         CLINE(J1)=SPACE
      ELSE
         J1=IBEG-1
      END IF
!
!     AND REST OF THE NEW LABEL NEWLAB(I1)...NEWLAB(I2)
!
  330 IJKLMN=1
      IS=IS+1
      IF(IS.GT.1450)THEN
         ISCERR=10
         GO TO 400
      END IF
      J1=J1+1
      IF(IS.GT.5.OR.J1.GT.ICLEN)THEN
         ISCERR=11
         GO TO 400
      END IF
      IF(LTYPE.EQ.6)THEN
         CLINE(J1)=SPC
      ELSE
         CLINE(J1)=NEWLAB(IS)
         LREF(LNO)=.TRUE.
      END IF
      IF(IS.NE.I2)GO TO  330
!
!
!     HERE, THE INSERTION HAS BEEN COMPLETED. THE LAST CHAR. WAS
!     PLACED INTO POSITION J1 OF CLINE. PASS THIS INFO BACK TO
!     THE CALLING ROUTINE THROUGH 'LAST'
! ABOVE REMARK SEEMS TO BE INCORRECT, AT LEAST NOW THAT I AM SUBBING
! SPC FOR LABEL VALUES WHEN LTYPE.EQ.6: THE DO VAR APPEARS TO BEGIN
! IN COLUMN J1+2, WITH SPC CODES IN IBEG TO J1+1.. NO THAT IS NOT RELIAB
! EITHER!
!
      IFIN=J1
      IS=J1+IOMIT
      IF(LTYPE.EQ.2)GO TO  360
  340 IJKLMN=1
      IF((IFIN+NSPARE).GE.ICLEN)ICLEN=IFIN
      IF(IFIN.EQ.ICLEN)GO TO  350
      J1=J1+1
      IS=IS+1
      IF(IS.GT.1450)THEN
         ISCERR=12
         GO TO 400
      END IF
      IF(IS.GT.ICLEN)GO TO  350
      CLINE(J1)=CLINE(IS)
      IF(IS.NE.ICLEN)GO TO  340
  350 IJKLMN=1
!
!     CLEAR ANY TRASH IN CLINE
!
  360 ICLEN=J1
      IF(ICLEN.GT.1450)ITRF=ITRF+1
      ITOP=ICLEN+1
      DO K=ITOP,1450
      CLINE(K)=SPC
      END DO
      ICLEN=J1
      IF(ICLEN.GT.1450)ITRF=ITRF+1
!
      GO TO 410
!
  380 IJKLMN=1
!
!     WANT TO COPY ALL OF NEWLAB-INCLUDING ANY SPC CODES
!
      DO I=1,5
      CLINE(I)=NEWLAB(I)
      END DO
      IF(LTYPE.GT.1)LREF(LNO)=.TRUE.
      GO TO 410
!
!      IRRETRIEVABLE ERROR. WARN USER, BUT CONTINUE PROCESSING.
!
  400 IJKLMN=1
      WRITE(*,*)'PROBABLE **FATAL** ERROR ENCOUNTERED FOR LINE: '
      WRITE(*,10)(CLINE(K),K=1,ICLEN)
      WRITE(*,40)ISCERR,IBEG,IFIN,LN,I1,I2,J1,LEN,NEWLEN,LEN,NEWLEN,IOMI&
     &T,IS,ICLEN,IC,MATCH,K,M,L,LNO,LMAX
      WRITE(*,30)(OLDLAB(K),K=1,5),(TMPLAB(J),J=1,5),(NEWLAB(L),L=1,5)
!     STOP
!      DONE
!
  410 IJKLMN=1
      IF(LTYPE.EQ.6)THEN
! TRY TO REMOVE THE EXTRA SPC CODES WHERE LABEL ONCE WAS FOUND
! ASSUME THAT 1ST EXTRA SPC IS IN COL=IBEG+1 (OFTEN=9) AND THAT
! THE DOLOOP VAR NAME WILL BE FOUND IN COL=IBEG+1+NEWLEN+1
         KK=IBEG
         KKK=IBEG+NEWLEN+2
         DO J=KKK,ICLEN
            KK=KK+1
            CLINE(KK)=CLINE(J)
         J1=KK
         END DO
         ICLEN=J1
         ZZZ=1
         LREF(LNO)=.FALSE.
      END IF
!
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
  440 FORMAT(/' ****** WARNING ***** REVISED LENGTH OF THE FOLLOWING',' &
     &LINE > 1450 COLS'/' CHECK FOR UNWANTED CHARACTER DELETIONS :',/80A&
     &1//)
      IF(ITRF.GE.1)WRITE(*,440)(CLINE(I),I=1,79)
      RETURN
      END SUBROUTINE SCRP
! **********************************************************************
      SUBROUTINE NTOASC(NIN,VALUE)
!I AM SURE THERE IS A SIMPLER WA TO DO THIS BUT I HAVE NOT GOTTEN AROUND
!TO WORKING ON IT (02 SEPT 2009)
      IMPLICIT NONE
      INTEGER(2) :: MYCDEF
      INTEGER(2), INTENT(INOUT) :: NIN
      CHARACTER(LEN=1)  , INTENT(INOUT) :: VALUE(5)
!
!     17 MAR 1989
!
!     CONVERTS A POSITIVE INTEGER ( 0<N<32767) TO A 5-CHARACTER ASCII ST
!     RESULT RETURNED IN 5-CHARACTER QUANTITY NAMED "VALUE"
!
      CHARACTER(LEN=1) :: ZERO
      CHARACTER(LEN=1) :: SPC
      INTEGER(2) :: TEN4,TEN3,TEN2,TEN
      INTEGER(2) :: I,IV,IBASE,NUM,NUM0,NUM1,NUM2,NUM3,NUM4,N
!
      IBASE=48
      ZERO=CHAR(0)
      SPC=CHAR(32)
      TEN4=10000
      TEN3=1000
      TEN2=100
      TEN=10
!
      N=NIN
!
      NUM4=N/TEN4
      VALUE(1)=CHAR(NUM4)
      NUM=N-ICHAR(VALUE(1))*TEN4
      NUM3=NUM/TEN3
      IF(VALUE(1).EQ.ZERO)VALUE(1)=SPC
      VALUE(2)=CHAR(NUM3)
      NUM=NUM-ICHAR(VALUE(2))*TEN3
      NUM2=NUM/TEN2
      IF(VALUE(1).NE.SPC)GO TO  10
      IF(VALUE(2).EQ.ZERO)VALUE(2)=SPC
   10 VALUE(3)=CHAR(NUM2)
      NUM=NUM-ICHAR(VALUE(3))*TEN2
      NUM1=NUM/TEN
      IF(VALUE(2).NE.SPC)GO TO  20
      IF(VALUE(3).EQ.ZERO)VALUE(3)=SPC
   20 VALUE(4)=CHAR(NUM1)
      NUM=NUM-ICHAR(VALUE(4))*TEN
      NUM0=NUM
      IF(VALUE(3).NE.SPC)GO TO  30
      IF(VALUE(4).EQ.ZERO)VALUE(4)=SPC
   30 VALUE(5)=CHAR(NUM0)
!
!     CONVERT THE RAW NUMBERS (0 TO 10) TO ASCII CHARACTER-CODES
!
      DO I=1,5
         IF(VALUE(I).EQ.SPC)GO TO  40
         IV=ICHAR(VALUE(I))+IBASE
         VALUE(I)=CHAR(IV)
!NEXT LINE MOVED MANUALLY TO INSIDE THE LOOP 6-20-97
   40 MYCDEF=0
      END DO
      RETURN
      END SUBROUTINE NTOASC
! **********************************************************************
      SUBROUTINE ISUBS(YES3,YES4,YES5,YES7,YES8,YES9)
      USE RENCOM
      IMPLICIT NONE
      LOGICAL, INTENT(INOUT) :: YES3
      LOGICAL, INTENT(INOUT) :: YES4
      LOGICAL, INTENT(INOUT) :: YES5
      LOGICAL, INTENT(INOUT) :: YES7
      LOGICAL, INTENT(INOUT) :: YES8
      LOGICAL, INTENT(INOUT) :: YES9
!
!     MARCH 25, 1989 (AMI)
!
!     ISIF       YES3
!     ISTHEN     YES4
!     ISENDF     YES5
!     ISELSE     YES7
!     ISELSF     YES8
!     IS END DO: YES9
!
!     17-MAR-1989/5-30-97
!
!     TEST CLINE FOR LEADING PRESENCE OF 'IF('
!
      INTEGER(2) :: I
!      LOGICAL YES6
      CHARACTER(LEN=10) :: XWORD
      CHARACTER(LEN=3) :: WORD3
      CHARACTER(LEN=3) :: YWORD3
!      CHARACTER(LEN=5) :: WORD4
      CHARACTER(LEN=4) :: WORD7
      CHARACTER(LEN=4) :: YWORD7
      CHARACTER(LEN=6) :: WORD8
      CHARACTER(LEN=6) :: YWORD8
      CHARACTER(LEN=6) :: YWORD9
! LENGTH OF WORD5 AND YWORD5 CHANGED FROM 5 TO 6 ON 1-MAY-1997
      CHARACTER(LEN=6) :: WORD5
      CHARACTER(LEN=6) :: YWORD5
      CHARACTER(LEN=10) :: WORD6
      CHARACTER(LEN=10) :: YWORD6
      YWORD3='IF('
      YWORD7='ELSE'
      YWORD9='END DO'
      YWORD8='ELSEIF'
      YWORD5='END IF'
      YWORD6='WRITE(*,*)'
!
      YES3=.FALSE.
      YES4=.FALSE.
      YES5=.FALSE.
!      YES6=.FALSE.
      YES7=.FALSE.
      YES8=.FALSE.
      YES9=.FALSE.
!
!### SEVERAL 6 -> 16 12/3/98
      DO I=7,16
      XWORD(I-6:I-6)=CLINE(I)
      END DO
! TRY TO CIRCUMVENT USE OF EQUIVALENCES
      WORD3=XWORD(1:3)
!      WORD4=XWORD(1:5)
      WORD5=XWORD(1:6)
      WORD6=XWORD(1:10)
      WORD7=XWORD(1:4)
      WORD8=XWORD(1:6)
      IF(WORD3.EQ.YWORD3)THEN
         YES3=.TRUE.
         CALL ISTHEN(YES4)
!     ELSEIF(WORD4.EQ.YWORD4) THEN
!        YES4=.TRUE.
      ELSE IF(WORD5.EQ.YWORD5)THEN
         YES5=.TRUE.
      ELSE IF(WORD5.EQ.YWORD9) THEN
         YES9=.TRUE.
!      ELSE IF(WORD6.EQ.YWORD6)THEN
!         YES6=.TRUE.
      ELSE IF(WORD7.EQ.YWORD7)THEN
         YES7=.TRUE.
      ELSE IF(WORD8.EQ.YWORD8)THEN
         YES8=.TRUE.
      END IF
!
!     SOME COULD BE TRUE AT SAME TIME
!
      IF(YES7.AND.YES8)YES7=.FALSE.
      RETURN
      END SUBROUTINE ISUBS
! *********************************************************************
      SUBROUTINE ISTHEN(YESNO)
      USE RENCOM
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN, MYCDEF
      LOGICAL, INTENT(INOUT) :: YESNO
!
!     25-MAR-1989
!
      CHARACTER(LEN=5) :: WORD
      CHARACTER(LEN=5) :: YWORD
      INTEGER(2) :: I, ISTART, ISTOP, K
!
      YWORD=')THEN'
!
!     IGNORE IRRELEVANT LINES
!
      IF(ICLEN.LT.10)THEN
         YESNO=.FALSE.
         RETURN
      END IF
!
!     SEARCH FROM RIGHT BEGINNING AT ICLEN
!
      ISTART=ICLEN-4
      ISTOP=ICLEN
      K=0
      DO I=ISTART,ISTOP
         K=K+1
      WORD(K:K)=CLINE(I)
      END DO
      IF(YWORD.EQ.WORD)THEN
         YESNO=.TRUE.
      ELSE
         YESNO=.FALSE.
      END IF
      RETURN
      END SUBROUTINE ISTHEN
! *********************************************************************
      SUBROUTINE INDENT(NDTEMP)
      USE RENCOM
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN, MYCDEF
      INTEGER(2), INTENT(INOUT) :: NDTEMP
!
!     17-MAR-1989
!
!     INDENT CLINE BY 'NDTEMP' SPACES TO RIGHT OF COLUMN 7
!
!     INPUTS: CLINE( ) = SOURCE CODE TEXT LINE
!             ICLEN = POINTS TO LAST VALID ENTRY IN CLINE()
!
!     OUTPUTS: CLINE IS PERMANANTLY MODIFIED
!              ICLEN IS ALSO PERMANANTLY ALTERED
!
      CHARACTER(LEN=1) :: SPC
      INTEGER(2) :: MORE, NMAX, NTERMS,I,K
!
!     MAKE SURE THAT WE HAVE ENOUGH SPARE SPACE TO INDENT TO RIGHT
!
      SPC=' '
!
      MORE=NDTEMP+ICLEN
      IF(MORE.GT.1450)THEN
         WRITE(*,*)'ARRAY CLINE IS TOO LONG TO DO INDENTATION - LEFT UNC&
     &HANGED'
         RETURN
      END IF
!
!     GO AHEAD WITH MOVES
!
      NMAX=NDTEMP+ICLEN
      NTERMS=ICLEN-6
      DO I=1,NTERMS
         K=I-1
!
! I=1   CLINE(NDTEMP+ICLEN)=CLINE(ICLEN)
! I=2   CLINE(NDTEMP+ICLEN-1)=CLINE(ICLEN-1)
! I=3   CLINE(NDTEMP+ICLEN-2)=CLINE(ICLEN-2)
!
         CLINE(NMAX-K)=CLINE(ICLEN-K)
      END DO
!
!     NOW FILL IN THE SPACES
!
      NMAX=6+NDTEMP
      DO I=7,NMAX
         CLINE(I)=SPC
      END DO
!
!     INCREASE ICLEN TO REFLECT INSERTIONS
!
      ICLEN=ICLEN+NDTEMP
      RETURN
      END SUBROUTINE INDENT
! **********************************************************************
      SUBROUTINE BUFIN(ALINE,IERR,LUNIN)
      USE RENCOM
      IMPLICIT NONE
      CHARACTER(LEN=1)  , INTENT(INOUT) :: ALINE(1450)
      INTEGER(2), INTENT(INOUT) :: IERR
      integer LUNIN
!
!     12-APR-1989 (WITH "TAB" EXPANSION,EXCEPT LAST LINE)"
!
!     READS CARDS FROM UNIT 'LUNIN' FILE INCLUDING CONTINUATION CARDS
!     UP TO MAX OF 19 CCARDS
!
!     FINAL RESULT IS LEFT IN ARRAY ALINE()
!
      SAVE NC
!
      CHARACTER(LEN=1) :: BLINE(72)
      CHARACTER(LEN=1) :: SPC
      CHARACTER(LEN=1) :: CEE
      CHARACTER(LEN=1) :: KHAR
      CHARACTER(LEN=1) :: WORD(3)
!      CHARACTER(LEN=1) :: ALINE(1450)
      CHARACTER(LEN=1) :: SPACE
      CHARACTER(LEN=1) :: TAB
      CHARACTER(LEN=1) :: EXCLAM
      INTEGER(2) :: ICCOL, NICC, IBASE, IKOU, IC,J, JMAX
      INTEGER(2) :: IJKLMN, MYCDEF, NC, I, LK, LL, ICCRD
!     CHARACTER(LEN=72) :: TMPBUF
!
   10 FORMAT(80A1)
   20 FORMAT(5X,I1,72A1)
   30 FORMAT(' EXPECTED CONTINUATION LINE DID NOT FOLLOW LINE '//1X,72A1&
     &//)
   40 FORMAT(' SERIOUS ERROR IN INPUT TEXT. LINE LENGTH TOO SMALL')
!
      CEE='C'
      SPC=' '
      EXCLAM='!'
      SPACE=CHAR(255)
      TAB=CHAR(9)
      ICLEN=72
      IERR=0
!
!     CLEAR THE BUFFERS COMPLETELY
!
      DO I=1,ICLOLD
      ALINE(I)=SPC
      END DO
      DO I=1,72
         BLINE(I)=SPC
!             CONBUF(I:I)=SPC
      END DO
!
      LN=0
!
!     OTHERWISE, COLLECT INOUT AS FOLLOWS
!
      IF(NLINE.LT.1.OR.NC.EQ.1)THEN
         READ(LUNIN,10,END=160)BLINE
      ELSE
!
!     COPY CONBUF TO BLINE
!
         DO I=1,72
            BLINE(I)=CONBUF(I:I)
         END DO
      END IF
!
      NLINE=NLINE+1
!
      IF(NLINE.GT.9999)THEN
         WRITE(*,*)'PROGRAM ELEMENT LENGTH EXCEEDS MAXIMUM ALLOWED VALUE&
     & OF 9999.'
         WRITE(*,*)'SORRY ABOUT THAT, BUT CANNOT PROCEED.'
         STOP 109
      END IF
!
      IF(NLINE.EQ.1)NC=0
!
!     COPY BLINE INTO FIRST PART OF ALINE, EXPANDING TABS TO 6 SPACES
!
      LK=0
      DO LL=1,ICLEN
         KHAR=BLINE(LL)
         LK=LK+1
         IF(KHAR.NE.TAB)GO TO  90
!     WRITE OVER THE TAB WITH SPC AND ADD 5 MORE
         DO I=1,6
            ALINE(LK)=SPC
            LK=LK+1
         END DO
         LK=LK-1
         GO TO 100
   90    ALINE(LK)=KHAR
!NEXT MANUALLY MOVED INSIDE LOOP 6-23-97
  100 MYCDEF=0
      END DO
      CALL UC1(ALINE(1))
!
!     SKIP SOME PROCESSING IF WE HAVE A COMMENT CARD ON HAND
!
      KHAR=ALINE(1)
      CALL UC1(KHAR)
      IF((KHAR.EQ.EXCLAM).OR.(KHAR.EQ.CEE))THEN
!
!     SET NC=1 TO SHOW THAT CONBUF WAS NOT READ AT ALL ON THIS PASS
!     SINCE COMMENT CARDS PASSED THRU W/O ANY ACTION
!
         NC=1
         GO TO 270
      ELSE
         NC=0
!
      END IF
!
!
!     WANT TO STRING ANY COMPLETE SEQUENCE OF CCARDS TOGETHER AS A
!     SINGLE LINE FOR PROCESSING.
!     SEE IF THERE IS A CCARD TO THIS ONE
!
  120 IJKLMN=1
      ICCRD=0
!
!     READ THE NEXT CARD AND TEST TO SEE IF IT IS A CC
!
!     READ(LUNIN,10,END=160) CONBUF
     READ(LUNIN,'(A72)',END=160)CONBUF
      KHAR=CONBUF(1:1)
      CALL UC1(KHAR)
      IF(CONBUF(6:6).EQ.' '.OR.KHAR.EQ.CEE.OR.KHAR.EQ.EXCLAM.OR.KHAR.EQ&
     &.TAB)THEN
!
!       THIS IS NOT A CONTINUATION RECORD..PREPARE FOR REGULAR READ
!
         GO TO 270
!
      ELSE
         ICCRD=ICCRD+1
!
!       KEEEP IN SYNC WITH ICONF ARRAY NUMBERING FOR NOW
!
!        NLINE=NLINE+1
!
!     I AM NOT SURE WHY I NEED TO BACK SPACE, BUT I DO NEED TO DO SO.
!
!        BACKSPACE LUNIN
! --------------------------------------------------------------------
!     CHECK ALLOWED SIZES OF THINGS
         IF(ICCRD.GT.19)THEN
            WRITE(*,*)'MORE THAN 19 CONTINUATION CARDS FOUND. LIKEY *FAT&
     &AL*'
            GO TO 270
         END IF
! ----------------------------------------------------------------------
!     EXTRACT COLS 7-72 OF CCARD AND APPEND TO ALINE AT POS ICLEN+1
         DO ICCOL=7,72
            NICC=ICLEN+ICCOL-6
            IF(NICC.GT.1450)THEN
               WRITE(*,*)'NICC = ',NICC,' EXCEDDS ARRAY SIZE IN <BUFIN15&
     &>'
               GO TO 270
            END IF
            ALINE(NICC)=CONBUF(ICCOL:ICCOL)
         END DO
      END IF
!
!     FIND ACTIVE LENGTH OF ALINE BY SEARCH FROM RH END TOWARD COL 1
!
      IF(NICC.EQ.0)THEN
         ICLEN=73
      ELSE
         ICLEN=NICC
      END IF
!
      GO TO 150
  150 IJKLMN=1
!
!     GO BACK AND REPEAT CHECKS
!
      GO TO 120
!
!     LAST CARD ENCOUNTERED IN ATTEMPOTING TO READ CONBUF
!     SHOULD GO AHEAD AND FINISH PROCESSING PRESENT ALINE W/O LOOK
!     AT CC POSSIBILITIES
!
  160 IJKLMN=1
!
!     I CAN'T SEEM TO DO ENOUGH BACK SPACES TO ALLOW A LEGAL READ WHEN
!     WE RECYCLE FROM DRIVER TO BEGINNING OF THIS FILE ONCE THE EOF
!     WAS MARKED IN CONBUF READ.
!
!     TWO BACK SPACES WORK FINE UNDER LAHEY LP77 AND ALLOW THE TRUE
!     FINAL RECORD TO BE READ AS BLINE ON NEXT PASS
!
!     BUT MICROSOFT 4.1 CRASHES WITH RUN TIME ERROR ON SECOND BACK SPACE
!     HOWEVER, THERE IS NO USE FOR JUST ONE BACK SPACE SINCE THAT DOESN'
!     MOVE TO BEGINNING OF LAST RECORD. THIS IS A BUG IN THE COMPILER AS
!     FAR AS I CAN TELL.
!
!     BACKSPACE LUNIN
!     BACKSPACE LUNIN
!
!     SO I GUESS I WILL HAVE TO JURY-RIG SOMETHING THAT WILL WORK WITH
!     EITHER COMPILER...EVEN IF NOT ELEGANT....
!
!     CRUNCH THE LINE TOWARD LEFT
!
      IBASE=0
!##?
      IKOU=6
      DO I=7,72
         KHAR=BLINE(I)
         CALL UC1(KHAR)
         IF(KHAR.EQ.SPC.OR.KHAR.EQ.SPACE)GO TO  170
         IKOU=IKOU+1
         BLINE(IKOU)=KHAR
         IBASE=IBASE+1
         IF(IBASE.LE.3)WORD(IBASE)=KHAR
! NEXT LINE MANUALLY MOVED INSIDE THE DO-LOOP 6-20-97
  170 MYCDEF=0
      END DO
      ICLEN=IKOU
      IF(IBASE.GE.3)GO TO  180
!
!     BLINE MUST NOT CONTAIN ANYTHING USEFUL, BUT IT COULD BE A COMMENT
!     CARD, I SUPPOSE.
!
      IERR=1
!
!     BUT SEE IF AN 'END' RESIDES IN CONBUF
!
      GO TO 190
!
!     TEST FOR 'END' IN BLINE
!
  180 IJKLMN=1
      IF(IBASE.GT.3)THEN
!
!     CAN'T BE A PROPER "END" CARD
!
         IERR=IERR+4
         GO TO 190
      END IF
      IF(WORD(1).EQ.'E'.AND.WORD(2).EQ.'N'.AND.WORD(3).EQ.'D')THEN
!
!     END IS IN BLINE
!
!     WE HAVE FOUND THE END CARD AND ANYTHING IN CONBUF CAN'T BE RELEVAN
!
         IERR=IERR+2
         GO TO 220
!
      ELSE
!
!     BLINE DOES NOT CONTAIN AN 'END' STATEMENT, BUT CONTAINS SOMETHING
!
         IERR=IERR+4
      END IF
!
!    IS  END IN CONBUF ?
!     CRUNCH CONBUF TOWARD LEFT
!
  190 IBASE=0
!##?
      IKOU=6
      DO I=7,72
         KHAR=CONBUF(I:I)
         CALL UC1(KHAR)
         IF(KHAR.EQ.SPC.OR.KHAR.EQ.SPACE)GO TO  200
         IKOU=IKOU+1
         CONBUF(IKOU:IKOU)=KHAR
         IBASE=IBASE+1
         IF(IBASE.LE.3)WORD(IBASE)=KHAR
!     IF(IBASE.EQ.3) GOTO 124
! NEXT LINE MANUALLY MOVED INSIDE THE DO-LOOP 6-20-97
  200 MYCDEF=0
      END DO
      ICLEN=IKOU
      IF(IBASE.GE.3)GO TO  210
!
!     CONBUF MUST BE EMPTY
!
      IERR=IERR+8
!
!     TEST FOR 'END'
!
  210 IJKLMN=1
      IF(IBASE.GT.3)THEN
         IERR=IERR+32
         GO TO 220
      END IF
      IF(WORD(1).EQ.'E'.AND.WORD(2).EQ.'N'.AND.WORD(3).EQ.'D')THEN
!     END IS IN CONBUF
         IERR=IERR+16
      ELSE
!
!     THERE IS SOMETHING THERE BUT IT ISN'T THE END CARD
!
         IERR=IERR+32
      END IF
  220 IJKLMN=1
!
!     PLANS:
!
!     IERR              ACTIONS IN PRE AND REL
!
!     9,12,33,36        COPY BLINE TO ALINE - RECOMPUTE ICLEN
!        (-1)           PROCESS ALINE AS A NORMAL PASS IN PRE OR REL
!                       THEN COPY CONBUF TO ALINE AND MAKE A FINAL PASS
!                       APPEND END CARD WITH 'NO END CARD ERROR MESSAGE'
!
!     10,18,34          COPY BLINE TO ALINE - RECOMPUTE ICLEN
!        (-2)           PROCESS ALINE AS NORMAL PASS AND EXIT (IGNORE
!                                                             CONBUF)
!     17,20             COPY BLINE TO ALINE, RECOMPUTE ICLEN AND MAKE
!        (-3)             ONE NORMAL PASS
!                       APPEND END W/O WARNING TO SAVE FOOLING WITH CONB
!                       EXIT
!     2                 BLINE CONTAINS THE END STMT. SO, IGNORE BLINE
!        (-4)           AND JUST APPEND THE END CARD, OR PROCESS IT AND
!                       EXIT
!
!     MAYBE IF I FIX THINGS PROPERLY IN PRE, LIFE WILL BE EASIER IN REL
!
      IF(IERR.EQ.9.OR.IERR.EQ.12.OR.IERR.EQ.33.OR.IERR.EQ.36)IERR=-1
      IF(IERR.EQ.10.OR.IERR.EQ.18.OR.IERR.EQ.34)IERR=-2
      IF(IERR.EQ.17.OR.IERR.EQ.20)IERR=-3
      IF(IERR.EQ.2)IERR=-4
      IF(IERR.GE.0)WRITE(*,*)'IERR.GT.0 AT END OF EOF PROCESSING IN <BUF&
     &IN>',IERR
      DO I=1,72
      ALINE(I)=BLINE(I)
      END DO
      IC=73
      DO I=1,72
         IC=IC-1
         KHAR=ALINE(IC)
         IF(KHAR.NE.SPC.AND.KHAR.NE.SPACE)GO TO  250
      END DO
!
      WRITE(*,*)'EMPTY LINE ERROR AT EOF EXIT IN BUFIN.'
      GO TO 260
  250 ICLEN=IC
  260 IJKLMN=1
      ICLOLD=1450
      RETURN
  270 IJKLMN=1
!
!      ADJUST LINE LENGTH TO SKIP TRAILING SPC CODES ON RH END OF ALINE
!
      JMAX=ICLEN+1
      DO J=1,JMAX
         IF(ALINE(ICLEN).NE.SPC)GO TO  290
         ICLEN=ICLEN-1
         IF(ICLEN.LT.1)THEN
!
!     WE SEEM TO HAVE A COMPLETELY BLANK LINE!
!     MAKE A COMMENT CARD OUT OF IT
!
            ICLEN=1
            ALINE(1)=EXCLAM
            GO TO 290
         END IF
!
      END DO
  290 IJKLMN=1
!
      ICLOLD=ICLEN+5
      RETURN
      END SUBROUTINE BUFIN
! *********************************************************************
      SUBROUTINE REL21
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
!
!     MODIFIED 1-APR-1989
!
!     7 SEPT 1985 - VAX 11-750 VERSION / A. MILLER
!     19 APR 1986 / A. MILLER / IBM-MICROSOFT FORTRAN VERSION
!     FROM 1984 CP/M MICROSOFT F80 COMPILER VERSION
!
      LOGICAL :: ISVAR
      CHARACTER(LEN=1) :: VARNAM(16)
      LOGICAL :: YES3,YES4,YES5,YES7,YES8,CONYES,JMPFLG,YES9
      CHARACTER(LEN=1) :: ZERO='0'
      CHARACTER(LEN=1) :: NINE='9'
      CHARACTER(LEN=1) :: SPC=' '
      CHARACTER(LEN=1) :: COMMA=','
      CHARACTER(LEN=1) :: LPAREN='('
      CHARACTER(LEN=1) :: RPAREN=')'
      CHARACTER(LEN=1) :: SPACE=CHAR(255)
      CHARACTER(LEN=9) :: NDCARD='      END'
      CHARACTER(LEN=1) :: PLUS='+'
      CHARACTER(LEN=1) :: MINUS='-'
      CHARACTER(LEN=1) :: STAR='*'
      CHARACTER(LEN=1) :: SLASH='/'
      CHARACTER(LEN=1) :: APOST=CHAR(39)
      CHARACTER(LEN=1) :: EXCLAM='!'
      CHARACTER(LEN=1) :: AMPERS='&'
      CHARACTER(LEN=1) :: EYE='I'
      CHARACTER(LEN=1) :: EFF='F'
      CHARACTER(LEN=8) :: MYCONT='MYCDEF=0'
      CHARACTER(LEN=4) :: KALL='CALL'
      CHARACTER(LEN=5) :: TEMP='T$$$'
      CHARACTER(LEN=5) :: ERRB=',ERR='
      CHARACTER(LEN=5) :: ENDB=',END='
      CHARACTER(LEN=5) :: READB='READ('
      CHARACTER(LEN=5) :: WRITB='WRITE'
      CHARACTER(LEN=2) :: DLP='DO'
      CHARACTER(LEN=4) :: GWORD='GOTO'
!
!     LABEL ARRAYS ARE TO HAVE THE FORM LABEL(1-5) CONTAIN ASCII LABEL
!     CODES. LABEL(6) CONTAINS 'IBEG'=COLUMN NO FOR 1-ST CHAR OF THE
!     LABEL, AND LABEL(7) CONTAINS 'IFIN'=COL.NO. FOR LAST CHAR.
!
!
      CHARACTER(LEN=5) :: TMP
      CHARACTER(LEN=26) :: USENAM
      CHARACTER(LEN=16) :: WRKNAM
      CHARACTER(LEN=79) :: MISC
      CHARACTER(LEN=1) :: KHAR
      CHARACTER(LEN=8) :: MYSTR
      CHARACTER(LEN=1) :: ABUF(80)
      CHARACTER(LEN=74) :: NAMSAV
      CHARACTER(LEN=73) :: TYPDEC
      CHARACTER(LEN=5) :: DOWORD,DOLIST(25)
      CHARACTER(LEN=4) :: TWORD,WORD
      CHARACTER(LEN=1) :: ALINE(1450)
      CHARACTER(LEN=1) :: NDF90(72)
      CHARACTER(LEN=5) :: LWORD
      CHARACTER(LEN=16) :: PUNAME
      LOGICAL :: ANS1, ANS2
      INTEGER LUNIN
      INTEGER(2) :: I, J, K,  NDLEVL, IFMT, ICONT8, IEXIT,NDO
      INTEGER(2) :: NOIND, IBGFLG, IERR, ABCDEF, ISTRT, NAMLEN, NRTYPE, JJ
      INTEGER(2) :: NDIF, IKEY, IKALL, ICFLG, LFLAG, KDO, IBELNG, ISPARE
      INTEGER(2) :: NDK, LC, NPARN, IDD1, IAPOST, NP, LL, MATCH, IAPCNT
      INTEGER(2) :: JBEG, K1, KK, IK, IC, NKEEP, NDTEMP, IBEL, III, IIK
      INTEGER(2) :: NFIRST, NLAST, NLST, NIC, LEFT, ILEN, IDUM
      INTEGER(2) :: ITMP,ID1,ID2
!
   10 FORMAT(1X,82A1)
   20 FORMAT(6X,I1,72A1)
   30 FORMAT(80A1)
   40 FORMAT(6X,72A1/)
   50 FORMAT(5X,I1,72A1)
   60 FORMAT(' EXPECTED CONTINUATION LINE DID NOT FOLLOW LINE '//1X,72A1&
     &//)
   70 FORMAT(' SERIOUS ERROR IN INPUT TEXT. LINE LENGTH TOO SMALL')
   80 FORMAT(' ERROR IN FINDING FINAL ) FOR LINE'/1X,80A1)
   90 FORMAT(/' APPARENT UN-BALANCED PARENTHESES DETECTED IN LINE: '/1X,&
     &72A1)
  100 FORMAT(A9)
!
! SEVERAL OF THE FOLLOWING ASSIGNMENTS CAUSE GREAT PROBLEMS WHEN I APPLY
! EZUP TO THIS ROUTINE ITSELF!!
! APPARENTLY EZUP IS INTERPRETING A GOTO ENCLOSED BY APOSTROPHES (IE
! 'GOTO' AS AN ACTUAL PROGRAM STATEMENT AND THEN LOOKS FOR A NON-EXISTEN
! LABEL
!      GWORD='GOTO'
!      TEMP='T$$$'
!      ERRB=',ERR='
!      ENDB=',END='
!      READB='READ('
!      WRITB='WRITE'
!      MYCONT='MYCDEF=0'
!      DLP='DO'
!      NDCARD='      END'
!        COMMA=','
!
!     SET VALUE FOR NO. OF SPACES FOR INDENTATIONS FOR EACH LEVEL
!
      IF(NDSPC.LT.0.OR.NDSPC.GT.5)NDSPC=2
!
!     INITIALIZE COUNTER
!
      NDLEVL=0
!
!     DEFINE OTHER PARAMETERS
!
!      ZERO='0'
!      NINE='9'
!      SPC=' '
!      SPACE=CHAR(255)
!
! LAHEY LF90 VERSION 3.0 SEEMS TO LOSE TRACK OF MEANING OF VARIABLE CR
! AND PERHAPS LF AS WELL! SO VARS CR AND LF WERE REPLACED (JULY 5, 1997) BY
! DIRECT CHAR(13) OR CHAR(10) IN COMPARISON STATEMENTS ELESWHERE IN THIS
! ROUTINE
!
!      CR=CHAR(13)
!      LF=CHAR(10)
!     CEE='C'
!      APOST=CHAR(39)
!      LPAREN='('
!      RPAREN=')'
!      PLUS='+'
!      MINUS='-'
!      STAR='*'
!      SLASH='/'
!      EYE='I'
!      EFF='F'
!      EXCLAM='!'
!      AMPERS='&'
!      EQUALS='='
!
      LUNIN=4
      REWIND  LUNIN
      IFMT=0
      ICONT8=0
      NLINE=0
      IEXIT=0
      ICLOLD=1450
      NDO=0
      NDLEVL=0
      NOIND=0
      IBGFLG=1
      MYSTR(1:1)=' '
      NUMVAR=0
      IBELNG=0
      DO I=1,400
         LREF(I)=.FALSE.
         DO J=1,16
            VARLST(I,J)=SPC
         END DO
      END DO
      CONYES=.FALSE.
!
!     RECYLE FOR NEW LINE HERE
!
  120 IJKLMN=1
      call clrll(aline)
      call clrll(cline)
      CALL BUFIN(ALINE,IERR,LUNIN)
! 17 OCT 2009: debuggin iclen = 1 but tword=CONT
	  IF ((ICLEN.EQ.1).AND.(ALINE(1).EQ."!")) THEN
		WRITE(IOOUT,'(A1)')ALINE(1)
! very bad move !!!
        goto 120
	  END IF
!
!
!     COPY ALINE INTO CLINE / RELOCATED TO HERE: 6-02-97
!        I PRESUME THAT BUFIN CALCULATES ICLEN
      DO J=1,ICLEN
      CLINE(J)=ALINE(J)
      END DO
      IF(IBGFLG.EQ.1.AND.ALINE(1).EQ.SPC)THEN
         IBGFLG=2
!
! ------------
         call clr73(typdec)
         CALL FNCHK(TYPDEC,ANS1,ANS2)
! ------------
! TRY TO SAVE STUFF* WHIC WE NEED TO ADD TO THE END STMT
         NAMSAV=' '
         DO I=7,ICLEN
            J=I
!     TERMINATE SEARCH FOR NAME WHEN FIND A LEFT-PAREN:
            IF(CLINE(I).EQ.'(')GO TO  160
         NAMSAV(I-6:I-6)=CLINE(I)
         END DO
  160    ABCDEF=8
         ISTRT=J
!         IF (NAMSAV(1:7) .EQ. 'PROGRAM') THEN
			CALL CLRABF(ABUF)
         DO I=1,74
            J=73-I
            IF(NAMSAV(I:I).EQ.SPACE)NAMSAV(I:I)=' '
            ABUF(I)=NAMSAV(I:I)
            IF(NAMSAV(J:J).NE.SPC)GO TO  180
         ABCDEF=10
         END DO
  180    NAMLEN=J
! MODIFIED 17 DEC 1999 TO IDENTIFY THE ACTUAL PROGRAM UNIT (PU) NAME
! AS NEW VARIABLE PUNAME (PROGRAM UNIT NAME)
             DO I=1,16
                  J=NAMLEN-I+1
                  IF(NAMSAV(J:J).EQ.SPC) GOTO 184
             END DO
  184    K=NAMLEN-J+1
         PUNAME=''
         DO I=1,K
             PUNAME(I:I)=NAMSAV(J+I:J+I)
             END DO
! BUILD THE NDF90 STRING
         DO I=1,6
            NDF90(I)=' '
         END DO
         NDF90(7)='E'
         NDF90(8)='N'
         NDF90(9)='D'
         NDF90(10)=' '
         J=10
         DO I=1,NAMLEN
            J=J+1
         NDF90(I+10)=ABUF(I)
         END DO
         NAMLEN=J
! WRITE NAMLEN CHARACTERS ALA WRITE(4,40)(NDF90(I),I=1,NAMLEN)
!
! THIS MAY BE THE EASIEST PLACE AT WHICH I CAN GENERATE A LIST
! OF SUBROUTINE OR FUNCTION PARAMETERS
         IF(ISTRT.GE.ICLEN)THEN
            NPRMS=0
            NRTYPE=0
         ELSE
            IF(ANS1)THEN
! FIND THE LEFT PARENTHESIS
               DO JJ=15,40
                  IF(CLINE(JJ).NE.'(')GO TO  210
                  ISTRT=JJ
                  GO TO 220
  210             IJKLMN=1
               END DO
!  210          IJKLMN=1
  220          IJKLMN=1
            END IF
            CALL SBVARS (ISTRT,NRTYPE)
!     IF (NPRMS.NE.0) THEN PRMLST SHOULD CONTAIN PARAM NAMES
!            NEXT LINE IS ONLY FOR EARLY TESTING
            IF(NPRMS.EQ.0)WRKNAM=PRMLST(NPRMS)
!
         END IF
      END IF
!
!       SPECIAL HANDLING NEEDED AT END OF FILE CONDITION
!
      IF(IERR.NE.0)GO TO  1110
!
  230 IJKLMN=1
!
      NDIF=0
      IKEY=0
      LTYPE=0
      NOIND=0
      IKALL=0
!
!     20 IN NEXT LINE IS MAX VAL OF FIRST INDEX OF LABL( , ).
!     CLEAR ARRAY LABL( , ) TO ALL SPC-CODES
!
      DO J=1,20
         DO K=1,7
             LABL(J,K)=SPC
         END DO
      END DO
!
!     DON'T PROCESS VERY SHORT LINES AND COMMENT LINES
!
      IF(ICLEN.LE.6)GO TO  870
      KHAR=CLINE(1)
      CALL UC1(KHAR)
! NEXT WAS EQ.CEE
      IF(KHAR.EQ.EXCLAM)GO TO  870
!
!     TEST FOR OTHER LINES FOR WHICH PROCESSING IS TO BE SKIPPED
!     AND PASS THEM THRU TO OUTPUT W/O COMPRESSION BY GOING BACK
!     TO ORIGINAL ALINE VERSION
!     ==> NOTE THAT SOME KEY WORDS ARE SPECIAL IN THIS TEST <===
!     ICLFG IS A FLAG TO ALLOW LOOK FOR LABEL DEFN IN COLS1-5
!     WITHOUT COMPRESSING TEXT IN REST OF THE LINE
!
      IF(IFMT.EQ.1.AND.ALINE(6).NE.SPC)GO TO  280
      IF(IFMT.EQ.1.AND.ALINE(6).EQ.SPC)IFMT=0
      ICFLG=0
      DO K=1,4
      TWORD(K:K)=CLINE(K+6)
      END DO
      IF(IFMT.EQ.0.AND.TWORD.EQ.KEYWDS(23))IFMT=1
!
!
      DO I=1,31
!
!     WHY DID I DO THIS ??? SEEMS TO SKIP COMPRESSION OF LINES BEGINNING
!     WITH LOGICAL, REWIND, CALL, FORMAT,SUBROUTINE,STOP .. BUT DOESN'T
!     SKIP SOME OTHERS WHIH MIGHT ALSO LOSE READABLITY VIA SPACE-CHAR
!     DELETION....A MYSTERY.....NO, THE REASON WAS TO SKIP OVER A LOT
!     OF FUSS AND COMPRESSION FOR LINES THAT CONTAINED KEYWORDS THAT
!     WOULDN'T HAVE LABELS
!
         IF(I.LE.21.AND.(TWORD.EQ.KEYWDS(I)))THEN
            IKEY=1
            GO TO 280
         END IF
         IF(TWORD.NE.KEYWDS(I))GO TO  270
         ICFLG=1
         GO TO 280
  270    MYCDEF=0
      END DO
!
  280 IJKLMN=1
!     I NOW CALL A SERIES OF SPECIAL ROUTINES WHICH WILL REPLACE
!     STANDARD "TYPE-DECLARATIONS" WITH F90 EQUIVALENTS.
!     FOR EXAMPLE, 'PREAL' CONVERTS "REAL*4" TO "REAL(4) ::"
!     SOME OF THE P-ROUTINES DO DIRECT WRITES TO IOOUT AND
!     SET JMPFLG=.TRUE. TO TELL ME TO SKIP ADDITIONAL PROCESSING
!     FOR THE CURRENT CLINE
!
!8-25-2009: experimentall, adding initialization of jmpflag=false
      JMPFLG=.FALSE.
!      
      IF(TWORD.EQ.KEYWDS(1))CALL PCHAR(JMPFLG)
      IF(TWORD.EQ.KEYWDS(3))CALL PCOMPL
      IF(TWORD.EQ.KEYWDS(4))CALL PDIMEN(JMPFLG)
      IF(TWORD.EQ.KEYWDS(5))CALL PDOUB
      IF(TWORD.EQ.KEYWDS(7))CALL PINTEG
      IF(TWORD.EQ.KEYWDS(8))CALL PREAL
      IF(TWORD.EQ.KEYWDS(15))CALL PLOGIC
      IF(TWORD.EQ.KEYWDS(10))CALL PIMPLI(JMPFLG)
!        NEXT GROUP OF CALLS LOOKS AT "NON-TYPE DECLARATION' STMTS
      IF(TWORD.EQ.KEYWDS(6))CALL PEQUIV
      IF(TWORD.EQ.KEYWDS(18))CALL PPARAM
      IF(TWORD.EQ.KEYWDS(16))CALL PBLOCK
      IF(TWORD.EQ.KEYWDS(9))CALL PDATA
      IF(TWORD.EQ.KEYWDS(23))CALL PFORMA
      IF(TWORD.EQ.KEYWDS(21))CALL PREWIN
      IF(TWORD.EQ.KEYWDS(37))CALL PINCLU
      IF(TWORD.EQ.KEYWDS(38))CALL PENTRY
      IF(JMPFLG)THEN
!     IN CERTAIN CASES, THE PROCESSING ROUTINE (P....) DO DIRECT
!     WRITE'S TO IOOUT, AND I SIMPLY GO BACK AND PICK UP THE NEXT
!     LINE OF THE INPUT FILE
         JMPFLG=.FALSE.
         GO TO 120
      END IF
!
!    CONTINUATION LINE TEST FOR LTYPE=8
      IF(ICONT8.EQ.0)GO TO  290
      J=7
      GO TO 450
!
!     PARAMETER LTYPE MAY BE USED BY SUBROUTINE SCRP IN TRYING
!     TO IMPROVE READABILITY OF SOME LINES.
!
  290 LTYPE=0
!     CALL PRINFO
!
!    LOOK FOR LABEL IN COLS 1-5, SET FLAG, AND JUSTIFY THE LABEL
!
      LFLAG=0
      DO J=1,5
         IF(CLINE(J).NE.SPC)LFLAG=1
      END DO
!
!     SET LFLAG =1 TO SIGNAL THAT THERE IS A LINE-LABEL IN COL 1-5
!     AND COPY IT INTO ARRAY LABL(1,..)
!
      IF(LFLAG.EQ.0)THEN
         IF(IKEY.EQ.0)THEN
            GO TO 360
         ELSE
            GO TO 870
         END IF
      END IF
!
      LTYPE=1
!      CALL PRINFO
!
      LN=1
      IBEG=6
      IFIN=0
      DO J=1,5
         KHAR=CLINE(J)
         IF(KHAR.EQ.SPC)GO TO  310
         IF(J.LT.IBEG)IBEG=J
         IF(J.GT.IFIN)IFIN=J
  310 LABL(LN,J)=KHAR
      END DO
      LABL(LN,6)=CHAR(IBEG)
      LABL(LN,7)=CHAR(IFIN)
!
!     TEST TO SEE IF THIS LABEL IN COLS 1-5 TERMINATES THE MOST RECENT
!     DO-LOOP
!
      IF(NDO.NE.0)THEN
         DO KDO=1,5
            DOWORD(KDO:KDO)=LABL(LN,KDO)
         END DO
! --------------------------------------------------------------
!     DOES THIS LABEL BELONG TO ANYTHING IN DOLIST ?
!
         IBELNG=0
         DO KDO=1,NDO
            IF(DOWORD.EQ.DOLIST(KDO))IBELNG=IBELNG+1
         END DO
         IF(IBELNG.NE.0)THEN
!
            IF(DOWORD.EQ.DOLIST(NDO))THEN
               NDLEVL=NDLEVL-1
               NDO=NDO-1
!
!        TEST FOR MULTIPLE TERMINATIONS ON SAME LABEL
!
               IF(NDO.GT.0)THEN
                  ISPARE=0
                  DO NDK=1,NDO
                     K=NDO-NDK+1
                     IF(DOLIST(K).EQ.DOWORD)ISPARE=ISPARE+1
                  END DO
                  NDO=NDO-ISPARE
                  NDLEVL=NDLEVL-ISPARE
               END IF
            ELSE
               WRITE(*,*)'* FATAL * DO-TERMINATION LABEL OUT OF ORDER: &
     &',     DOWORD
                  STOP 201
               END IF
            END IF
         END IF
!
! ---------------------------------------------------------------------
!
!     CALL SCRP TO DO SERACH-REPLACE OPERATINS
!
         CALL SCRP
!
!     IF IKEY=1, THERE SHOULD BE NO LABELS OTHER THAN COLS 1-5, SO
!     BUG OUT HERE
!
         IF(IKEY.EQ.1)GO TO  870
!
!     SEARCH SOME MORE OF THE LINE FOR KEY-WORDS WHICH LEAD TO LABELS
!
!     INITIALIZE SEARCH PARAMETER AT J=6 SO SRCH BEGINS AT J=7
         J=6
  360    IJKLMN=1
         IF(LTYPE.LT.7)LTYPE=0
         IBEG=83
         IFIN=0
         LC=0
         DO K=1,5
            TMP(K:K)=SPC
         END DO
         WORD=TMP
!
  380    J=J+1
!
!     ERROR CHECKS
!
         IF(ICLEN.GT.1450)THEN
            WRITE(*,*)'TROUBLE FOR NLINE,ICONF(NLINE): ',NLINE,ICONF(NLI&
     &NE)
            WRITE(*,*)'* PROBABLE SERIOUS ERROR FOR LINE(S):'
            WRITE(*,*)ALINE
!     WRITE(*,*)CONBUF
            GO TO 430
         END IF
         IF(J.GT.ICLEN)THEN
            GO TO 430
         END IF
         IF(LTYPE.GE.7)GO TO  740
         KHAR=CLINE(J)
         IF(KHAR.EQ.SPC)GO TO  380
!
!     END OF LINE ?
!
         IF(KHAR.EQ.CHAR(10).OR.KHAR.EQ.CHAR(13))GO TO  430
!
!     COLLECT UP TO 5 CHARACTERS, IGNORING SPACES - LOOKING FOR KEYWDS
!     READ-, WRITE,GOTO, OR GO TO.
!     IF KHAR IS A DECIMAL NUMBER IN ASCII FORM, IT ISN'T PART OF A
!     KEYWORD EITHER..UNLESS IT IS 5-TH CHAR OF GOTO#
!
         IF(LC.EQ.4.AND.(WORD.EQ.GWORD))GO TO  390
         IF(KHAR.GE.ZERO.AND.KHAR.LE.NINE)GO TO  380
         IF(KHAR.EQ.PLUS.OR.KHAR.EQ.MINUS.OR.KHAR.EQ.STAR.OR.KHAR.EQ.SLA&
     &SH)GO TO  380
  390    IJKLMN=1
         LC=LC+1
         TMP(LC:LC)=KHAR
!         WORD(LC:LC)=KHAR
         IF(LC.EQ.5)GO TO  440
!
!    AS SOON AS I HAVE 2-CHARS, CAN TEST FOR 'DO-LOOP' LABEL
!
         IF(LC.NE.2)GO TO  380
         IF(TMP(1:1).NE.DLP(1:1))GO TO  380
         IF(TMP(2:2).NE.DLP(2:2))GO TO  380
!
!     CONTINUE HERE ONLY IF THE FIRST TWO CHARS ARE INDEED 'DO'
!     THE NEXT NON-SPACE CHARACTER MUST BE AN ASCII 0-9 IF I AM
!     LOOKING AT A DO-LOOP LABEL
!
         JJ=J+1
         KHAR=CLINE(JJ)
!      IF(KHAR.LT.ZERO.OR.KHAR.GT.NINE) GOTO 300
         IF(KHAR.LT.ZERO.OR.KHAR.GT.NINE)GO TO  400
!
!     IF I HAVEN'T JUMPED, I NOW HAVE FORM 'DO#', SO I WILL ASSUME
!     THAT I HAVE LOCATED A 'DO-LOOP' LABEL-BEGINNING AT JK=J+1
!
         LFLAG=1
         LTYPE=6
!      CALL PRINFO
         GO TO 740
!
!     RECYCLE SINCE THIS 'DO' ISN'T A STATEMENT SET-UP
!     5/30/97: B U T! THAT ISN'T NECESSARILY TRUE BECAUSE
!     I MIGHT ACTUALLY BE LOOKING AT A DO .... END DO
!     CONSTRUCT HAVING NO NUMERICAL LABEL!
!     HOW CAN I DISTINGUISH
!
!     DO K=I1,I2(M),I3
!  FROM
!     DOBK(K)=A*QQ(K,J)
!  ???
!   TRY 1) THERE IS A COMMA TO THE RIGHT OF THE EQUAL SYMBOL
!   AND 2) THE COMMA IS NOT ENCLOSED BY PARENTHESES
  400    NPARN=0
         DO IDD1=8,ICLEN
            KHAR=CLINE(IDD1)
            IF(KHAR.EQ.'(')NPARN=NPARN+1
            IF(KHAR.EQ.')')NPARN=NPARN-1
            IF(KHAR.EQ.','.AND.NPARN.EQ.0)THEN
               LTYPE=61
               LFLAG=1
               GO TO 740
            END IF
         END DO
!
         LC=0
         J=JJ
         GO TO 380
  430    IJKLMN=1
         GO TO 870
!
!     COMPARE CONTENTS OF TMP TO VALID KEYWORDS
!
  440    IJKLMN=1
         IF(TMP(3:3).NE.LPAREN)GO TO  490
!
         IF(TMP(1:1).NE.EYE)GO TO  490
         IF(TMP(2:2).NE.EFF)GO TO  490
!
         LTYPE=8
!      CALL PRINFO
!
!     LOCATE THE FINAL ')' BEFORE PROCEEDING.
!     THIS PROBABLY WILL NOT WORK AS IT IS IF SOME FOTRAN77 STUFF IS
!     USED, E.G.:  READ(8,'(A)') - WILL STOP ON WRONG PAREN!!
!
         ICONT8=0
         IAPOST=0
!
!    I HAVE LAREADY LOCATED A LEFTPARENTHESIS WHEN I GET HERE
!
         NP=1
  450    IJKLMN=1
         IF(ICONT8.EQ.1)ICONT8=0
         DO LL=J,ICLEN
            KHAR=CLINE(LL)
            IF(KHAR.EQ.APOST.AND.IAPOST.EQ.0)THEN
               IAPOST=IAPOST+1
            ELSE
               IF(KHAR.EQ.APOST.AND.IAPOST.NE.0)IAPOST=IAPOST-1
            END IF
!
!     TRY TO FIND NEXT RPAREN TO PINPOINT END OF IF(,......)
!     HOWEVER, AVOID PAYING ATTENTION TO PARENS THAT ARE ENCOUNTERED
!     WHEN NO. OF APOSTS IS NOT EVEN
!
            IF(IAPOST.EQ.0.AND.KHAR.EQ.LPAREN)NP=NP+1
            IF(IAPOST.EQ.0.AND.KHAR.EQ.RPAREN)THEN
               NP=NP-1
               GO TO 470
            END IF
!
         END DO
         IF(NP.EQ.0)GO TO  470
!
!     IF I GET TO HERE, THE NO.  OF ( AND ) ARE NOT EQUAL
!     PRINT WARNING, ALTHOUGH THINGS MAY BALANCE OUT ON A CONT.CARD
!
         WRITE(*,90)(CLINE(LL),LL=1,ICLEN)
         GO TO 870
  470    IJKLMN=1
         IF(LL.EQ.ICLEN)THEN
!
!     SEE IF THERE REALLY IS A CCARD BY LOOKING AT ICONF(NLINE)
!
            IF(ICONF(NLINE+1).EQ.0)THEN
!
!     THERE ISN'T REALLY A CONTIN CARD AND THIS IF MUST BE A FALSE
!     ALARM.  I NEED TO GET OUT NOW!
!     TRY JUST SENDING THE LINE ON TO THE OUTPUT FILE
!
               GO TO 870
            ELSE
               ICONT8=1
            END IF
         END IF
         IF(ICONT8.EQ.1)GO TO  870
         J=LL
!
!     BE CAREFUL ! WE MIGHT BE LOOKING AT AN IF (... ) GOTO CASE
!     SO CHECK  TO THE RIGHT OF THE ) FOR ANY OTHER CHARS
!
  480    LL=LL+1
         IF(LL.GT.ICLEN)GO TO  740
         IF(CLINE(LL).EQ.SPC)GO TO  480
         IF(CLINE(LL).GE.ZERO.AND.CLINE(LL).LE.NINE)GO TO  740
!
!     MAYBE IT IS ) GOTO FORM
!     OR SIMPLE IF(...) G=5 !!!!!
!
         LTYPE=0
!      CALL PRINFO
         GO TO 580
!
!     IS IT A 'READ' ?
!
  490    MATCH=1
         DO JJ=1,5
            K=JJ
            IF(TMP(K:K).NE.READB(K:K))MATCH=0
            IF(MATCH.EQ.0)GO TO  550
         END DO
!
!     IF 'MATCH' STILL = 1, ALL 5 CHARS AGREED
!
         IF(MATCH.EQ.0)GO TO  550
!
!     SEARCH FOR THE SEPARATOR (COMMA)
!
  510    J=J+1
         IF(J.GT.ICLEN)THEN
            GO TO 430
         END IF
         IF(CLINE(J).EQ.COMMA)GO TO  520
         GO TO 510
  520    IJKLMN=1
!
!     GOLLY! I NEVER CHECKED TO SEE IF THERE WAS NO COMMA AT ALL!!!!!
!
!
!     FORMATTED READ ?
!
         KHAR=CLINE(J+1)
!
!     AD-HOC, CLUMSY FIXUPS FOR SOME FORTRAN77 SITUATIONS:
!
!     IF KHAR IS AN APOSTROPHE, WE HAVE GOT A FORT 77 READ STATEMENT
!     THAT CONTAINS ITS OWN FORMAT INFO, AND THERE IS NO NUMERICAL
!     REFERENCE TO A FORMAT STATEMENT
!     IN THAT CASE, WE HAVE TO INSERT A NEW STRATEGY:
!     1) FIND THE SECOND (OR MULTIPLE OF 2 COUNT) APOSTROPHE
!        AND RESET THE INDEXING VARIABLE J TO POINT PAST THE INTERNAL
!        FORMAT INFO.
!     2) CHECK TO SEE IF WE HAVE REACHED THE END , THAT IS A ")" PAREN.
!        OR WHETHER THERE MAY BE MORE LABELS SUCH AS "END=" STUFF IN
!        REMAINDER OF THE LINE.
!     3) IF THERE IS NOTHING ELSE BY WAY OF LABELS IN THE LINE, WE
!        WANT TO SKIP CALL OF SCRP ENTIRELY.
!        BUT IF THERE APPEAR TO BE MORE LABELS, WE CAN JUST RESET J
!        AND JUMP TO WHERE WE RECYCLE LOOKING FOR ADDITIONAL LABELS
!        IN THE CURENT LINE.
!
         IF(KHAR.EQ.APOST)THEN
!
            IAPCNT=1
            JBEG=J+2
            DO JJ=JBEG,ICLEN
               KHAR=CLINE(JJ)
               IF(KHAR.EQ.APOST)IAPCNT=IAPCNT-1
               IF(IAPCNT.EQ.0)THEN
!            NEXT CHAR MUST BE ) OR COMMA OR ELSE CAN'T HANDLE IT
                  IF(CLINE(JJ+1).EQ.RPAREN)THEN
!
!     I HOPE THAT THERE ISN'T ANY MORE ??
!     I DON'T KNOW WHERE I SHOULD REALLY GO FROM HERE, BUT FOR NOW
!     I WILL ASSUME I EITHER HAVE A READ OR A WRITE, THOUGH IT
!     MIGHT BE SOMETHING ELSE
!
!                  GOTO 740
! NO! DO SOMETHING ELSE, SINCE A LABEL MAY HAVE ALREADY BEEN REPLACED
!
!     20-MAR ?? LEAVE CLINE AS IT IS AND PROCEED ?
                     GO TO 870
                  END IF
                  IF(CLINE(JJ+1).EQ.COMMA)THEN
                     J=JJ+1
!
                     GO TO 540
                  END IF
               END IF
            END DO
         END IF
!
         IF(KHAR.LT.ZERO.OR.KHAR.GT.NINE)GO TO  730
!
  540    IJKLMN=1
         LTYPE=4
         GO TO 740
!
!  NEXT STMT MEANS TMP WASN'T 'READ' - OR DIDN'T CONTAIN A NUM. LABEL
!
  550    IJKLMN=1
!
!    WAS IT 'WRITE' ?
!
         MATCH=1
         DO JJ=1,5
            K=JJ
            IF(TMP(K:K).NE.WRITB(K:K))MATCH=0
            IF(MATCH.EQ.0)GO TO  580
         END DO
         IF(MATCH.EQ.0)GO TO  580
!
!     NEXT SIGNIFICANT CHAR MUST BE A '(', OR NO LABEL FOLLOWS
!
  570    J=J+1
         IF(J.GT.ICLEN)THEN
            GO TO 430
         END IF
         KHAR=CLINE(J)
         IF(KHAR.EQ.SPC)GO TO  570
!
!     WHEN LPAREN IS FOUND, JUMP TO TREAT SAME AS IN "READ" STMT
!
         IF(KHAR.EQ.LPAREN)GO TO  510
         GO TO 570
!
!   GOTO ?
!
!     MAY APPEAR IN TWO FORMS ')GOTO' OR 'GOTO#',SO NEED SOME EXTRA
!     CHECKING SCHEME
!
  580    IJKLMN=1
         MATCH=1
!
!     IF 1-ST CHAR IS NEITHER ')' NOR 'G', DON'T HAVE GO TO IN TMP
!
         IF(TMP(1:1).EQ.RPAREN)GO TO  600
         IF(TMP(1:1).EQ.GWORD(1:1))GO TO  620
         IF(TMP(1:1).EQ.'R')GO TO  590
         MATCH=0
         GO TO 640
!
!   LOOK FOR REWIND; LL POINTS TO FIRST CHAR AFTER RT. PAREN (2 NOV 95)
!
  590    IF((TMP(2:2).EQ.'E').AND.(TMP(3:3).EQ.'W').AND.(TMP(4:4).EQ.'I'&
     &).AND.(TMP(5:5).EQ.'N').AND.(CLINE(LL+5).EQ.'D'))THEN
                        ID1=LL+6
                        ID2=1
            CALL MVRT(ID1,ID2)
            CLINE(LL+6)=' '
            GO TO 640
         END IF
  600    DO JJ=1,4
            K=JJ+1
            IF(TMP(K:K).NE.GWORD(JJ:JJ))MATCH=0
         END DO
!
! BUT THERE ARE A FEW OTHER POSSIBILITIES TOO! REWIND22
!
         IF(MATCH.EQ.0)GO TO  640
!
!     SO, IT IS A GOTO
!
         LTYPE=3
!      CALL PRINFO
!
!     SEE IF IT IS A ' )GOTO ( ' SITUATION
!
         IF(CLINE(J+1).EQ.LPAREN)THEN
            LTYPE=7
!          CALL PRINFO
         END IF
         IF(LTYPE.EQ.7)J=J+1
         GO TO 740
  620    MATCH=1
         DO JJ=1,4
            IF(TMP(JJ:JJ).NE.GWORD(JJ:JJ))MATCH=0
         END DO
         IF(MATCH.EQ.0)GO TO  640
         LTYPE=2
!      CALL PRINFO
!
!     NOW HAVE A GOTO# SITUATION. 1-ST CHAR OF LABEL
!     IS ALREADY IN TMP, SO MUST DO SOMETHING SPECIAL ??
!
         J=J-1
         IF(TMP(5:5).EQ.LPAREN)THEN
            LTYPE=7
!          CALL PRINFO
         END IF
         GO TO 740
!
!     END= ?
!
  640    IJKLMN=1
         MATCH=1
         DO K=1,5
            IF(TMP(K:K).NE.ENDB(K:K))MATCH=0
!
!     IF NO MATCH, GO TO NEXT TEST
!
            IF(MATCH.EQ.0)GO TO  660
         END DO
         IF(MATCH.EQ.1)GO TO  720
!
  660    IJKLMN=1
!
!     OR  ,ERR=
!
         MATCH=1
         DO K=1,5
            IF(TMP(K:K).NE.ERRB(K:K))MATCH=0
            IF(MATCH.EQ.0)GO TO  680
         END DO
         IF(MATCH.EQ.1)GO TO  720
!
!     CALL SUBROUTINE CAN HAVE INTERNAL LABELS (*1220) FOR EXAMPLE
!     BUT NO LABELS SHOULD APPEAR IN LINES FOR WHICH "IKEY" HAS BEEN
!     SET TO 1, IE KEYWDS(1-15) AS PRESENTLY CODED
!
  680    IJKLMN=1
         MATCH=1
         DO K=1,4
            IF(TMP(K:K).NE.KALL(K:K))MATCH=0
            IF(MATCH.EQ.0)GO TO  730
         END DO
         IF(MATCH.NE.1)GO TO  730
!
!     IKALL POINTS TO FIRST CHARACTER FOLLOWING LAST "L" OF "CALL"
!     WILL BE USED LATER (WHEN I GET AROUND TO IT) FOR ADDING EXTRA
!     SPACE CODE IF NEEDED
!
         IKALL=J
!
!     NOW LOOK FOR ASTERISK, STARTING SEARCH AT J+1
         K1=J+1
         DO K=K1,ICLEN
            KHAR=CLINE(K)
            IF(KHAR.NE.STAR)GO TO  710
!
!     K NOW POINTS TO THE ASTERISK. LABEL SHOULD BEGIN IN NEXT COLUMN
!     AND SHOULD BEGIN WITH NUMERAL (???)
!
            J=K
!
!     TRY TO USE OLFD LTYPE=5
!
            LTYPE=5
!      CALL PRINFO
            GO TO 720
  710       IJKLMN=1
         END DO
         GO TO 730
!
  720    LTYPE=5
!      CALL PRINFO
         GO TO 740
!
!     RECYCLE
!
  730    IJKLMN=1
!
         LC=0
         J=J-4
         GO TO 380
!
  740    IJKLMN=1
         LFLAG=1
!
!      DIG OUT THE NUMERICAL VALUE OF THE LABEL AND SAVE IT
!      START SEARCH AT J. GOBBLE SPACES. QUIT ON NON-NUMBER
!
         DO K=1,5
         TEMP(K:K)=SPC
         END DO
         K1=J+1
         LC=0
         IBEG=89
         IFIN=0
!
         DO K=K1,ICLEN
            KHAR=CLINE(K)
            IF(LC.EQ.0.AND.LTYPE.EQ.7.AND.KHAR.EQ.RPAREN)GO TO  870
            IF(KHAR.EQ.SPC)GO TO  760
            IF(LC.GE.1.AND.(KHAR.LT.ZERO.OR.KHAR.GT.NINE))GO TO  770
            IF(LC.EQ.0.AND.(KHAR.LT.ZERO.OR.KHAR.GT.NINE))GO TO  760
            LC=LC+1
            TEMP(LC:LC)=KHAR
            IF(K.LT.IBEG)IBEG=K
            IF(K.GT.IFIN)IFIN=K
            IF(LC.EQ.5)GO TO  770
  760    IJKLMN=1
         END DO
  770    IJKLMN=1
!
!     FOR GOTO TYPE LTYPE=7 OR 8, WANT TO SKIP NEXT CHARACTER IF IT
!     IS A COMMA WHEN WE SEARCH AGAIN, AND TERMINATE SEARCH FOR
!     LABELS WHEN WE FIND A RT-PAREN ) INSTEAD OF A COMMA(LTYPE=7 CASE)
!
         IF(LTYPE.EQ.8.AND.CLINE(IFIN+1).EQ.COMMA)J=IFIN
         IF(LTYPE.EQ.7.AND.CLINE(IFIN+1).EQ.COMMA)J=IFIN
         IF(LTYPE.EQ.7.AND.CLINE(IFIN+1).EQ.RPAREN)J=IFIN
!
         LN=LN+1
         IF(LN.LE.20)GO TO  800
!
!     HAVE EXECEED DIMENSION OF ARRAY 'LABL(20,7)'
!     WILL PROBABLY HAVE OTHER TROUBLE WITH SO MANY LABELS IN A LINE!
!
  790    FORMAT(//' LN = ',I6,' EXCEEDS 20 IN RELSUB '/' FIRST = ',I5,',&
     & LAST = ',I5,', LC = ',I5,' K1 =',I5/' J = ',I5,', LFLAG = ',I5,',&
     &ICFLG = ',I5,', ICLEN = ',I5)
         WRITE(*,790)LN,IBEG,IFIN,LC,K1,J,LFLAG,ICFLG,ICLEN
         WRITE(*,10)(ALINE(KK),KK=1,72)
         WRITE(*,10)(CLINE(KK),KK=1,ICLEN)
         WRITE(*,*)'LABLE MAY CARRY TO A CONTINUATION CARD. UNABLE TO HA&
     &NDLE THOSE CASES.'
!
  800    LABL(LN,6)=CHAR(IBEG)
         LABL(LN,7)=CHAR(IFIN)
         LC=6
         DO K=1,5
            JJ=6-K
            KHAR=TEMP(JJ:JJ)
            IF(KHAR.EQ.SPC)GO TO  810
            LC=LC-1
            LABL(LN,LC)=KHAR
  810    IJKLMN=1
         END DO
!
!     SEE IF THIS LABEL BELONGS TO BEWGINNING OF A DO-LOOP, AND ENTER
!     IN DOLIST() IF IT DOES
!
         IF(LTYPE.EQ.6.OR.LTYPE.EQ.61)THEN
            DO KDO=1,5
            DOWORD(KDO:KDO)=LABL(LN,KDO)
            END DO
            NDO=NDO+1
            IF(NDO.GT.25)THEN
               WRITE(*,*)'* FATAL * TOO MANY SUBORDINATE DO-LOOPS. JOB T&
     &ERMINATED *'
               STOP 202
            END IF
!
            DOLIST(NDO)=DOWORD
            NDLEVL=NDLEVL+1
            NOIND=NOIND+1
         END IF
!
         IF(LTYPE.EQ.61)THEN
                        ID1=9
                        ID2=1
            CALL MVRT(ID1,ID2)
            CLINE(9)=' '
         ELSE
            CALL SCRP
         END IF
         J=IFIN-1
         IF(LTYPE.EQ.7.AND.CLINE(IFIN+1).EQ.RPAREN)GO TO  870
         IF(LTYPE.EQ.8.AND.IFIN.GE.ICLEN)GO TO  870
!
!     END OF ONE SEARCH LOOP
!
         IF(LFLAG.EQ.0)GO TO  840
  840    LC=0
         J=J+1
!
!     GO BACK AND CONTINUE SEARCH FOR OTHER LABELS IN CURRENT LINE
!
         IF(LTYPE.EQ.61)GO TO  870
         GO TO 360
!
  870    IJKLMN=1
!
!     INSERT ANY SPECIAL SPACES CODES, SUCH AS IN "CALLERRMSG" TO GET
!     "CALL ERRMSG"
!
         IF(IKALL.NE.0.AND.IKALL.LT.ICLEN)THEN
            IF(CLINE(IKALL).NE.SPC.AND.CLINE(IKALL).NE.SPACE)THEN
!
!        MOVE EVERYTHING AFTER "CALL" TO RIGHT BY ONE COLUMN
!
               IK=ICLEN
  880          CLINE(IK+1)=CLINE(IK)
               IK=IK-1
               IF(IK.GE.IKALL)GO TO  880
!        INSERT SPACE CODE
               CLINE(IKALL)=SPACE
               ICLEN=ICLEN+1
            END IF
         END IF
!
!     DO A FINAL CRUNCH TO DELETE UNNEEDED SPACE CODES ON RIGHT HAND
!     END OF THE FINAL CLINE ARRAY. STOP WHEN WE REACH ANYTHING ELSE
!     I THINK THAT MULTI-LINE DATA, FORMATS WILL BE SAFE, BUT WE SHALL
!     SEE:
!
         IK=ICLEN+1
         IC=ICLEN
         DO K=1,IK
            IC=IK-K
            IF(CLINE(IC).NE.SPACE)GO TO  900
         END DO
  900    IJKLMN=1
         ICLEN=IC
!
!     RECONVERT SPECIAL SPACE CODES IF THERE ARE ANY
!
         DO K=1,ICLEN
            IF(CLINE(K).EQ.SPACE)CLINE(K)=SPC
         END DO
!
! =====================================================================
!
!     INDENTATION PROCESSING FOR SOME LINES BEGINS HERE
!
!     DON'T PROCESS COMMENT LINES FOR INDENTATION
!
         KHAR=CLINE(1)
         CALL UC1(KHAR)
         IF(KHAR.EQ.EXCLAM)GO TO  930
!
!     NDLEVL IS LEVEL OF INDENTATION. MAY NEED RESTRICTIONS / ABORTS
!     NDSPC IS NUMBER OF SPACES TO INDENT PER LEVEL
!     NELSE = 1 IS FLAG TO TEMPORARILY REDUCE NDLEVL FOR THE CURRENT
!     LINE ONLY. NELSE = 0 DOESNT.
!
!     USE A SPECIAL FLAG NOIND = 1 -> THIS IS A DO OR SOME OTHER CASE
!     FOR WHICH WE WANT TO REDUCE INDENTATION TEMPORARILY BY ONE LEVEL
!
         CALL ISUBS(YES3,YES4,YES5,YES7,YES8,YES9)
!
!     IS THERE ALSO A THEN IN THIS LINE ?
!
         IF(YES3)THEN
            IF(YES4)THEN
               NDLEVL=NDLEVL+1
!     BUT:
               NOIND=NOIND+1
            END IF
         END IF
!
!CC
         IF(YES5)NDLEVL=NDLEVL-1
         IF(YES7)NOIND=NOIND+1
         IF(YES8)NOIND=NOIND+1
! "END DO" HANDLING 5-20-97
         IF(YES9)THEN
            NDLEVL=NDLEVL-1
            NDO=NDO-1
         END IF
!
!     NDTMP IS ABSOLUTE NUMBER OF SPC CODES TO BE INSERTED FOR INDENTATI
!     BUT RESTRICT SOMEWHAT
         IF(NOIND.EQ.0)THEN
            NKEEP=0
         ELSE
            NKEEP=1
         END IF
         NDTEMP=(NDLEVL-NKEEP)*NDSPC
!
!     NEVER CALL INDENT FOR COMMENT LINE
!
         IF(CLINE(1).NE.'C'.AND.ICLEN.GE.7.AND.NDTEMP.GT.0) THEN
                        CALL INDENT(NDTEMP)
               END IF
!
! ================= END OF MOST INDENTATION LOGIC ==================
!
  930    IJKLMN=1
         IBEL=IBELNG
         IF(IBEL.GT.0)THEN
            CONYES=.FALSE.
!
! HERE IS WHAT I AM TRYING TO DO: IF THIS STATEMENT TERMINATING A
! DO-LOOP IS 'CONTINUE', THEN MOVE THE CONTINUE *OUTSIDE* THE DOLOOP
! UNDER THE THEORY THAT IS MIGHT ALSO BE THE TARGET OF A 'GO TO'
! INTENDED TO MOVE EXECUTION OUTSIDE THE LOOP.
!
! IF CONYES IS .TRUE. THEN WE WANT TO KEEP THE CURRENT STATEMENT
! *INSIDE* THE DO-LOOPS BECAUSE THE STMT IN CLINE IS TRULY PART
! OF THE DO-LOOPS. BUT IF THERE IS NO '=', THEN THE STMT ..OOPS
!
!
! WE ARE TERMINATING A DO LOOP . SEE IF IT IS A "CONTINUE". IF SO,
! REPLACE CONTINUE BY A LEGAL DUMMY STATEMENT AFTER INSERTING END DO
! IN ITS PLACE.... CAN CAUSE TROUBLE IF GOTO THE CONTINUE WAS INTENDED
! AS A WAY OUT OF A DO LOOP!
!
!7-10-97    DO III=7,14
! CONTINUE MIGHT NOT BEGIN IN COLUMN 7!!!!
            IDUM=0
                  DO III=7,ICLEN
                       IF(CLINE(III).NE.SPC) THEN
                            IDUM=IDUM+1
                              IF (IDUM.GT.8) GO TO 932
                    MYSTR(IDUM:IDUM)=CLINE(III)
                        END IF
            END DO
!
  932       IF(MYSTR.EQ.'CONTINUE')THEN
!
! KEEP THE LINE OF CODE, BUT MAKE IT A COMMENT IN CASE THE PROGRAMMER
! NEEDS TO FIND IT AND DEAL WITH IT AS A GO TO TARGET.
! OR PUT IN A DUMMY STATEMENT TO REPLACE THE BANISHED CONTINUE
!
               DO IIK=7,14
                  JJ=IIK-6
               CLINE(IIK)=MYCONT(JJ:JJ)
               END DO
               ICLEN=14
!
!7-09-97 CHANGING THE NEXT STMT FROM CONYES=.TRUE. TO CONYES=.FALSE.
!        SEEMS TO MOVE THE "CONTINUE" INSIDE THE DO LOOP RATHER THAN
!        OUTSIDE IT.. BUT THERE MAY BE OTHER RAMIFICATIONS
!        FOR EXAMPLE, ALSO SEEMS TO HAVE CHANGED MYCDEF=0 INTO IJKLMN=1
!      CAN FAIL WITH NESTED DOLOOPS HOWEVER: PLACES THE EQUIVALENT
!        IJKLMN=1 INSIDE THE INNERMOST LOOP EVE IF IT OUGHT TO GO
!        OUTSIDE THAT LOOP BUT INSIDE ANOTHER ONE.
               CONYES=.FALSE.
            ELSE
!
!     WE KNOW THAT IBELNG.NE.0 SO WE ARE TERMINATING THE DO LOOP
!     WITH SOMETHING OTHER THAN A CONTINUE
               CONYES=.FALSE.
!
! END OF THE IF (MYSTR.EQ.'CONTINUE') BLOCK FOLLOWS:
!
            END IF
!
! END OF THE IF (IBELNG.NE.0) BLOCK:
!
         END IF
!
         IF(TWORD.EQ.KEYWDS(35))THEN
!!debug
		IF(ICLEN.EQ.1) THEN
			write(ioout,*)'ICLEN=1 inside CONT=CONT if stmt!!'
			write(ioout,*)'Some of CLINE follows: '
			write(ioout,'(72A1)')(cline(iik),iik=1,72)
			write(ioout,*)'Partial aline follows'
			write(ioout,*)ALINE(1:72)
			close(ioout)
			stop 870
			IJKLMN=IJKLMN+1
		END IF
!!END DEBUG

! CHECK THE WHOLE WORD
            DO K=1,8
               IIK=ICLEN-K+1
            MYSTR(9-K:9-K)=CLINE(ICLEN+1-K)
            END DO
            IF(MYSTR.EQ.'CONTINUE'.OR.MYSTR.EQ.'MYCDEF=0')THEN
! INSERT ALL OF THE 'END DO'
               IBEL=IBELNG
! REPLACE 'CONTINUE' BY BLAND 'IJKLMN=1'
               IF(MYSTR.EQ.'CONTINUE')THEN
                  MYSTR='IJKLMN=1'
                  DO K=1,8
                     IIK=ICLEN-8+K
                  CLINE(IIK)=MYSTR(K:K)
                  END DO
               END IF
!
! ? WHY DID I NOT OUT THE END DO AFTER THE DUMMY ??
! ANS: BECAUSE I WANTED A GOTO THE CONTINUE TO GET ONE OUT OF DOLOOP
! END OF THE IF(MYSTR.EQ.'CONTINUE') BLOCK FOLLOWS:
!
            ELSE
               CONYES=.FALSE.
            END IF
!
! END OF THE IF (TWORD.EQ.KEYWDS(35) BLOCK FOLLOWS:
!
         END IF
!
!
!     TEST LINE LENGTH AND WRITE OUTPUT LINE. APPEND CONTINUATION CARDS
!     AS NEEDED. USE DIFFERENT FORMATS FOR SCREEN AND FILE WRITING
!
         NFIRST=1
         NLAST=72
         NIC=1
         IF(ICLEN.LT.72)NLAST=ICLEN
         IF(ITARG.NE.1)THEN
!
!     REMOVE ANY REMAINING SPACE/SPC CODES AT RH END OF LINE
!
            NLST=NLAST
            IF(ICLEN.LE.72)CALL RESQEZ(NFIRST,NLST)
!
!     NLST SHOULD POINT TO FINAL NON-SPC CHAR POSITION LESS THAN NLAST
!
            CALL VARCHK(VARNAM,ISVAR)
!
            IF(ICLEN.LE.72)THEN
               WRITE(IOOUT,30)(CLINE(K),K=NFIRST,NLST)
!               WRITE(*,*)'REL21(1227)',(CLINE(K),K=NFIRST,NLST)
            ELSE
!
!      I AM GOING TO LET TRAILING AMPERSAND GO IN COL 73 SINCE THIS ISN'
!      HONEST TO GOD FORTRAN THAT WE ARE PRODUCING.
!
               WRITE(IOOUT,30)(CLINE(K),K=NFIRST,NLST),AMPERS
            END IF
!
!     PRINT CCARDS AS NEEDED
!
  990       LEFT=ICLEN-NLAST
            IF(LEFT.LE.0)GO TO  1030
!
!        NOW WE KNOW WE NEED CC'S
!
            NFIRST=NLAST+1
            idum=nfirst+65
            NLAST=MIN(ICLEN,idum)
            NLST=NLAST
!         CALL RESQEZ(NFIRST,NLST)
!
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
 1000       FORMAT(5X,A1,73A1)
!
            CALL VARCHK(VARNAM,ISVAR)
!
            IF(NLST.NE.ICLEN)THEN
               WRITE(IOOUT,1000)AMPERS,(CLINE(K),K=NFIRST,NLST),AMPERS
            ELSE
               WRITE(IOOUT,1000)AMPERS,(CLINE(K),K=NFIRST,NLST)
            END IF
            NIC=NIC+1
            IF(NIC.GT.9)NIC=1
            GO TO 990
         ELSE
!
! SCREEN OUTPUT CASE:
!
            NLST=NLAST
!         CALL RESQEZ(NFIRST,NLST)
!
!
            CALL VARCHK(VARNAM,ISVAR)
            IF(ICLEN.LE.72)THEN
               WRITE(IOOUT,10)(CLINE(K),K=NFIRST,NLST)
            ELSE
               WRITE(IOOUT,10)(CLINE(K),K=NFIRST,NLST),AMPERS
            END IF
!     PRINT CCARDS AS NEEDED(MORE THAN 9)
 1010       LEFT=ICLEN-NLAST
            IF(LEFT.LE.0)GO TO  1030
            NFIRST=NLAST+1
            idum=nfirst+65
            NLAST=MIN(ICLEN,idum)
            NLST=NLAST
            CALL RESQEZ(NFIRST,NLST)
!
 1020       FORMAT(5X,A1,73A1)
            IF(NLST.NE.ICLEN)THEN
               WRITE(IOOUT,1020)AMPERS,(CLINE(K),K=NFIRST,NLST),AMPERS
            ELSE
               WRITE(IOOUT,1020)AMPERS,(CLINE(K),K=NFIRST,NLST)
            END IF
!         WRITE(IOOUT,20)NIC,(CLINE(K),K=NFIRST,NLST)
            NIC=NIC+1
            IF(NIC.GT.9)NIC=1
            GO TO 1010
         END IF
 1030    IJKLMN=1
         GO TO 1040
!
! ------- NOW GO BACK AND TAKE CARE OF THE NEXT LINE OF SOURCE ---------
!
 1040    IJKLMN=1
!
         IDUM=IBELNG
         IF(IDUM.GT.0)THEN
            IF(.NOT.CONYES)THEN
               IBEL=IBELNG
               IF(IBEL.EQ.1)THEN
                                    IDUM=0
                  CALL MAKEDO(IDUM,NDLEVL,NKEEP)
                  IBELNG=0
               ELSE
                  DO I=1,IBEL
!         WRITE(IOOUT,*)'MAKEDO AT LOOP 842'
                     IF(IBEL.EQ.1)IBELNG=0
                     CALL MAKEDO(IBELNG,NDLEVL,NKEEP)
                  IBELNG=IBELNG-1
                  END DO
                  IF(IBELNG.LT.0)IBELNG=0
               END IF
            END IF
         END IF
!
         IF(IEXIT.NE.0)GO TO  1150
!
!     INSERT IMPLICIT NONE AFTER 1ST LINE
         IDUM=IBGFLG
         IF(IDUM.EQ.2)THEN
            IBGFLG=0
            IF(NUMCUR.NE.0)THEN
! ALSO NEED "USE MODULENAME" STMTS FOR CONVERTED COMMON BLOCK MODULES
               USENAM='                  '
               USENAM(1:10)='      USE '
               DO I=1,NUMCUR
                  WRKNAM=CURMOD(I)
                  DO J=1,16
                  USENAM(10+J:10+J)=WRKNAM(J:J)
                  END DO
!               WRITE(IOOUT,*)USENAM
                  WRITE(IOOUT,1080)USENAM
               END DO
            END IF
 1080       FORMAT(A18)
! EXTRA SPC ADDED TO NEXT TWO OUTPUTS FOR LF90, FPS 4.0 COMPILER BEHAVIO
            MISC='      IMPLICIT NONE'
                        ITMP=79
            CALL GETLEN(MISC,ITMP,ILEN)
            WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
            MISC='      INTEGER(2) :: IJKLMN, MYCDEF'
            CALL GETLEN(MISC,ITMP,ILEN)
            WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
!
! AND THAT ISN'T ALL! FOR SUBROUTINES AND FUNCTIONS NEED TO
! INSERT "INTENT" LOGIC AS WELL
            IF(NRTYPE.GT.0)THEN
               MISC='! ** BEGIN  EZUP-GENERATED ''INTENT'' STATEMENTS **&
     &'
               CALL GETLEN(MISC,ITMP,ILEN)
               WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
               WRITE(*,30)(MISC(JJ:JJ),JJ=1,ILEN)
!
               IF(ANS2)THEN
                  ITMP=72
                  CALL GETLEN(TYPDEC,ITMP,ILEN)
!
! 12 Oct 2009: If I skip the next write to ioout, then the function
! name will not be included with INTENT - which f90 doesnot allow anyway.
! An alternative way of handling the problem would be to omit the INTENT
! portion of the TYPDEC that is assigned in subroutine FNCHK. That might
! be preferable because it would make the data type of the function
! clearer - although it would be even better to reinsert the correct
! data type before the function name is written to ioout.
!
                  WRITE(IOOUT,40)(TYPDEC(JJ:JJ),JJ=1,ILEN)
                  WRITE(*,40)(TYPDEC(JJ:JJ),JJ=1,ILEN)
               END IF
!
               MISC='      UNKNOWN, INTENT(INOUT) :: '
               DO I=1,NPRMS
!### 12-8-9833:38 -> 33:48
                  MISC(33:48)=PRMLST(I)
                  ITMP=79
                  CALL GETLEN(MISC,ITMP,ILEN)
               WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
               END DO
               MISC='! ** END OF EZUP-GENERATED ''INTENT'' STATEMENTS **&
     &'
               CALL GETLEN(MISC,ITMP,ILEN)
               WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
!
!
                  ELSE
              MISC='! ** BEGIN  EZUP-GENERATED ''INTENT'' STATEMENTS **&
     &'
               CALL GETLEN(MISC,ITMP,ILEN)
               WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
               MISC='! ** END OF EZUP-GENERATED ''INTENT'' STATEMENTS **&
     &'
               CALL GETLEN(MISC,ITMP,ILEN)
               WRITE(IOOUT,30)(MISC(JJ:JJ),JJ=1,ILEN)
!
            END IF
!
         END IF
!
         IF(IERR.EQ.0)GO TO  120
!
! ----------------------------------------------------------------------
!     EOF PROCESSING SECTION
! ----------------------------------------------------------------------
 1110    IJKLMN=1
         IF(IERR.EQ.-1)THEN
            IEXIT=1
            IC=73
            DO I=1,72
            ALINE(I)=CONBUF(I:I)
            END DO
            DO I=1,72
               KHAR=ALINE(I)
               IC=IC-1
               IF(KHAR.NE.SPC.AND.KHAR.NE.SPACE)GO TO  1140
            END DO
 1140       ICLEN=IC
            GO TO 230
         END IF
!
         IF(IERR.EQ.-2)THEN
            IEXIT=2
            GO TO 230
         END IF
!
         IF(IERR.EQ.-3)THEN
            IEXIT=3
            GO TO 230
         END IF
!
         IF(IERR.EQ.-4)THEN
            WRITE(IOOUT,30)(NDF90(I),I=1,NAMLEN)
!        WRITE(IOOUT,90) NDCARD
            GO TO 1160
         END IF
         WRITE(*,*)'*FATAL ERROR IN IERR PROCESSING WITHIN <REL20>'
         STOP 203
! ---------------------------------------------------------------------
!     PSEUDO EXIT PROCESSING (AFTER ONE LAST PASS AT STD. PROCESSING)
! ---------------------------------------------------------------------
 1150    IJKLMN=1
         IF(IEXIT.EQ.1)THEN
            WRITE(*,*)'END OF FILE WITHOUT MODULE END STATEMENT. END STA&
     &TEMENT APPENDED (TYPE=1).'
            WRITE(IOOUT,100) NDCARD
            GO TO 1160
         END IF
!
         IF(IEXIT.EQ.2)GO TO  1160
         IF(IEXIT.EQ.3)THEN
            WRITE(IOOUT,100) NDCARD
            GO TO 1160
         END IF
!
!     SET END OF FILE FLAG FOR DRIVER
!
 1160    IJKLMN=1
!
!     END OF COPY AND PROCESSING
!
         DO J=1,LMAX
            IF(.NOT.LREF(J))THEN
               DO K=1,5
               LWORD(K:K)=LABEL(J,K,2)
               END DO
               WRITE(IOOUT,1180) LWORD
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
 1180          FORMAT('! ** LABEL ',A5,' WAS NEVER REFERENCED, SO LABEL &
     &AND/OR LINE WAS DELETED.')
!
            END IF
         END DO
         RETURN
      END SUBROUTINE REL21
! --------------------------
      SUBROUTINE PREAL
      USE RENCOM
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN, MYCDEF
      INTEGER(2) :: ISTRT1,id1,id2
! CONVERT REAL   -> REAL(4) ::
!         REAL*4 -> REAL(4) ::
!         REAL*8 -> REAL(8) ::
!
      ISTRT1=11
      IF(CLINE(11).EQ.'*')THEN
         IF(CLINE(12).EQ.'4'.OR.CLINE(12).EQ.'8')THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT ") ::"  (W/O ") AFTER THE 4
                        id1=13
                        id2=4
            CALL MVRT(id1,id2)
            CLINE(11)='('
            CLINE(13)=')'
            CLINE(14)=' '
            CLINE(15)=':'
            CLINE(16)=':'
            ISTRT1=17
            GO TO 10
         END IF
!
      END IF
!
      IF(CLINE(11).EQ.CHAR(255))THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT "4) ::"  (W/O ") AFTER THE 4
                  id1=11
                  id2=6
         CALL MVRT(id1,id2)
         CLINE(11)='('
         CLINE(12)='4'
         CLINE(13)=')'
         CLINE(14)=' '
         CLINE(15)=':'
         CLINE(16)=':'
         ISTRT1=17
      END IF
!10    CONTINUE
   10 CALL PARSEC(ISTRT1)
      RETURN
      END SUBROUTINE PREAL
! *********************************************************************
      SUBROUTINE PINTEG
      USE RENCOM
      IMPLICIT NONE
            integer(2) :: id1,id2
!      INTEGER(2) :: IJKLMN, MYCDEF
!
! CONVERT INTEGER -> INTEGER(2) ::
!         INTEGER*2 -> INTEGER(2) ::
!         INTEGER*4 -> INTEGER(2) ::
!
      IF(CLINE(14).EQ.'*')THEN
         IF(CLINE(15).EQ.'4'.OR.CLINE(15).EQ.'2')THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT ") ::"  (W/O ") AFTER THE 4
                        id1=16
                        id2=4
            CALL MVRT(id1,id2)
            CLINE(14)='('
            CLINE(16)=')'
            CLINE(17)=' '
            CLINE(18)=':'
            CLINE(19)=':'
            RETURN
         END IF
!
         IF(CLINE(15).EQ.'8')THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT ") ::"  (W/O ") AFTER THE 4
            CALL MVRT(id1,id2)
            CLINE(14)='('
            CLINE(15)='8'
            CLINE(16)=')'
            CLINE(17)=' '
            CLINE(18)=':'
            CLINE(19)=':'
            RETURN
         END IF
!
      END IF
!
      IF(CLINE(14).EQ.CHAR(255))THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT "(4) ::"
                  id1=14
                  id2=6
         CALL MVRT(id1,id2)
         CLINE(14)='('
         CLINE(15)='4'
         CLINE(16)=')'
         CLINE(17)=' '
         CLINE(18)=':'
         CLINE(19)=':'
      END IF
      RETURN
      END SUBROUTINE PINTEG
!
      SUBROUTINE PDOUB
      USE RENCOM
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN, MYCDEF
!     CONVERT DOUBLE PRECISION -> REAL(8) ::
!             DOUBLE PRECISION COMPLEX -> COMPLEX(8)
      CHARACTER(LEN=16) :: DOUBWD
      CHARACTER(LEN=8) :: DCOMP
      LOGICAL :: ISDOUB,ISDCMP
!
      INTEGER(2) :: I, ITEST,ID1,ID2
      DOUBWD='DOUBLE PRECISION'
      DCOMP=' COMPLEX'
      DOUBWD(7:7)=CHAR(255)
      DCOMP(1:1)=CHAR(255)
! DO WE REALLY HAVE A "DOUBLE PRCISION" STATEMENT ?
      ISDOUB=.TRUE.
      DO I=1,16
         ITEST=I+6
         IF(CLINE(ITEST).NE.DOUBWD(I:I))ISDOUB=.FALSE.
      END DO
      IF(.NOT.ISDOUB)RETURN
!     IS IT ALSO "COMPLEX" ?
      ISDCMP=.TRUE.
      DO I=1,8
         ITEST=I+22
         IF(CLINE(ITEST).NE.DCOMP(I:I))ISDCMP=.FALSE.
      END DO
      IF(.NOT.ISDCMP)THEN
!     ASSUME REAL(8)
!     FIRST, MAY NEED TO MOVE CHARACTERS TO THE LEFT
         CLINE(7)='R'
         CLINE(8)='E'
         CLINE(9)='A'
         CLINE(10)='L'
         CLINE(11)='('
         CLINE(12)='8'
         CLINE(13)=')'
         CLINE(14)=CHAR(255)
         CLINE(15)=':'
         CLINE(16)=':'
                  ID1=23
                  ID2=6
         CALL MVLFT(ID1,ID2)
      ELSE
!     VARS ARE TO BE COMPLEX(8)
         DO I=1,7
         CLINE(6+I)=DCOMP(I+1:I+1)
         END DO
         CLINE(14)='('
         CLINE(15)='8'
         CLINE(16)=')'
         CLINE(17)=CHAR(255)
         CLINE(18)=':'
         CLINE(19)=':'
                  ID1=31
                  ID2=11
         CALL MVLFT(ID1,ID2)
      END IF
      RETURN
      END SUBROUTINE PDOUB
! *********************************************************************
      SUBROUTINE PCOMPL
      USE RENCOM
      IMPLICIT NONE
            integer(2) :: id1,id2
!      INTEGER(2) :: IJKLMN, MYCDEF
!
!     CONVERT COMPLEX    -> COMPLEX(4) ::
!             COMPLEX*8  -> COMPLEX(4) ::
!             COMPLEX*16 -> COMPLEX(8) ::
!
      IF(CLINE(14).EQ.'*')THEN
         IF(CLINE(15).EQ.'4'.OR.CLINE(15).EQ.'8')THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT ") ::"  (W/O ") AFTER THE 4
                        id1=16
                        id2=4
            CALL MVRT(id1,id2)
            CLINE(14)='('
            CLINE(15)='4'
            CLINE(16)=')'
            CLINE(17)=' '
            CLINE(18)=':'
            CLINE(19)=':'
            RETURN
         END IF
!
         IF(CLINE(15).EQ.'1'.AND.CLINE(16).EQ.'6')THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT ") ::"  (W/O ") AFTER THE 4
                        id1=17
                        id2=3
            CALL MVRT(id1,id2)
            CLINE(14)='('
            CLINE(15)='8'
            CLINE(16)=')'
            CLINE(17)=' '
            CLINE(18)=':'
            CLINE(19)=':'
            RETURN
         END IF
!
      END IF
!
      IF(CLINE(14).EQ.CHAR(255))THEN
! NEED TO REPLACE THE ASTERISK BY (
! MOVE TO RIGHT BY ENUF SPCS TO INSERT "4) ::"  (W/O ") AFTER THE 4
         id1=14
                  id2=6
         CALL MVRT(id1,id2)
         CLINE(14)='('
         CLINE(15)='4'
         CLINE(16)=')'
         CLINE(17)=' '
         CLINE(18)=':'
         CLINE(19)=':'
!           CLINE(20) = ' '
      END IF
      RETURN
      END SUBROUTINE PCOMPL
!
      SUBROUTINE PLOGIC
      USE RENCOM
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN, MYCDEF
      CHARACTER(LEN=8) :: LOGIWD
      INTEGER(2) :: I,id1,id2
!
      LOGIWD='LOGICAL'
      LOGIWD(8:8)=CHAR(255)
      DO I=1,8
         IF(CLINE(6+I).NE.LOGIWD(I:I))RETURN
      END DO
            id1=14
            id2=3
      CALL MVRT(id1,id2)
      CLINE(14)=CHAR(255)
      CLINE(15)=':'
      CLINE(16)=':'
      RETURN
      END SUBROUTINE PLOGIC
! *********************************************************************!
      SUBROUTINE PIMPLI(JMPFLG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I
      LOGICAL, INTENT(INOUT) :: JMPFLG
!
!     THERE ARE MANY POSSIBLE THINGS TO DO HERE, SUCH AS
!     ANALYZING IMPLICIT REAL*8(A-H,O-Z)
!     BUT, FOR NOW, I AM ONLY GOING TO ACT TO OMIT ANY IMPLICIT
!     STATEMENTS FROM THE OUTPUT FILE -AND BE SATISFIED WITH THE
!     AUTOMATIC IMPLICIT NONE INSERTION
!
      CHARACTER(LEN=9) ::  IMPNAM
      IMPNAM(1:8)='IMPLICIT'
      IMPNAM(9:9)=CHAR(255)
      DO I=1,9
         IF(CLINE(6+I).NE.IMPNAM(I:I))THEN
            JMPFLG=.FALSE.
            RETURN
         END IF
      END DO
      JMPFLG=.TRUE.
      RETURN
      END SUBROUTINE PIMPLI
! *********************************************************************
      SUBROUTINE PDIMEN(JMPFLG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN,ILEN
      LOGICAL, INTENT(INOUT) :: JMPFLG
!
!     TRY TO REPLACE DIMENSION STATEMENTS
!     ASSUME NORMAL FORTRAN TYPING: (A-H,O-Z)-> REAL; (I-N)-> INTEGER
!     DIMENSION ABCD(12,45,6), HJKL(15), GHOI(6), NORML(13,27)
!     SHOULD BECOME SEVERAL STATEMENTS
!     REAL(4) :: ABCD(12,45,6), HJKL(15), GHOI(6)
!     INTEGER(2) :: NORML(13,27)
!
      CHARACTER(LEN=10) :: DIMWD
      CHARACTER(LEN=32) :: RVARS(50),IVARS(50),WORKWD,TMPWD
      CHARACTER(LEN=1) :: COMMA
      CHARACTER(LEN=1) :: TMPCH
      CHARACTER(LEN=1) :: RPAREN
      CHARACTER(LEN=11) :: LEADIN,LEADRE
      INTEGER(2) :: NREAL, NINTGR,I,J,K,NVKOU,KDIM,NXTONE
!
      COMMA=','
      RPAREN=')'
      LEADRE='REAL(4) :: '
      LEADIN='INTEGER(2) :: '
      DIMWD='DIMENSION'
      DIMWD(10:10)=CHAR(255)
!
! ---------------------------------------------------------------------
! I  WANT TO WORK MY WAY THROUGH CLINE LOOKING FOR VARIABLE NAMES AND
! THE ASSOCIATED DIMENSIONS, AND TO COPY THEM INTO SPECIAL ARRAYS FOR
! EASIER CONSTRUCTION OF THE SUBSTITUTE SOURCE CODE LINES. EG, FOR THE
! ABOVE SAMPLE SOURCE LINE I WOULD WANT
!     RVARS(1)='ABCD(12,45,6)'
!     RVARS(2)='HJKL(15)'
!     NREAL=3
!     RVARS(3)='GHOI(6)'
!     VARS(1)='NORML(13,27)'
!     NINTGR=1
! ---------------------------------------------------------------------
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   10 FORMAT(82A1)
!
!     VALIDATE THE COMPLETE WORD, OR RETURN
!
      DO I=1,10
         IF(CLINE(6+I).NE.DIMWD(I:I))RETURN
      END DO
!
!     I AM GOING TO GOBBLE THE DIMENSION LINE,SO SET:
!
      JMPFLG=.TRUE.
!
!     I EXPECT THAT CLINE(11) WILL CONTAIN CHAR(255) AS SPACE HOLDER
!     SO SEARCH SHOULD START AT COLUMN 11 AND LOOK FOR A COMMA
!
      NREAL=0
      NINTGR=0
      NVKOU=0
      NXTONE=17
!
   30 IJKLMN=1
      NVKOU=NVKOU+1
      TMPWD='                                '
      J=0
!     NEED TO SKIP OVER MY PLACE HOLDING CHAR(255) CODES IF PRESENT
      K=NXTONE
      DO I=K,ICLEN
         IF(CLINE(I).NE.CHAR(255))THEN
            NXTONE=I
            GO TO 50
         END IF
      END DO
   50 DO I=NXTONE,ICLEN
         J=J+1
         TMPCH=CLINE(I)
         IF(TMPCH.EQ.RPAREN)THEN
            ILEN=J
            WORKWD(J:J)=TMPCH
! NOW LOCATE THE NEXT COMMA OR END OF LINE
            KDIM=I
            NXTONE=0
            DO K=KDIM,ICLEN
               IF(CLINE(K).EQ.COMMA)THEN
                  NXTONE=K+1
                  GO TO 80
               END IF
               IF(K.EQ.ICLEN)NXTONE=-1
            END DO
            GO TO 80
         END IF
      WORKWD(J:J)=TMPCH
      END DO
   80 IF(ILEN.EQ.0)THEN
         WRITE(IOOUT,*)'ERROR 1 IN PDIMEN'
         RETURN
      END IF
      DO K=1,ILEN
      TMPWD(K:K)=WORKWD(K:K)
      END DO
      WORKWD=TMPWD
      TMPCH=WORKWD(1:1)
      IF((TMPCH.GE.'A'.AND.TMPCH.LE.'H').OR.(TMPCH.GE.'O'.AND.TMPCH.LE.'&
     &Z'))THEN
         NREAL=NREAL+1
         RVARS(NREAL)=WORKWD
      END IF
      IF(TMPCH.GE.'I'.AND.TMPCH.LE.'N')THEN
         NINTGR=NINTGR+1
         IVARS(NINTGR)=WORKWD
      END IF
!      ELSE
!          WRITE(IOOUT,*)'ERROR 2 IN PDIMEN'
!      END IF
!
      IF(NXTONE.NE.-1)GO TO  30
!
!     NOW WRITE THE NEW VERSIONS OF THE CARDS
!
      DO I=1,1450
      CLINE(I)=' '
      END DO
      IF(NREAL.GT.0)THEN
         NXTONE=6
         DO I=1,11
            NXTONE=NXTONE+1
         CLINE(6+I)=LEADRE(I:I)
         END DO
         DO J=1,NREAL
            WORKWD=RVARS(J)
            DO K=1,32
               TMPCH=WORKWD(K:K)
               IF(TMPCH.EQ.' ')GO TO  130
               NXTONE=NXTONE+1
            CLINE(NXTONE)=TMPCH
            END DO
  130       NXTONE=NXTONE+1
         CLINE(NXTONE)=COMMA
         END DO
         ICLEN=NXTONE-1
         WRITE(IOOUT,10)(CLINE(I),I=1,ICLEN)
         NLINE=NLINE+1
      END IF
!
! NOW THE INTEGER EXPRESSIONS, IF ANY
!
      IF(NINTGR.GT.0)THEN
         NXTONE=6
         DO I=1,11
            NXTONE=NXTONE+1
         CLINE(6+I)=LEADIN(I:I)
         END DO
         DO J=1,NINTGR
            WORKWD=IVARS(J)
            DO K=1,32
               TMPCH=WORKWD(K:K)
               IF(TMPCH.EQ.' ')GO TO  170
               NXTONE=NXTONE+1
            CLINE(NXTONE)=TMPCH
            END DO
  170       NXTONE=NXTONE+1
         CLINE(NXTONE)=COMMA
         END DO
         ICLEN=NXTONE-1
         WRITE(IOOUT,10)(CLINE(I),I=1,ICLEN)
         NLINE=NLINE+1
      END IF
!
      RETURN
      END SUBROUTINE
      SUBROUTINE PEQUIV
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I,ILEN, JJ
            INTEGER(2) :: itmp
      CHARACTER(LEN=11) :: TSTWD
      CHARACTER(LEN=79) :: MISC
!
!     VALIDATE THE COMPLETE WORD, OR RETURN
!
      TSTWD='EQUIVALENCE'
      DO I=1,11
         IF(CLINE(6+I).NE.TSTWD(I:I))RETURN
      END DO
!
!      WRITE(IOOUT,*)'!* WARNING: CANNOT CONVERT "EQUIVALENCE" STATEMENT
!     1'
      MISC='!* WARNING: CANNOT CONVERT "EQUIVALENCE" STATEMENTS'
            ITMP=79
      CALL GETLEN(MISC,ITMP,ILEN)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   20 FORMAT(79A1)
      WRITE(IOOUT,20)(MISC(JJ:JJ),JJ=1,ILEN)
      WRITE(*,*)'** WARNING: CANNOT CONVERT "EQUIVALENCE" STATEMENTS **'
      RETURN
      END SUBROUTINE PEQUIV
! *********************************************************************
      SUBROUTINE PPARAM
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I,ILEN, JJ
            INTEGER(2) :: ITMP
      CHARACTER(LEN=9) :: TSTWD
      CHARACTER(LEN=16) :: MISC
!
!     VALIDATE THE COMPLETE WORD, OR RETURN
!
      TSTWD='PARAMETER'
      DO I=1,9
         IF(CLINE(6+I).NE.TSTWD(I:I))RETURN
      END DO
!
!      WRITE(IOOUT,*)'!* WARNING: CANNOT CONVERT "PARAMETER" STATEMENTS'
      MISC='!* WARNING: CANNOT CONVERT "PARAMETER" STATEMENTS'
            ITMP=79
      CALL GETLEN(MISC,ITMP,ILEN)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   20 FORMAT(79A1)
      WRITE(IOOUT,20)(MISC(JJ:JJ),JJ=1,ILEN)
      WRITE(*,*)'** WARNING: CANNOT CONVERT "PARAMETER" STATEMENTS **'
      RETURN
      END SUBROUTINE PPARAM
! *********************************************************************
      SUBROUTINE PBLOCK
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I, ILEN,JJ
            INTEGER(2) :: ITMP
      CHARACTER(LEN=6) :: TSTWD
      CHARACTER(LEN=79) :: MISC
!
!     VALIDATE THE COMPLETE WORD, OR RETURN
!
      TSTWD='BLOCK'
      DO I=1,6
         IF(CLINE(6+I).NE.TSTWD(I:I))RETURN
      END DO
!
!      WRITE(IOOUT,*)'!* WARNING: CANNOT CONVERT "BLOCK DATA" STATEMENTS
      MISC='!* WARNING: CANNOT CONVERT "BLOCK DATA" STATEMENTS'
            ITMP=79
      CALL GETLEN(MISC,ITMP,ILEN)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   20 FORMAT(79A1)
      WRITE(IOOUT,20)(MISC(JJ:JJ),JJ=1,ILEN)
      WRITE(*,*)'** WARNING: CANNOT CONVERT "BLOCK DATA" STATEMENTS **'
      RETURN
      END SUBROUTINE PBLOCK
! *********************************************************************
      SUBROUTINE PDATA
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: ILEN, JJ
            INTEGER(2) :: ITMP
      CHARACTER(LEN=79) :: MISC
!      WRITE(IOOUT,*)'!* WARNING: CANNOT CONVERT "DATA" STATEMENTS **'
      MISC='!* WARNING: CANNOT CONVERT "DATA" STATEMENTS'
            ITMP=79
      CALL GETLEN(MISC,ITMP,ILEN)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   10 FORMAT(79A1)
      WRITE(IOOUT,10)(MISC(JJ:JJ),JJ=1,ILEN)
      WRITE(*,*)'** WARNING: CANNOT CONVERT "DATA" STATEMENTS **'
      RETURN
      END SUBROUTINE PDATA
! *********************************************************************
      SUBROUTINE PFORMA
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I,ILEN, JJ
            INTEGER(2) :: ITMP
      CHARACTER(LEN=6) :: TSTWD
      CHARACTER(LEN=79) :: MISC
!
!     VALIDATE THE COMPLETE WORD, OR RETURN
!
      TSTWD='FORMAT'
      DO I=1,6
         IF(CLINE(6+I).NE.TSTWD(I:I))RETURN
      END DO
!     WRITE(IOOUT,*)'!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS **'
      MISC='!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS'
            ITMP=79
      CALL GETLEN(MISC,ITMP,ILEN)
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   20 FORMAT(79A1)
      WRITE(IOOUT,20)(MISC(JJ:JJ),JJ=1,ILEN)
      WRITE(*,*)'** WARNING: CANNOT CONVERT "FORMAT" STATEMENTS **'
      RETURN
      END SUBROUTINE PFORMA
! *********************************************************************
      SUBROUTINE PRINFO
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I
   10 FORMAT(' LTYPE SET TO : ',I2,' FOR SOURCE LINE: ')
   20 FORMAT(82A1)
      WRITE(IOOUT,10) LTYPE
      WRITE(IOOUT,20)(CLINE(I),I=1,ICLEN)
      RETURN
      END SUBROUTINE PRINFO
! *********************************************************************
      SUBROUTINE PCHAR(JMPFLG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN
      LOGICAL, INTENT(INOUT) :: JMPFLG
      CHARACTER(LEN=9) :: CHWORD
      CHARACTER(LEN=5) :: LADDIN
      CHARACTER(LEN=4) :: TRAILR
      LOGICAL :: ISCHAR,ISNN
      INTEGER(2) :: NSTAR,NCASE,MSPC, I, MENDNO, NLEN, id1,id2
!     CHARACTER TMPBUF(16)
!     INTEGER TMPLEN,TMP1,TMP2
! ISCHAR=TRUE MEANS THAT THE WHOLE WORD CHARACTER IS THE LEADING TERM
! ISNN  =TRUE MEANS FORM CHARACTER*NN IS THE LEADING TERM IN CLINE
! NSTAR > 0   MEANS THAT WE HAVE MIXTURE CHARACTER A*12, B*5, ETC.
!
      CHWORD='CHARACTER'
      LADDIN='(LEN='
      TRAILR=') ::'
!     WANT TO CONVERT
! (1) "CHARACTER ABCDEF "   TO "CHARACTER(LEN=1) :: ABCDEF"
! (2) "CHARACTER*NN XYZZR,ABC" TO "CHARACTER(LEN=NN) :: XYZZR,ABC"
! (HARDER:)
! (3) "CHARACTER ABCDEF*NN"   TO "CHARACTER(LEN=NN) :: ABCDEF"
! MUCH HARDER:
! (4) CHARACTER A*3, B*16, D*17, IGHDG*91
! (5) CHARACTER A, KHAR*15, OTHER*32, LABEL(200,5)
!     THE LAST ONE IS A REAL DUKE'S MIXTURE!
! NOT TO MENTION:
!
!     CHARACTER(*) ANMUI(*,*,*)
!
      NSTAR=0
      ISCHAR=.TRUE.
      DO I=1,9
      IF(CLINE(6+I).NE.CHWORD(I:I))ISCHAR=.FALSE.
      END DO
      IF(.NOT.ISCHAR)RETURN
!     IS THE NEXT CHARACTER AN ASTERISK ??
      IF(CLINE(16).EQ.'*')THEN
         NCASE=2
         ISNN=.TRUE.
      ELSE
         ISNN=.FALSE.
      END IF
!     CHECK FOR MULTIPLE ASTERISKS AND COMMAS
      IF(.NOT.ISNN)THEN
         NCASE=1
      ELSE
!         ISNN IS TRUE:
         NCASE=2
! BUT, WE MIGHT HAVE: CHARACTER*(*)
!
         IF(CLINE(17).EQ.'('.AND.CLINE(18).EQ.'*'.AND.CLINE(19).EQ.')')N&
     &CASE=3
! WE WANT TO CREATE CHARACTER(LEN=*) :: ..........
!
      END IF
!
!     SELECT CASE (NCASE)
!     -------
!     CASE(1)
      IF(NCASE.EQ.1)THEN
         CALL PCHR1(JMPFLG)
         GO TO 80
      END IF
!     -------
!     CASE(2)
      IF(NCASE.EQ.2)THEN
!
!
! MUST SEPARATE OUT THE DESIRED CHARACTER LENGTH FROM, SAY, "*234"
! WHERE THE * MUST BE IN COLUMN 16
!
!
         DO I=17,ICLEN
            IF(CLINE(I).EQ.CHAR(255))THEN
               MENDNO=I-1
               GO TO 30
            END IF
         END DO
   30    IJKLMN=1
! NLEN IS # CHARS IN THE LENGTH SPECIFIER FOLLOWING THE "*"
         NLEN=MENDNO-17+1
                  id1=17
                  id2=4
                  call mvrt(id1,id2)
!         CALL MVRT(17,4)
         DO I=1,5
         CLINE(I+15)=LADDIN(I:I)
         END DO
!
         MSPC=21+NLEN
                  id2=4
         CALL MVRT(MSPC,id2)
         DO I=1,4
         CLINE(MSPC+I-1)=TRAILR(I:I)
         END DO
         GO TO 80
      END IF
!
!     -------
!     CASE (3)
      IF(NCASE.EQ.3)THEN
               id1=18
                  id2=3
         CALL MVRT(id1,id2)
         DO I=1,5
         CLINE(15+I)=LADDIN(I:I)
         END DO
                  id1=23
         CALL MVRT(id1,id2)
         DO I=1,4
         CLINE(I+21)=TRAILR(I:I)
         END DO
         GO TO 80
      END IF
!     -------
!
!     END SELECT
!
   80 IJKLMN=1
      RETURN
      END SUBROUTINE PCHAR
!  ********************************************************************
      SUBROUTINE PCHR1(JMPFLG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN
      LOGICAL, INTENT(INOUT) :: JMPFLG
!
!     PCHR1 IS USED TO HANDLE LINES WHICH CONTAIN MIXTURES OF
!     CHARACTER LENGTHS, SUCH AS
!
!     CHARACTER ABCD(10,32), DEFG(32,8)*16, XYX, XZ*8
! WHAT ABOUT?
!      CHARACTER*(*) AVALUE,A2   -  WHICH NOW GIVES:
!      CHARACTER(LEN=(*)) :: AVALUE,A2
!
!      CHARACTER BVALUE(*),ANK1(7) - WHIC NOW GIVES:
!      CHARACTER(LEN=)) :: BVALUE(
!      CHARACTER(LEN=1) :: ANK1(7)
!
!     LIMITATION: A SINGLE DECLARATION MUST NOT EXCEED 48 CHARS
!
      CHARACTER(LEN=1) :: CHBLK(48)
      CHARACTER(LEN=1) :: NEWOUT(72)
      CHARACTER(LEN=14) :: LADDIN
      CHARACTER(LEN=5) :: TRAILR
      INTEGER(2) :: BLKEND,BLKLEN,BEGSCH,ISTAR,NEWLEN,LENNN, I, J
      LOGICAL :: ISCHAR
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
      LADDIN='CHARACTER(LEN='
      TRAILR=') :: '
!
!     VALIDATE GENERAL PICTURE
      ISCHAR=.TRUE.
      DO I=1,9
         IF(CLINE(6+I).NE.LADDIN(I:I))ISCHAR=.FALSE.
      END DO
      IF(.NOT.ISCHAR)THEN
         JMPFLG=.FALSE.
         RETURN
      END IF
!###   LEN 16 CONVERSIOIN NEEDED BELOW ?
!     SET UP BASIC OUTPUT LINE:BBBBBBCHARACTER(LEN=
!
      DO I=1,6
      NEWOUT(I)=' '
      END DO
      DO I=1,14
      NEWOUT(6+I)=LADDIN(I:I)
      END DO
!
!     SEARCH FOR FIRST VARIABLE STRING BY CALLING "GETBLK" WITH SEARCH
!     TO BEGIN IN COLUMN 16 OF CLINE (WHICH OUGHT TO CONTAIN CHAR(255))
!
      BLKEND=15
!  19  FORMAT(1X,80A1)
   40 FORMAT(80A1)
   50 IJKLMN=1
      BEGSCH=BLKEND+1
      IF(BEGSCH.GT.ICLEN)GO TO  130
      CALL GETBLK(CHBLK,BLKLEN,BLKEND,BEGSCH,ISTAR)
      IF(BLKEND.LT.0)GO TO  130
!
!     IF ISTAR IS NOT ZERO THEN  VAR IS OF FORM NAME*NN
!
      IF(ISTAR.EQ.0)THEN
         NEWOUT(21)='1'
         NEWLEN=21
         DO I=1,5
            NEWLEN=NEWLEN+1
         NEWOUT(21+I)=TRAILR(I:I)
         END DO
         DO I=1,BLKLEN
            NEWLEN=NEWLEN+1
         NEWOUT(I+26)=CHBLK(I)
         END DO
         WRITE(IOOUT,40)(NEWOUT(J),J=1,NEWLEN)
         JMPFLG=.TRUE.
         GO TO 50
      ELSE
!
!     WILL FALL THROUGH TO HERE IF ISTAR >0 , NEED TO HANDLE
!     SUCH SITUATIONS AND THEN RECYLE FOR ANOTHER PASS UNTIL
!     WE RUN OUT OF DATA IN CLINE
!     NOW, WE KNOW THAT THE * LIES IN POSITION ISTAR OF CHBLK
!     SO,PROCEDE AS FOLLOWS:
!     FIRST APPEND THE NN OF *NN TO NEWOUT BEGINNING AT POSITION 21
!     THEN APPEND THE VARIABLE NAME FROM POSITIONS 1->(ISTAR-1) OF
!     CHBLK AND WRITE THE OUTPUT LINE
!
         NEWLEN=20
         LENNN=BLKLEN-ISTAR
!
!     IF LENNN=1, MAKE SURE THAT NEXT CHAR IS NOT A ) BEFORE PROCEDING!
!
         IF(LENNN.EQ.1.AND.CHBLK(ISTAR+1).EQ.')')THEN
!  WE MUST DO SOMETHING DIFFERENT!!!!!!!
!     APPEND TRAILR
            NEWLEN=NEWLEN+1
            NEWOUT(NEWLEN)='*'
            DO I=1,5
            NEWOUT(I+NEWLEN)=TRAILR(I:I)
            END DO
            NEWLEN=NEWLEN+5
            DO I=1,(ISTAR+1)
               NEWLEN=NEWLEN+1
            NEWOUT(NEWLEN)=CHBLK(I)
            END DO
            WRITE(IOOUT,40)(NEWOUT(J),J=1,NEWLEN)
            GO TO 50
         END IF
!
         DO I=1,LENNN
         NEWOUT(20+I)=CHBLK(ISTAR+I)
         END DO
!
!     APPEND TRAILR
!
         NEWLEN=20+LENNN
         DO I=1,5
         NEWOUT(NEWLEN+I)=TRAILR(I:I)
         END DO
         NEWLEN=NEWLEN+5
         DO I=1,(ISTAR-1)
            NEWLEN=NEWLEN+1
         NEWOUT(NEWLEN)=CHBLK(I)
         END DO
         WRITE(IOOUT,40)(NEWOUT(J),J=1,NEWLEN)
!
         GO TO 50
      END IF
!
!     DONE
!
  130 RETURN
      END SUBROUTINE PCHR1
! *********************************************************************
      SUBROUTINE GETBLK(CHBLK,BLKLEN,BLKEND,BEGSCH,ISTAR)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
! ** BEGIN  EZUP-GENERATED 'INTENT' STATEMENTS **
      CHARACTER(LEN=1)  , INTENT(INOUT) :: CHBLK(48)
      INTEGER(2)  , INTENT(INOUT) :: BLKLEN
      INTEGER(2)  , INTENT(INOUT) :: BLKEND
      INTEGER(2)  , INTENT(INOUT) :: BEGSCH
      INTEGER(2)  , INTENT(INOUT) :: ISTAR
! ** END OF EZUP-GENERATED 'INTENT' STATEMENTS **
!     CHARACTER(LEN=1) :: CHBLK(48)
      CHARACTER(LEN=1) :: TMPCHR
      CHARACTER(LEN=1) :: LPAREN
      CHARACTER(LEN=1) :: RPAREN
      CHARACTER(LEN=1) :: COMMA
      CHARACTER(LEN=1) :: ASTRSK
      INTEGER(2) :: BLKBEG,NPAREN,ICKOU, I
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
      LPAREN='('
      RPAREN=')'
      COMMA=','
      ASTRSK='*'
!
      NPAREN=0
      ICKOU=0
      ISTAR=0
      DO I=1,48
      CHBLK(I)=' '
      END DO
      DO I=BEGSCH,ICLEN
         TMPCHR=CLINE(I)
         IF(TMPCHR.EQ.CHAR(255).OR.TMPCHR.EQ.' ')GO TO  10
!
! I MIGHT FIND * AS FIRST NON BLANK CHARACTER TOO!
! BUT, FOR NOW ASSUME THAT WE HAVE DEALT WITH CHARACTER*NN ALREADY
!
         IF(ICKOU.EQ.0)BLKBEG=I
         ICKOU=ICKOU+1
         CHBLK(ICKOU)=CLINE(I)
         IF(TMPCHR.EQ.ASTRSK)ISTAR=ICKOU
         IF(TMPCHR.EQ.LPAREN)NPAREN=NPAREN+1
         IF(TMPCHR.EQ.RPAREN)NPAREN=NPAREN-1
         IF(I.EQ.ICLEN.OR.(TMPCHR.EQ.COMMA.AND.NPAREN.EQ.0))THEN
            BLKEND=I
            GO TO 30
         END IF
   10 IJKLMN=1
      END DO
   20 MYCDEF=0
   30 IJKLMN=1
      IF(BLKBEG.EQ.ICLEN.OR.BEGSCH.GT.ICLEN)THEN
!     WE ARE THROUGH OR FOUND NOTHING!
         BLKEND=-1
         BLKLEN=0
         RETURN
      END IF
      IF(BLKEND.LT.ICLEN)ICKOU=ICKOU-1
      BLKLEN=ICKOU
! CHBLK STILL CONTAINS TRAILING COMMA AT COL=ICKOU
      RETURN
      END SUBROUTINE GETBLK
! *********************************************************************
      SUBROUTINE PREWIN
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I,id1,id2
      CHARACTER(LEN=6) :: TESTWD
      LOGICAL :: ISOK
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
      TESTWD='REWIND'
      ISOK=.TRUE.
      DO I=1,6
      IF(CLINE(6+I).NE.TESTWD(I:I))ISOK=.FALSE.
      END DO
      IF(.NOT.ISOK)RETURN
            id1=13
            id2=1
      CALL MVRT(id1,id2)
      CLINE(13)=' '
      RETURN
      END SUBROUTINE PREWIN
! *********************************************************************
      SUBROUTINE PINCLU
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I,id1,id2
      CHARACTER(LEN=7) :: TESTWD
      LOGICAL :: ISOK
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
      TESTWD='INCLUDE'
      ISOK=.TRUE.
      DO I=1,7
      IF(CLINE(6+I).NE.TESTWD(I:I))ISOK=.FALSE.
      END DO
      IF(.NOT.ISOK)RETURN
            id1=14
            id2=1
      CALL MVRT(id1,id2)
      CLINE(14)=' '
      RETURN
      END SUBROUTINE PINCLU
! *********************************************************************
      SUBROUTINE PENTRY
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: I,id1,id2
      CHARACTER(LEN=5) :: TESTWD
      LOGICAL :: ISOK
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
      TESTWD='ENTRY'
      ISOK=.TRUE.
      DO I=1,5
      IF(CLINE(6+I).NE.TESTWD(I:I))ISOK=.FALSE.
      END DO
      IF(.NOT.ISOK)RETURN
            id1=12
            id2=1
      CALL MVRT(id1,id2)
      CLINE(12)=' '
      RETURN
      END SUBROUTINE PENTRY
! *********************************************************************
      SUBROUTINE FNCHK(TYPDEC,ANS1,ANS2)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN
      CHARACTER(LEN=73)  , INTENT(INOUT) :: TYPDEC
      LOGICAL, INTENT(INOUT) :: ANS1
      LOGICAL, INTENT(INOUT) :: ANS2
      CHARACTER(LEN=8) :: FNWD
      CHARACTER(LEN=1) :: BLNK
      CHARACTER(LEN=1) :: CH1
      CHARACTER(LEN=1) :: CH2
      CHARACTER(LEN=72) :: MISC
      INTEGER(2) :: K, K1, KW, NF, NDLEN, I, IW, M, M1, M2, M3, M4, NCH
      INTEGER(2) :: KMAX,id2
!
! CHECK CLINE TO SEE IF IT CONTAINS THE WORD FUNCTION (ANS1=TRUE)
! AND FIND ANY LEADING TYPE DECLARATIONS(ANS2=TRUE)
! IF SO, THEN COPY TYPE DECLARATION INFO TYPDEC
!
      FNWD = 'FUNCTION'
      BLNK=CHAR(255)
      IF(CLINE(1).EQ.'!')GO TO  170
      KW=1
      K=0
   10 K=K+1
      IF(K.GT.ICLEN)GO TO  170
      IF(CLINE(K).NE.FNWD(KW:KW))GO TO  10
      KW=KW+1
      K1=K
      IF(KW.EQ.9)GO TO  20
      GO TO 10
   20 ANS1=.TRUE.
!
!     NOW TEST FOR DATA TYPE DECLARATIONS
!     REAL, REAL*4, REAL*8
!     COMPLEX
!     CHARACTER
!     LOGICAL
!     DOUBLE REAL
!     DOUBLE COMPLEX , COMPLEX*8, COMPLEX*16
!     DOUBLE PRECISION REAL, REAL*4, REAL*8
!     DOUBLE PRECISION COMPLEX, COMPLEX*8, COMPLEX*16
!
!     PERHAPS THE VALUE OF K WILL BE A CLUE
!     F OF FUNCTION BEGINS IN COLUMN K-8
!     IF (K-8) IS ITSELF 7, THEN MAYBE WE HAVE SOMETHING
      NF=(K-8)
      NDLEN=0
      DO K=7,NF
         NDLEN=NDLEN+1
      TYPDEC(K-6:K-6)=CLINE(K)
      END DO
   50 IF(NDLEN.GT.4)THEN
         ANS2=.TRUE.
!--------------
! TEST CLINE TO SEE IF IT CONTAINS ASTERISK & DIGITS
! BUT IT IS WRONG TO TRY TO USE PRECONCEIVED COLUM NUMBERS
! BECAUSE REAL*8 OR COMPLEX*16 ARE QUITE DIFFERENT. THAT
! MEANS I MUST REALLY SEARCH FOR THE *
! BUT IF PRESENT IT WILL LIE BETWEEN COLS 1 AND NDLEN
!
         DO I=1,NDLEN
            M=I
            IF(TYPDEC(I:I).EQ.'*')GO TO  80
         END DO
!     NO * FOUND SO CARRY ON
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   70    FORMAT(A72)
         MISC='!** WARNING: NEXT FUNCTION-NAME''S DATA TYPE DECLARATION&
     & IS INCOMPLETE!'
         WRITE(IOOUT,70) MISC
         M3=NDLEN
         GO TO 130
   80    M1=M+1
         M2=M
         CH1=TYPDEC(M1:M1)
! WE HAVE FOUND AN ASTERISK IN COLUMN M
! LOCATE FIRST COLUMN > M+1 CONTAINING A NON-NUMERIC CHARACTER
         DO I=M1,NDLEN
            M=I
            IW=ICHAR(TYPDEC(I:I))
            IF(IW.LT.48.OR.IW.GT.57)GO TO  100
         END DO
         GO TO 110
  100    NCH=M-M1
! THERE ARE NCH NUMERIC CHARACTERS FOLLOWING THE *
! I THINK ONLY NCH=1 AND NCH2 WOULD BE LEGAL (4,8,16)
! I NEED TO DEFINE TYPDEC MORE CAREFULLY
! ALA   REAL(NN), INTENT(OUT) ::
! WHEREIN I INSERT THE LEFT PAREN AT PREV LOCATION OF THE *
         TYPDEC(M2:M2)='('
         M3=M2+1
         TYPDEC(M3:M3)=CH1
         M4=M3+1
         IF(NCH.EQ.2)CH2=TYPDEC(M4:M4)
         NDLEN=NDLEN+1
         IF(NCH.EQ.2)THEN
            M3=M3+1
            TYPDEC(M3:M3)=CH2
         END IF
         M3=M3+1
         M4=M3+17
         TYPDEC(M3:M3)=')'
         M3=M3+1
         NDLEN=NDLEN+1
!
         GO TO 130
  110    IJKLMN=1
! I DUNNO WHAT TO DO NOW.... WERE THERE NO DIGITS AT ALL ??
!
!
  130    IJKLMN=1
!--------------
! 12 October 2009: I am going to try to omit the INTENT term
! INSERT INTENT
!!         M4=M3+17
!!         TYPDEC(M3:M4)=', INTENT(OUT) :: '
!!         M3=M4+1
! try this instead:
			m4=m3+17
			typdec(m3:m4)='              :: '
			m3=m4+1
! 13 Oct 2009: The above change puts a bunch of spaces ahead of the
! double colon. My reason for doing that is the fact that another
! part of ezup expects a length of 17 for type declarations and I hope
! to avoid neding to make some e xceptions there for handling FUNCTION
! names.
!
! K1 TELLS ME WHERE FUNCTION NAME BEGINS:
         M=NDLEN
         K1=K1+1
! FUNCTION NAME MUST HAVE BEGUN IN COLUMN K1 AND HAS MAX LENGTH OF
! SIX CHARACTERS .. BUT MAY BE FEWER;WILL END AT A PAREN IF PRESENT
         KMAX=ICLEN-K1
         DO K=1,KMAX
            M=K+K1-1
            IF(CLINE(M).EQ.'(')GO TO  150
            IF(ICHAR(CLINE(M)).EQ.255)GO TO  140
            TYPDEC(M3:M3)=CLINE(M)
            M3=M3+1
  140    IJKLMN=1
         END DO
!  140    IJKLMN=1
!     IF CONTROL EVER COMES HERE, THERE IS PROBABLY A
!     MAJOR ERROR BECAUSE A L L FUNCTION STMTS OUGHT TO HAVE
!     AN ARGUMENT LIST ENCLOSED IN A PAIR OF PARENTHESES!
         WRITE(*,*)'** PROBABLE MISSING PARAMETER LIST FOR FUNCTION:'
         WRITE(*,'(A72)') TYPDEC
! IOOUT MAY BE WRONG UNIT AT THIS PARTICULAR MOMENT!!
         WRITE(IOOUT,*)'** PROBABLE MISSING PARAMETER LIST FOR FUNCTION:&
     &'
         WRITE(IOOUT,'(A37)') TYPDEC
         ANS2=.FALSE.
         GO TO 180
  150    IJKLMN=1
! NOW THAT WE HAVE  PRESERVED THE TYPE DECLARATION INFO
! STRIP IT FROM CLINE BY MOVING CLINE TO THE LEFT
         M=NF-7
         IF(M.GT.0)CALL MVLFT(NF,M)
! THERE MAY BE A CHAR(255) HANGING AROUND TOO, SO TRY TO
! ELIMINATE ANY LEADING ONES
         M=6
  160    M=M+1
         IF(ICHAR(CLINE(M)).EQ.255)THEN
            M1=M+1
            id2=1
            CALL MVLFT(M1,id2)
            GO TO 160
         END IF
!
      ELSE
!6-10-97 DID HAVE ANS2=.FALSE. AND NO GO TO!
         ANS2=.TRUE.
         TYPDEC='UNKNOWN'
         NDLEN=8
         GO TO 50
      END IF
      GO TO 180
!
  170 ANS1=.FALSE.
      ANS2=ANS1
      GO TO 180
  180 RETURN
      END SUBROUTINE FNCHK
         Subroutine  ezclean()
!
! This is  a post-post processor for ezup 207
! It looks at the previously "final" output file
! and tries to insert a space code between any double colon
! pairs and pushes the rest of the chareacters to the right.
! HOWEVER, it does not  (yet) do that for type declaration
! lines that are followed by continuation cards. That
! situation is signaled by an ampersand in column 73.
!
! "fname2" is name of the ezup output file(32 char max)
! It is assumed to be closed when this routine'
! is called.
!      character(LEN=96) :: inname
      use rencom
      Character(73) :: OLDLINE, NEWLINE
		character(5) :: WTST
      character(1) :: AMPS
      integer(2) :: i,j,k,llen,L1
      integer iin,itf
    1 format(a73)
!
      itf=77
      iin=78
      L1=73
      amps='&'
      open(unit=iin,file=fname2,status='old',err=9000)
      open(unit=itf,file='ezclean.tmp',status='unknown')
      rewind iin
      rewind itf
   10 read(iin,1,end=8900) oldline
      if (oldline(6:6).eq.amps.or.oldline(73:73).eq.amps.or.oldline    &
     &(72:72).ne.' ') then
        write(itf,1)oldline
        goto 10
      end if
      call  clr73(newline)
      call getl73(oldline,L1,llen)
! In spite of other efforts, there are still some char(255) codes that
! need to be replaced by SPC codes
		
		DO I=7,11
				WTST(I-6:I-6)=OLDLINE(I:I)
		END DO
	   if (WTST.NE.'WRITE') then
         do i=7,llen
            if (ICHAR(oldline(i:i)).eq.255) oldline(i:i)=' '
         end do
		end if      
! Look for a double colon pair
      do i=7,llen-1
        if(oldline(i:i+1).eq.'::') then
        k=i+1
        goto 20
        end if
      end do
! did not find the :: pair, so pass the line as it is
      write(itf,1)oldline
      goto 10
  20  newline(1:k)=oldline(1:k)
      do i=k+2,llen+1
        newline(i:i)=oldline(i-1:i-1)
      end do
      newline(k+1:k+1)=' '
      write(itf,1) newline
      goto 10
8900  rewind itf
      close(iin)
      open(unit=iin,file=fname2,status='old',err=9000)
      rewind (iin)
      do k=1,9999
        read(itf,1,end=9999) oldline
        call getl73(oldline,L1,llen)
        write(iin,'(73a1)') (oldline(J:J),j=1,llen)
      end do
9000  write(*,*)'Could not open file ',fname2
9999  close(iin)
      return
      end subroutine ezclean
! ******** BEGIN ROUTINES THAT CONSTITUTE "AUXUTILG"   **********
      SUBROUTINE PAKLFT(ASTRING,START,LLEN)
!      REMOVE LEADING (ON LEFT) SPC CODES FROM ASTRING BEGINNING AT
! POSITION START AND ENDING AFTER LLEN CHARS ARE EXAMINED
      CHARACTER(LEN=73) :: ASTRING,TMPSTR
      INTEGER(2) :: I,K,LLEN,START,AEND
      AEND=START+LLEN-1
      IF (AEND.GT.73) AEND=75
! FIND FIRST NON SPC CHAR TO RIGHT OF COL 7
      DO I=START,AEND
      IF (ASTRING(I:I).NE.' ') THEN
            J=I
            EXIT
      END IF
      END DO
      K=1
      DO I=1,LLEN
             K=I+J-1
             TMPSTR(I:I)=ASTRING(K:K)
      END DO
      DO I=1,LLEN
             ASTRING(I:I)=TMPSTR(I:I)
      END DO
      RETURN
      END SUBROUTINE PAKLFT
!
      SUBROUTINE CNVNUL(ASTRING)
! REPLACE EVERY CONTROL CODE  BY SPC
      CHARACTER(LEN=16) :: ASTRING
      INTEGER(2) :: I ,ICC
! NEXT LINE IS MS FPS4 VALUE FOR HEX 21. OTHER COMPILERS MAY CRASH
!      ICC=16#21
! THE FOLLOWING WORKS WITH G95 BUT NOT MS FPS 4
!      ICC=Z'21'
      DATA ICC/Z'21'/
      DO I=1,16
            IF (ICHAR(ASTRING(I:I)).LE.ICC) ASTRING(I:I)=' '
      END DO
      END SUBROUTINE CNVNUL
!
      SUBROUTINE PAKLIN1(WRKLIN,LLEN)
      USE RENCOM
      CHARACTER(LEN=73), INTENT(INOUT) :: WRKLIN
      CHARACTER(LEN=73) :: TMPLIN,WRKCPY
      CHARACTER(LEN=1) ::SPC
      CHARACTER(LEN=4) :: TWORD
      INTEGER(2) :: I,IDUM,LLEN,id1,id2
! THE NEXT LINE IS OK FOR MS FPS 4.0 COMPILER
!      NUL=CHAR(16#0)
! THE FOLLOWING WORKS WITH G95 BUT NOT MS FPS 4
      DATA NUL /Z'0'/
      SPC=' '
      IDUM=6
      DO I=1,73
            TMPLIN(I:I)=' '
            WRKCPY(I:I)=' '
      END DO
! COMPACT INSTRING WRKLIN PAST POSITION 6 IN WRKLIN
! INSTRING MUST BE LE 80 CHAR LONG
! EXCEPT LINES CONTAINING FIRST 4 CHARS OF CERTAIN KEYWORDS IN
! COLS 7:10
      WRKCPY(1:72)=WRKLIN(1:72)
      ID1=7
      ID2=48
      CALL PAKLFT(WRKCPY,ID1,ID2)
! SPECIAL CASE FOR DO-LOOPS:
      IF (WRKCPY(1:3).EQ.'DO ') RETURN
      TWORD(1:4)=WRKCPY(1:4)
      IF(TWORD.EQ.'EXTE') THEN
            IJKLM=1
      END IF
! ABOVE ASSIGNMENT IS NOT ADEQUATE - IT CAN FAIL ON INDENTED LINES
! MAYBE I CAN MAKE A COPY OF FIRST FEW CHARS OF WRKLIN AND TEST
! THAT AFTER APPLYING PAKLFT ROUTINE TO THE COPY
!
! THE NEXT LOOP WAS ADDED AROUND 23 JULY TO AVOID COMPRESSING SOME
! LINES CONTAINING KEYWORDS...BUT IT IS NOT WORKING WELL, PARTICULARLY
! IF THE INPUT LINE HAS A CCARDTO FOLLOW. IN THAT CASE A SIMPLE RETURN
! SEEMS TO BE INADEQUATE
      DO I=1,40
            IF (TWORD.EQ.KEYWDS(I)) RETURN
      END DO
      DO I=1,80
            TMPLIN(I:I)=SPC
      END DO
      DO I=7,LLEN
            IF(ICHAR(WRKLIN(I:I)).NE.NUL.AND.WRKLIN(I:I).NE.SPC) THEN
            IDUM=IDUM+1
            TMPLIN(IDUM:IDUM)=WRKLIN(I:I)
            END IF
      END DO
      DO I=1,LLEN
            WRKLIN(I:I)=TMPLIN(I:I)
      END DO
      RETURN
      END SUBROUTINE PAKLIN1
! *********************************************************************
      SUBROUTINE PAKLLIN(WRKLIN,LLEN)
      USE RENCOM
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE
!
      CHARACTER(LEN=1450), INTENT(INOUT) :: WRKLIN
      CHARACTER(LEN=1450) :: TMPLIN,WRKCPY
      CHARACTER(LEN=1) ::SPC
      CHARACTER(LEN=4) :: TWORD
      INTEGER(2) :: I,IDUM,id1,id2
      INTEGER(2) :: LLEN
! THE NEXT LINE IS OK FOR MS FPS 4.0 COMPILER
      DATA NUL /Z'0'/
! NEXT VERSION OK FOR G95 COMPILER
!      NUL=CHAR(Z'0')
      SPC=' '
      IDUM=6
      LLEN=GETLLEN(WRKLIN)
!!      CALL CLRLLIN(TMPLIN)
!!      CALL CLRLLIN(WRKCPY)
      CALL CLR73(TMPLIN)
      CALL CLR73(WRKCPY)
      DO I=1,73
            TMPLIN(I:I)=' '
            WRKCPY(I:I)=' '
      END DO
! COMPACT INSTRING WRKLIN PAST POSITION 6 IN WRKLIN
! INSTRING MUST BE LE 80 CHAR LONG
! EXCEPT LINES CONTAINING FIRST 4 CHARS OF CERTAIN KEYWORDS IN
! COLS 7:10
      WRKCPY(1:72)=WRKLIN(1:72)
      ID1=7
      ID2=48
      CALL PAKLFT(WRKCPY,ID1,ID2)
! SPECIAL CASE FOR DO-LOOPS:
      IF (WRKCPY(1:3).EQ.'DO ') RETURN
      TWORD(1:4)=WRKCPY(1:4)
      IF(TWORD.EQ.'EXTE') THEN
            IJKLM=1
      END IF
! ABOVE ASSIGNMENT IS NOT ADEQUATE - IT CAN FAIL ON INDENTED LINES
! MAYBE I CAN MAKE A COPY OF FIRST FEW CHARS OF WRKLIN AND TEST
! THAT AFTER APPLYING PAKLFT ROUTINE TO THE COPY
!
! THE NEXT LOOP WAS ADDED AROUND 23 JULY TO AVOID COMPRESSING SOME
! LINES CONTAINING KEYWORDS...BUT IT IS NOT WORKING WELL, PARTICULARLY
! IF THE INPUT LINE HAS A CCARDTO FOLLOW. IN THAT CASE A SIMPLE RETURN
! SEEMS TO BE INADEQUATE
      DO I=1,40
            IF (TWORD.EQ.KEYWDS(I)) THEN 
                  RETURN
            END IF
      END DO
      DO I=1,80
            TMPLIN(I:I)=SPC
      END DO
      DO I=7,LLEN
            IF(ICHAR(WRKLIN(I:I)).NE.NUL.AND.WRKLIN(I:I).NE.SPC) THEN
            IDUM=IDUM+1
            TMPLIN(IDUM:IDUM)=WRKLIN(I:I)
            END IF
      END DO
      DO I=1,LLEN
            WRKLIN(I:I)=TMPLIN(I:I)
      END DO
      RETURN
      END SUBROUTINE PAKLLIN

      INTEGER(2) FUNCTION GETLLEN(PHRASE)
      CHARACTER(LEN=1450) :: PHRASE
      INTEGER(2) :: I,J
! THE NEXT LINE IS OK FOR MS FPS 4.0 COMPILER
      DATA NUL /Z'0'/
! USE THE NEXT LINE FOR G95 COMPILER
!      NUL=CHAR(Z'0')
      DO I=1,1450
            J=1451-I
            IF (PHRASE(J:J).NE.' '.AND.ICHAR(PHRASE(J:J)).NE.NUL) THEN
                  GETLLEN=J
                  RETURN
            END IF
      END DO
! DEFAULT
      GETLLEN=J
      RETURN
      END FUNCTION GETLLEN
! *********************************************************************
      SUBROUTINE CLRLLIN(ASTRING)
      CHARACTER(LEN=1450) :: ASTRING
      INTEGER(2) :: I
      DO I=1,1450
            ASTRING(I:I)=' '
      END DO
      RETURN
      END SUBROUTINE CLRLLIN
! *********************************************************************
      SUBROUTINE CLRLL(ASTRING)
      CHARACTER(LEN=1) :: ASTRING(1450)
      INTEGER(2) :: I
      DO I=1,1450
            ASTRING(I)=' '
      END DO
      RETURN
      END SUBROUTINE CLRLL
! *********************************************************************  
      SUBROUTINE CLR73(STRING)
      CHARACTER(LEN=73) :: STRING
      INTEGER(2) :: I
      DO I=1,73
            STRING(I:I)=' '
      END DO
      return
      END SUBROUTINE CLR73
! *********************************************************************
      SUBROUTINE PUTLIN(STRING,LUO)
      IMPLICIT NONE
! PURPOSE: WRITE AN INCOMING STRING TO THE TEMPORARY NEWPRG.TMP
! FILE, CREATING CCARDS WHEN NEEDED
! THE INCOMING STRING SHOULD NOT CONTAIN ANY AMPERSANDS !!
!
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE
!
      CHARACTER(LEN=1450) ::STRING
      CHARACTER(LEN=73) :: TMPLIN
      INTEGER(KIND=2) :: I,I1,I2,I3,I4,N,NTOGO
      integer LUO
      INTEGER(2) :: LLEN,NWRK
    1 FORMAT(A72)
       2 FORMAT(A73)
      CALL CLR73(TMPLIN)
      LLEN=GETLLEN(STRING)
      NTOGO=LLEN
      N=0
      NWRK=73
      TMPLIN=""
      IF (LLEN.LE.72) THEN
!            WRITE(40,*) STRING(1:72)
!            WRITE(LUO,1) STRING(1:72)
      WRITE(LUO,'(80A1)') (STRING(I:I),I=1,LLEN)
            RETURN
      ELSE
            I1=1
            I2=72
            I3=1
            I4=72
         10      TMPLIN(I1:I2)=STRING(I3:I4)
! NO OF CHARS WRITTEN IS AEND-START+1
            IF(NTOGO.GT.72) THEN
                  TMPLIN(I2+1:I2+1)='&'
                  WRITE(40,2) TMPLIN
            ELSE
                  WRITE(40,1)TMPLIN
                  RETURN
            END IF
            NTOGO=LLEN-I4+1
            I3=I4+1
            IF(NTOGO.LE.66) THEN
                  I4=I3+NTOGO-1
            ELSE
                  I4=I3+65
            END IF
            CALL CLR73(TMPLIN)
            TMPLIN(6:6)='&'
            I1=7
            IF(NTOGO.LT.66) THEN
                  I2=NTOGO      +I1
            ELSE
                  I2=72
            END IF
!            IF(START.GT.LLEN) RETURN
            GOTO 10
      END IF
!
      END SUBROUTINE PUTLIN
! *********************************************************************
      SUBROUTINE READCC(SLINE,WRKLIN,LEN1,LUIN)
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE
      INTERFACE
         SUBROUTINE GETL73(PHRASE,NWRK,LEN1)
         CHARACTER(LEN=73)  , INTENT(INOUT) :: PHRASE
         INTEGER(2)  , INTENT(INOUT) :: NWRK,LEN1
         END SUBROUTINE GETL73
      END INTERFACE
!
      CHARACTER(LEN=1450) :: WRKLIN
      CHARACTER(LEN=73) :: SLINE
      INTEGER(2) :: I,LEN1,NWRK
      integer luin
      INTEGER(KIND=2) :: I1,I2,I3,I4
      BACKSPACE(LUIN)
   10 FORMAT(A73)
      CALL CLRLLIN(WRKLIN)
      I=7
      I1=1
      I2=72
      I3=1
      I4=72
      NWRK=73
      20      READ(LUIN,10,END=30) SLINE
            CALL GETL73(SLINE,NWRK,LEN1)
            IF(LEN1.LT.72) THEN
                  I2=I1+LEN1
                  I4=I3+LEN1
            END IF
            WRKLIN(I1:I2)=SLINE(I3:I4)
            IF (SLINE(73:73).NE.'&') THEN
!                   LEN1=I
                   GOTO 30
            END IF
            I3=7
            I1=I2+1
            IF (LEN1.LT.66) THEN
                  I4=I3+LEN1
            ELSE
                  I4=72
            END IF
            I2=I1+65
!
            GOTO 20      
      30 K=1
      CALL RMAMPS(WRKLIN)
         LEN1=GETLLEN(WRKLIN)
      RETURN      
      END SUBROUTINE READCC
! ---------------------------------------------------------------------
      SUBROUTINE GETL73 (PHRASE,NWRK,LINLEN)
      IMPLICIT NONE
      CHARACTER(LEN=73)  , INTENT(INOUT) :: PHRASE
      INTEGER(2)  , INTENT(INOUT) :: NWRK                  
      INTEGER(2)  , INTENT(INOUT) :: LINLEN
      INTEGER(2) :: N,L
!
!     TRY TO LOCATE RIGHTMOST CHARACTER WHICH ISN'T BLANK
!     RETURN POSITION AS LINLEN
!     CALLER SHOULD SPECIFY SIZE OF PHRASE
      DO N=1,NWRK
         L=NWRK-N+1
!         IF (PHRASE(L:L).NE.' ') THEN
         IF(PHRASE(L:L).NE.' '.AND.ICHAR(PHRASE(L:L)).NE.0)THEN
      LINLEN=L
      RETURN
         END IF
      END DO
      LINLEN=1
      RETURN
      END SUBROUTINE GETL73
! *********************************************************************
      SUBROUTINE PAKLIN(STRNGIN)
!      PURPOSE IS TO REMOVE ANY SPC CODES BETWEEN COL 6 AND FIRST
!      NON-SPC CHARACTER. THIS ROUTINE IS INTENDED FOR USE WITH
!      CONTINUATION CARDS
!
      CHARACTER*80, INTENT(INOUT) :: STRNGIN
      CHARACTER*80 WORKSTR
      CHARACTER :: AMPERS,SPC,COL73
      INTEGER(2) :: I,J,K
      LOGICAL :: ATEND
!
      SPC=' '
      AMPERS='&'
      ATEND=.FALSE.
      DO I=1,80
         WORKSTR(I:I)=' '
      END DO
!      FIND THE FIRST NON-SPC CHAR
      DO I=7,72
        IF (STRNGIN(I:I).NE.SPC) THEN
           J=I
           EXIT
        END IF
      END DO
        WORKSTR(1:6)=STRNGIN(1:6)
        COL73=STRNGIN(73:73)
        J=6
        DO K=7,72
          IF(STRNGIN(K:K).NE.SPC) THEN
             J=J+1
             WORKSTR(J:J)=STRNGIN(K:K)
          END IF
        END DO
!      IF THERE IS AN AMPERSAND IN COL 73, I GUESS I MUST KEEP IT THERE
        IF (COL73.EQ.AMPERS) THEN
          WORKSTR(73:73)=COL73
        END IF
        STRNGIN=WORKSTR
        RETURN
        END SUBROUTINE PAKLIN
! *********************************************************************
        SUBROUTINE PAKNAM(STRNGIN,NAMLEN)
!      PURPOSE IS TO REMOVE ANY SPC CODES BETWEEN COL 6 AND FIRST
!      NON-SPC CHARACTER. THIS ROUTINE IS INTENDED FOR USE WITH
!      CONTINUATION CARDS
!
        CHARACTER*80, INTENT(INOUT) :: STRNGIN
        CHARACTER*80 WORKSTR
        CHARACTER :: SPC
        INTEGER(2) :: J,K,NAMLEN
!
        SPC=' '
        J=6
        DO K=1,NAMLEN
          IF(STRNGIN(K:K).NE.SPC) THEN
             J=J+1
             WORKSTR(J:J)=STRNGIN(K:K)
          END IF
        END DO
        STRNGIN=WORKSTR
        RETURN
        END SUBROUTINE PAKNAM
!
      SUBROUTINE CCARD1(STRNG,LUIN,FLAG)
!        READ INPUT FILE UNTIL I FIND A CARD THAT CONTAINS A & IN COL 6
!      BUT NOT IN COL 73 
      CHARACTER*80 STRNG
      INTEGER LUIN,FLAG
      FLAG=0
      IF (STRNG(6:6).NE.'&') THEN
         RETURN
      END IF
10    READ(LUIN,'(80A)') STRNG
      IF ((STRNG(6:6).EQ.'&') .AND. (STRNG(73:73).EQ.'&')) GO TO 10
      FLAG=1
      RETURN
      END SUBROUTINE CCARD1
!
      SUBROUTINE GETLEN (PHRASE,NWRK,LINLEN)
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN, MYCDEF
      CHARACTER(LEN=128)  , INTENT(INOUT) :: PHRASE
      INTEGER(2)  , INTENT(INOUT) :: NWRK
      INTEGER(2)  , INTENT(INOUT) :: LINLEN
      INTEGER(2) :: N,L
!
!     TRY TO LOCATE RIGHTMOST CHARACTER WHICH ISN'T BLANK
!     RETURN POSITION AS LINLEN
!     CALLER SHOULD SPECIFY SIZE OF PHRASE
      DO N=1,NWRK
         L=NWRK-N+1
!         IF (PHRASE(L:L).NE.' ') THEN
         IF(PHRASE(L:L).NE.' '.AND.ICHAR(PHRASE(L:L)).NE.0)THEN
      LINLEN=L
      RETURN
         END IF
      END DO
      LINLEN=1
      RETURN
      END SUBROUTINE GETLEN
! *********************************************************************
      SUBROUTINE MVRT(MSTRT,MSPC)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2), INTENT(INOUT) :: MSTRT, MSPC
!
!     SHIFT CONTENTS OF CLINE TO RIGHT BY MSPC SPACES BEGINNING
!     WITH ELEMENT MSTRT
!     IE CLINE(1 TO MSTRT-1) ARE LEFT ALONE
!        CLINE(MSTRT) MOVED TO CLINE(MSTRT+MSPC)
!
      INTEGER(2) :: I, NEWLEN,NEWPOS,MOVEE,MYMAX, NMOVE
!
      MYMAX=1450-MSPC
      NEWLEN=ICLEN+MSPC
      NMOVE=ICLEN-MSTRT+1
!
      DO I=1,NMOVE
         NEWPOS=NEWLEN-I+1
         MOVEE=ICLEN-I+1
         CLINE(NEWPOS)=CLINE(MOVEE)
      END DO
      ICLEN=NEWLEN
      IF(ICLEN.GT.MYMAX)THEN
!
         WRITE(IOOUT,*)'** TRUNCATION OCCURED AT LINE ',NLINE
      END IF
      RETURN
      END SUBROUTINE MVRT
! *********************************************************************
      SUBROUTINE MVLFT(MSTRT,MSPC)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2), INTENT(INOUT) :: MSTRT, MSPC
!
!     SHIFT CONTENTS OF CLINE TO LEFT BY MSPC SPACES BEGINNING
!     WITH ELEMENT MSTRT
!     IE CLINE(1 TO MSTRT-MSPC-1) ARE LEFT ALONE
!        CLINE(MSTRT) MOVED TO CLINE(MSTRT-MSPC)
!
      INTEGER(2) :: I, NEWLEN,NEWPOS,MOVEE,NMOVE,MYMAX
!
      MYMAX=1450-MSPC
      NEWLEN=ICLEN-MSPC
      NMOVE=ICLEN-MSTRT+1
!
      DO I=1,NMOVE
         NEWPOS=MSTRT-MSPC-1+I
         MOVEE=MSTRT-1+I
         CLINE(NEWPOS)=CLINE(MOVEE)
      END DO
      ICLEN=NEWLEN
!19 Oct 2009: Put space codes in the cols that are no longer valie
	  DO I=1,MSPC
		CLINE(ICLEN+I)=' '
	  END DO
!	 
      IF(ICLEN.GT.MYMAX)THEN
!
         WRITE(IOOUT,*)'** TRUNCATION OCCURED AT LINE ',NLINE
      END IF
      RETURN
      END SUBROUTINE MVLFT
! *********************************************************************
      SUBROUTINE RMAMPS(WRKLIN)
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE

!     REMOVE ALL AMPERSANDS AND SPACE CODES TO RIGHT OF :: PAIR IN WRKLIN
      CHARACTER(LEN=1450) :: WRKLIN, NEWLIN
      INTEGER(KIND=2) :: I,J,K,LLEN,CLNPOS,J1
      LOGICAL :: XFLAG
		CHARACTER(4) :: TESTX
      CALL CLRLLIN(NEWLIN)
      LLEN=GETLLEN(WRKLIN)
! FIND THE ::
      DO I=1,LLEN-1
            IF(WRKLIN(I:I+1).EQ.'::') THEN
! SET K TO POINT TO THE COLUMN FOLLOWING THE SECOND COLON
! AND CLNPOS TO POINT TO THE COL CONTAINING SECOND COLON
                  K=I+2
                  CLNPOS=I+1
!                  k=i+1
!                  clnpos=i
                  XFLAG=.FALSE.
                  GOTO 10
            END IF
      END DO
! 17 AUG 2009: SKIP SOME STMTS IF THERE IS NO :: PAIR
! 06	OCT 2009: ONE MORE TEST. SOME STATEMENTS MAY BE INDENTED SO BEFORE
! MAKING THE CHECKS FOR SPECIAL CASES TO BE SKIPPED, FIND THE FIRST CHAR
! THAT IS NOT A SPACE-CHAR STARTING AT COLUMN 7
		J1=7
      DO I=7,72
				IF (WRKLIN(I:I).NE.' ') THEN
						J1=I
						GO TO 5		
				END IF
		END DO
	 5	TESTX=WRKLIN(J1:J1+3)
		CALL UCA(TESTX)
      if(TESTX.eq.'FORM') goto 1000
      if(TESTX.eq.'DATA') goto 1000
      if(TESTX.eq.'WRIT') goto 1000
      if(TESTX.eq.'CALL') goto 1000
      if(TESTX.eq.'GOTO') goto 1000
!
! UNFORTUNATELY, THERE ARE SOME LEGAL STATEMENTS THAT DO NOT CONTAIN THE
! PAIR OF COLONS. IN SUCH A CASE CONTROL COMES TO HERE. 
! ONE SUCH CASE I HAVE FOUND INVOLVES AN 'EXTERNAL ...' WITH CCARDS
      DO I=1,LLEN-1
            IF(WRKLIN(I:I+7).EQ.'EXTERNAL') THEN
! I WANT K TO POINT TO THE COLUMN FOLLOWING THE 'L'
                  K=I+8
                  XFLAG=.TRUE.
                  CLNPOS=I+7
                  GOTO 10
            END IF
      END DO
      XFLAG=.FALSE.
! NOW I HAVE NO IDEA WHAT TO DO IF PROG HAS NOT ALREAD JUMPED AWAY  !!
! MAYBE RETURN WITH NO CHANGES AT ALL..BUT TRY THIS:
      K=LLEN
10      J=K+1
      NEWLIN(1:K-1)=WRKLIN(1:K-1)
      DO I=K,LLEN
            IF(WRKLIN(I:I).NE.'&') THEN
                  NEWLIN(J:J)=WRKLIN(I:I)
                  J=J+1
            END IF
      END DO
! NOW DELETE AN SPC CODES
      CALL CLRLLIN(WRKLIN)
!      LEN=GETLLEN(NEWLIN)
      K=J-1
      J=7
      WRKLIN(1:6)=NEWLIN(1:6)
      DO I=7,K
         IF(XFLAG.AND.I.LE.16) THEN
            WRKLIN(J:J)=NEWLIN(I:I)
            J=J+1
            GOTO 20
            ELSE
            IF(NEWLIN(I:I).NE.' ') THEN
                  WRKLIN(J:J)=NEWLIN(I:I)
                  J=J+1
            END IF
         END IF
   20          ijklmn=1
           END DO
! IF XFLAG IS TRUE, THEN I WANT TO INSERT A SPC BETWEEN 'EXTERNAL' AND
! THE NEXT CHAR. INTEGER CLNPOS SHOULD BE POINTING TO THE FINAL 'L'
! SO I WANT TO ALL CHARS TO RIGHT BY 1 COLUMN AND THEN INSERT AN SPC
! IN COL CLNPOS+1
      
 1000      RETURN
      END SUBROUTINE RMAMPS
! *********************************************************************
      SUBROUTINE RMVNAM(WRKLIN,ISTART,ISTOP)
! UPOM ENTRY, ISTART SHOULD POINT TO THE COLUMN IN WRKLIN CONTAINING
! THE FIRST CHARACTER OF THE NAME TO BE DELETED, AND ISTOP SHOULD POINT
! TO THE CHARACTER THAT TERMINATES THE NAME (A COMMA OR A SPC CODE)
! THE LENGTH OF THE NAME TO BE REMOVED SHOULD BE EQUAL TO ISTOP-IEND+1
!
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE
!
      CHARACTER(LEN=1450) :: WRKLIN,TMPLIN
      INTEGER(2) :: LLEN
      INTEGER(KIND=2) :: I,I1,I2,I3,ISTART,ISTOP
      NAMLEN=ISTOP-ISTART+1
      LLEN=GETLLEN(WRKLIN)
      CALL CLRLLIN(TMPLIN)
      TMPLIN(1:ISTART-1)=WRKLIN(1:ISTART-1)
      I1=ISTART
      I2=ISTOP
      I3=LLEN-NAMLEN
      DO I=I1,I3
            TMPLIN(I:I)=WRKLIN(I+NAMLEN:I+NAMLEN)
      END DO
      CALL CLRLLIN(WRKLIN)
      LLEN=GETLLEN(TMPLIN)
      WRKLIN(1:LLEN)=TMPLIN(1:LLEN)
!
      END SUBROUTINE RMVNAM
! *********************************************************************
      SUBROUTINE COMMVARS(FNAME,IOUT)
      USE RENCOM
! SEARCH THE MODULESXX.F90 FILE AND BUILD A NEW FILE CONTAINING THE
! NAMES OF ALL VARIABLES FOUNF THEREIN
! INCOMING IOIN SHOULD POINT TO THE MODULES FILE
      INTERFACE
         SUBROUTINE GETL73(PHRASE,NWRK,LEN1)
         CHARACTER(LEN=73)  , INTENT(INOUT) :: PHRASE
         INTEGER(2)  , INTENT(INOUT) :: NWRK
         INTEGER(2)  , INTENT(INOUT) :: LEN1
         END SUBROUTINE
      END INTERFACE
      INTERFACE
         SUBROUTINE CLRTN(NAME)
         CHARACTER(LEN=16) :: NAME
         END SUBROUTINE
      END INTERFACE
!
      CHARACTER(73) :: SLINE
      CHARACTER(16) :: VARNAM
      CHARACTER(LEN=12) :: FNAME
      INTEGER(2) :: J,LEN1,I1,I2,J1
      INTEGER IOUT
!
      OPEN(UNIT=IMODUL,FILE=FNAME,STATUS='OLD',ERR=2000)
      CLOSE(UNIT=IOUT)
      OPEN(UNIT=IOUT,FILE='COMMVARS.TMP',STATUS='UNKNOWN')
   20 READ(IMODUL,'(A73)',END=1000) SLINE
      J=73
      CALL GETL73(SLINE,J,LEN1)
      CALL CLRTN(VARNAM)
      IF (SLINE(22:27).EQ.'  ::  ') THEN
!! 20 Oct 2009: EARLIER THIS MONTH (OR LAST) I MADE A CHANGE SOMEWHERE
!! THAT LED TO LINES LIKE "      INTEGER         ::  A8". THAT NOW CAN 
!! CAUSE LEN1 TO EXCEED THE ASSIGNED LENGTH OF VARNAM BECAUSE ALTHOUGH
!! THE ACTUAL VARNAM STILL ENDS IN COLUMN # LEN1 THE RANGE 1 TO LEN1
!! CAN EXCEED 16 (ALLOWED VARIABLE NAME LENGTH). 
!! I WILL TRY TO GUESS THAT THE CORRECT OF THE LENGHT OF VARNAM IS
!! EQUAL TO LEN1-27.
!! SO, LETS SEE HOW THAT WORKS
!! 
!!         VARNAM(1:LEN1)=SLINE(28:LEN1)
		 J1=LEN1-27
		 VARNAM(1:J1)=SLINE(28:LEN1)
         IF(LEN1.LT.44) THEN
!            I1=LEN1
			I1=J1
            I2=44
   25       J=I1+1
            IF(J.GE.I2) GOTO 27
!
! FOR REASONS i CANNOT UNDERSTAND AT ALL, UNDER G95 COMPILATIONS 
! THE ORIGINAL DO-LOOP DEACTIVATED BELOW ALLOWED J TO REACH VALUES
! LARGER THAN 5000!!
! SO I REPLACED IT WITH A DIFFERENT SCHEME 17 AUG 2009
!
!              DO J=ILEN+1,44
                 VARNAM(J:J)=' '
!              END DO
         END IF
      27   WRITE(IOUT,'(A16)')VARNAM
      END IF
      GOTO 20
 1000 CLOSE(IMODUL)
      CLOSE(IOUT)
      close(27)
      RETURN
!
 2000 WRITE(*,*) 'COMMVARS: CANNOT OPEN THE FILE:',FNAME
      STOP
      END SUBROUTINE COMMVARS
! *********************************************************************
      SUBROUTINE CLRTYP(STRNGN,NAMLEN)
!     PURPOSE IS TO REMOVE ANY NON-SPC CODES AFTER FIRST SPACE
!     SKIP OVER ASSOCIATED CONTINUATION CARDS, IF ANY
!     SKIP ACTUALLY I ALSO WANT TO REMOVE ANY ", INTENT(XXX).. "
!     STRINGS SUCH AS
!      INTEGER(2)  , INTENT(INOUT) :: M
!    
      CHARACTER*80, INTENT(INOUT) :: STRNGN
!         CHARACTER*80 WORKSTR
      CHARACTER :: SPC
      INTEGER(2) :: I,J,NAMLEN
      SPC=' '
! FIND THE FIRST SPC IN STRNG
      DO I=1,NAMLEN              
            IF (STRNGN(I:I).EQ.SPC) THEN
               J=I
               GOTO 10
            END IF
      END DO
! CLEAR ANY CHARACTERS THAT REMAIN IN STRNGN
   10 DO I=J,NAMLEN
         STRNGN(I:I)=SPC
      END DO
      RETURN
      END SUBROUTINE CLRTYP
!
      SUBROUTINE CMVCHK ()
! MAJOR MODS INITIATED 17 JULY 2009; USING NEW ROUTINES FNDVAR, ET AL
! TO CREATE A FILE OF MOST VARIABLE NAMES: "VARNAMES.TMP" (TESTIT.OUT)
!
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
!EZUP BUG->      UNKNOWN, INTENT(INOUT) ::
!
!     SEE IF WE CAN FIND TYPE DECLARATIONS FOR ANY OF THE VARS
!     TYPED AS 'UNKNOWN :: ' IN THE MODULES.OUT (LUN=21) FILE
!
      CHARACTER(LEN=80) :: ORITXT,NEWTXT
!
      CHARACTER(LEN=16) :: VARNAM
      CHARACTER(LEN=17) :: IDSTR1,NSTRNG,TSTRNG,MSTRNG
      CHARACTER(LEN=32) :: TMPNAM,VARTYP,NEWNAM
      INTEGER(2) :: I, J, K, KK, KKK, IDUM
      INTEGER(2) :: L
      integer LUO
!        LOGICAL :: ISAND
      IDSTR1='      UNKNOWN :: '
      MSTRNG='MODULE'
   10 FORMAT (A80)
      11 FORMAT(A32,1X,A32)
  180       FORMAT (72A1)
! TRY TO CATALOG ALL KNOW VARIABLES AND THEIR DATA TYPES
         LUO = 41
      OPEN (UNIT=LUO,FILE='VARNAMES.TMP',STATUS='UNKNOWN')
      CALL FNDVAR(ITMPF,LUO)
!
! BEGIN CYCLING THROUGH THE MODULES.OUT FILE AND EXTRACT VARIABLE
! NAME AS VARNAM
!
      REWIND  ITMOD
      DO I=1,9999
         READ(ITMOD,10,END=215)ORITXT
!            WRITE(98,10)ORITXT
         TSTRNG=ORITXT(7:12)
         IF(TSTRNG.EQ.MSTRNG)THEN
!
!     SEE IF THIS MODULE HAS ALREADY BEEN REVIEW FOR TYPE DECLS
!        WHERE IS THIS MODULE IN THE NMODS() ARRAY ?
      TSTRNG=ORITXT(14:19)
      DO KKK=1,NUMMOD
         IF(TSTRNG.EQ.NMODS(KKK))THEN
            IF(CMCHKD(KKK))THEN
               RETURN
            ELSE
!     SET FLAG TO PREVENT ANOTHER SET OF WRITES TO 'IMODUL'
               CMCHKD(KKK)=.TRUE.
               GO TO 30
            END IF
         END IF
      END DO
         END IF
   30    NSTRNG=ORITXT(1:17)
         IF(NSTRNG.NE.IDSTR1)THEN
            IDUM=80
      CALL GETLEN (ORITXT,IDUM,ICLEN)
      WRITE (IMODUL,180) (ORITXT(KK:KK),KK=1,ICLEN)
      GO TO 190
         END IF
         VARNAM=ORITXT(18:33)
! ITMPF <--> FILE "REVISED.TMP'
! AT THIS POINT VARNAM IS PRESUMABLY THE NAME OF A VARIABLE THAT WAS
! PREVIOUSLY TAGGED WITH 'UNKNOWN' DATA TYPE IN THE MODULES00 FILE.
!
         REWIND  LUO
!
! NOW I WANT TO SEE IF THE VARIABLE REPRESENTED IN VARNAM IS KNOWN TO
! THE FILE CREATED BY FNDVARS, ET AL. HOWEVER, AS OF JULY 2009, THE
! VARS FOUND IN FILE SCRATCH2.TMP (FIRST DRAFT OF MODULESXX.OUT) DO NOT
! CONTAIN ANY DIMENSIONAL INFO WHEREAS THOSE IN TESTIT.OUT (FROM
! FNDVARS MAY CONTAIN SUCH INFO. THEREFORE I WILL NEED TO TRUNCATE
! NAMES IN TESTIT.OUT FOR COMPARISONS
         DO J=1,10000
!      READ(LUO,11,END=210)NEWNAM,VARTYP
      READ(LUO,11,END=190)NEWNAM,VARTYP
!            WRITE(97,11)NEWNAM,VARTYP
! REMOVE ANY DIMENSIONAL INFO
!
            TMPNAM(1:16)=NEWNAM(1:16)
            DO K=1,16
                  IF (TMPNAM(K:K).EQ.'(') THEN
                  DO      L=K,16
                        TMPNAM(L:L)=' '
                  END DO
                  GOTO 35
                  END IF
            END DO
   35      IF(TMPNAM(1:16).EQ.VARNAM) THEN
!
! REPLACE THE 'UNKNOWN' PHRASE BY VARTYP, WATCH FOR LENGTH CHANGES!!!
! NOTE THAT THE DOUBLE COLON WILL NOT APPEAR IN VARTYP SO THAT I WILL
! NEED TO TACK IT ONTO THE FRONT OF THE VARIABLE NAME
! USE      'NEWTXT' AS THE NEW LINE TO BE CONSTRUCTED
!
                  NEWTXT(1:6)='      '
                  NEWTXT(7:23)=VARTYP
                  NEWTXT(23:27)= ' :: '
                  NEWTXT(28:60)=NEWNAM
                  WRITE(IMODUL,'(A60)') NEWTXT
                  GOTO 190
            ELSE
            END IF
   80       IJKLMN=1
         END DO
! I THINK THAT I AM THROUGH WITH THIS VARIABLE NAME
      GO TO 210
!
  190    IJKLMN=1
         END DO
!     IF WE EXIT FROM LOOP OVER SOURCE FILE WITHOUT A BRANCH
!     FOR HANDLING THE CURRENT LINE FROM MODULES.OUT IT PROBABLY
!     MEANS THAT WE DID NOT FIND ANY "TYPED" VARIABLE WHOSE
!     NAME MATCHED VARNAM FROM THE MODULE, 'THO THAT NEVER ACTUALLY
!     SEEMS TO HAPPEN.
!     IN THAT CASE, OR IF I REACH EOF ON THE SOURCE FILE, THEN
!     JUST PASS PASS THE LINE FROM "MODULES.OUT"  AS IT STANDS
!

!!## 12-9-1998 HERE IS ONE PLACE WHERE I NEED TO "RESQUEEZE"
!! LINE LENGTH TO REMOVE TRAILING BLANKS FROM MANY VARIABLES
!! BEFORE CALLING GETLEN AND DOING THE WRITE!
!!
! NEXT MOVED INSIDE LOOP 6-24
  210 MYCDEF=0
!
  215 MYCDEF=1
  220 CLOSE(LUO)
      CLOSE(97)            
      CLOSE(98)
!
      RETURN
      END SUBROUTINE CMVCHK
! *********************************************************************
      SUBROUTINE FNDVAR(LUIN,LUOUT)
      IMPLICIT NONE
! THIS IS A DRIVER PROGRAM FOR ATTEMPTING TO CATALOG ALL
! VARIABLE NAMES AND THEIR DATA TYPES THAT I CAN FIND WITHIN
! A SINGLE SOURCE CODE FILE.
! FOR EZUP USE THE INPUT FILE IS EXPECTED TO BE THE FILE "REVISED.TMP".
!
      CHARACTER(LEN=4) :: DWDS(6)
         CHARACTER(LEN=73) :: OLDTXT
      CHARACTER(LEN=1450) :: WRKLIN
         CHARACTER(LEN=32) :: VARINF(256),TMPSTR,VARTYP,EMPTY
      INTEGER(KIND=2) :: NV,I,DUM1,NVARS,LLEN
      INTEGER(kind=2) :: CLNPOS,idum
      integer LUIN,LUOUT
         CHARACTER SPC
      DWDS(1)='INTE'
      DWDS(2)='REAL'
      DWDS(3)='LOGI'
      DWDS(4)='COMP'
      DWDS(5)='CHAR'
      DWDS(6)='DOUB'
      NVARS=0
!
      1  FORMAT(32A1,3X,A32,3X,I5)
      REWIND LUIN
         DO I=1,256
         IF (I.LT.33) EMPTY(I:I)=' '
            VARINF(I)=' '
         END DO
         VARTYP=''
         SPC=' '
    5 READ(LUIN,'(73A)',ERR=1000,END=1000)OLDTXT
! SKIP COMMENT CARDS
         IF(OLDTXT(1:1).EQ.'!') GOTO 5
      CALL CLRLLIN(WRKLIN)
      IDUM=73
         CALL GETLEN(OLDTXT,IDUM,LLEN)
      IF(OLDTXT(73:73).EQ.'&') THEN
            CALL READCC(OLDTXT,WRKLIN,LLEN,LUIN)
      ELSE
            WRKLIN(1:LLEN)=OLDTXT(1:LLEN)
      END IF
!      CALL PAKLIN(WRKLIN)
!
            DO I=1,6
                  IF(WRKLIN(7:10).EQ.DWDS(I)) THEN
                  GOTO 7
               END IF
      END DO
      GOTO 5
!
! THE ABOVE LOOP TESTS FOR DATA TYPE DECLARATIONS ONLY
! BUT I MAY NEED TO PAY ATTENTION TO THE BEGINNINGS AND ENDS OF
! SUBROUTINES AND FUNCTIONS SINCE IT IS LIELY THAT SOME VARIABLE
! NAMES WILL APPEAR IN MORE THAN ONE ROUTINE. EXAMPLES ARE THE
! LETTERS I, J, K. FRANKLY, I DON'T SEE A STRAIGHTFORWARD WAY OF
! DEALING WITH MULTIPLE DATA TYPES FOR ONE VARIABLE NAME!
! MAYBE I WILL BE LUCKY SINCE WE ARE TRYING TO FIX UP DATA TYPES
! IN THE MODULESXX.F90 FILE AND MAYBE DUPLICATE NAMES WILL NOT
! BE ALLOWED BY COMPILERS.....
!
    7 DUM1=1
      CALL PAKDW(WRKLIN,LLEN,CLNPOS)
   20 CALL VNSRCH(WRKLIN,VARINF,VARTYP,NV)
         IF(NV.EQ.0) THEN 
            GOTO 5
      END IF
      idum=32
      CALL CLRTYP(VARTYP,idum)
      IF (NV.GT.256)NV=256
         DO I=1,NV
            TMPSTR=VARINF(I)
            IF (TMPSTR.NE.EMPTY) THEN
            NVARS=NVARS+1
            WRITE(LUOUT,1001)VARINF(I),VARTYP
            END IF
      END DO
         GOTO 5
!
! 1000 STOP
 1000 RETURN
 1001 FORMAT(A32,1X,A32)      
 !      END SUBROUTINE FNDVAR
      END SUBROUTINE FNDVAR
! *********************************************************************
         SUBROUTINE VNSRCH(TESTR,VARINF,VARTYP,NVARS)
!
! TRY TO EXTRACT DATA TYPES FOR ALL VARIABLES
! TEST A LINE FOR VARIABLE NAMES, DIMENSIONS, DATA TYPES
!       TESTR IS LINE OF TEXT TO BE CHECKED
!       VARINF IS AN ARRAY OF VARIABLE NAMES FOUND; TO BE RETURNED
!  TO THE CALLING ROUTINE, INCLUDING ANY DIMENSIONS
!       VARTYP IS STRING REP OF DATA TYPE FOR THE VARIABLE
!       NVARS IS THE NUMBER OF VARIABLE NAMES FOUND IN THE CURRENT
!  CALL TO THIS ROUTINE. SUCH A CALL WILL READ ALL DETECTED
!  CONTINUATION CARDS ASSOCIATED WITH A SINGLE DATA TYPE
!  DECLARATION. THE MAXIMUM ALLOWED VALUE IS 256
         USE RENCOM
         IMPLICIT NONE
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE
!
      CHARACTER(LEN=1450) :: TESTR
         CHARACTER(LEN=32) :: VARINF(256),VARTYP
         CHARACTER(LEN=1450) :: WORKSTR
         CHARACTER(LEN=32) :: SPTST,TBLANK
         CHARACTER(LEN=1) :: RP,LP
!         CHARACTER(LEN=4) :: TEMPO
         CHARACTER(LEN=1) :: INP,SPC
         INTEGER(KIND=2) :: I,L,L1,M,N, NVARS
!         INTEGER(KIND=2) :: DUM1,DUM2,LASTPO,ILPRN
      INTEGER(KIND=2) :: IBEGIN,IEND,ILP,IRP
         INTEGER(kind=2) :: LEN
         LOGICAL IFLAG,JFLAG 
!        IPRN WILL POINT TO POS OF CLOSING PARENTHESIS OF DIM DEFNS
!    ICOMMA SHOULD BE SET TO POINT TO THE POSITION OF A COMMA BETWEEN
!    VARIABLE NAMES
!
         RP='('
         LP=')'
         SPC=' '
         NVARS=0
         IFLAG=.FALSE.
         JFLAG=IFLAG
         TBLANK='          '
         WORKSTR=' '
         SPTST=TBLANK
      VARTYP=TBLANK
! THE CALLER WOULD ALSO NEED TO NOTE BEGINNINGS AND END OF SUBROUTINES IN THE
! FILE BEING TESTED.
!
! -- STANDARD SEARCH FOR VARIABLE NAMES BEGINS HERE ---------------------------
! LOOK FOR DATA TYPE STATEMENTS; PRESUME ALL VARS IN A LINE
! AND ANY OF ITS CONTINUATION CARDS HAVE THE SAME DATA TYPE
!
!  14  DTYP=-1
! THE FIRST THING I WANT TO DO IS LOOK FOR THE "::" COMBO SO I CAN START
! THE SEARCH FOR VARIABLE NAMESTO THE RIGHT OF THAT IN THE TESTR
! SET L1 TO POINT TO THE SECOND COLON, AND BEGIN VARNAME SEARCHES @ L1+1
            DO L=7,1449
            INP=TESTR(L:L)
            IF (TESTR(L:L+1).EQ.'::') THEN 
                  L1=L+1
                  IBEGIN=L1+1
                  GOTO 5
! AND THE NUMBER OF CHARACTERS TO SEARCH IS  THEN THE LENGTH OF TESTR                  
! MINUS THE VALUE OF L1
            END IF
              END DO
! REMOVE ANY SPC CODES TO THE RIGHT OF THE :: PAIR
    5      M=L1
      CALL CLRLLIN(WORKSTR)
      WORKSTR(1:L1)=TESTR(1:L1)
      DO L=L1+1,1450
            IF (TESTR(L:L).NE.SPC) THEN
                  M=M+1
                  N=L
                  WORKSTR(M:M)=TESTR(L:L)
            END IF
      END DO
! NOW, BACKUP AND INSERT ONE SPACE AFTER THE DOUBLOE COLON
! I AM NOW GOING TO COPY THE COMPACTED STRING BACK INTO TESTR
!        DO M=1450,L1+2,-1
!            WORKSTR(M:M)=WORKSTR(M-1:M-1)
!      END DO
!      WORKSTR(L1+1:L1+1)=' '
!
      CALL CLRLLIN(TESTR)
      LEN=GETLLEN(WORKSTR)
      TESTR(1:LEN)=WORKSTR(1:LEN)
! I SUPPOSE THAT THIS IS A GOOD PLACE TO TRY TO EXTRACT THE DATA TYPE
! I SLSO GUESS THAT I WANT TO IGNORE ", INOUT(" PHRASES
      DO I=7,L1-2
            INP=TESTR(I:I)
            IF (TESTR(I:I+6).EQ.'INTENT(') THEN
                  M=I-1
! THERE OUGHT TO BE A COMMA NETWEEN I AND END OF ACTUAL NAME. TRY TO FIND IT
! IF I SEARCH TO LEFT FROM I AND DO NOT FIND A COMMA THEN THERE IS SOME ERROR
                  DO L=1,M
                        IF (TESTR(L:L).EQ.',') THEN
! ASSUME THAT THE END OF THE VARNAM IS IN COL L-1
                              M=L-1
                              GOTO 10
                        END IF
                  END DO
                  GOTO 10
            ELSE
                  M=L1-2
            END IF
      END DO
   10 N=0      
      VARTYP=TESTR(7:M)
! NOW I WANT TO ACTUALLY SEARCH FOR ONE OR MORE VARIABLE NAMES, 
! BEGINNING AT POSITION L1+1. L1  WILL BE ADJUSTED IF MULTIPLE VARNAMES
! ARE FOUND. NEXT LINE IS THE "BEGIN SEARCH FOR NEXT VARNAME" POINT
! ---------------------------------------------------------------------
!         STEP 1
! --------------------------------------------------------------------
15      ILP=0
      IRP=0
! VARNAME PRESUMABLE BEGINS IN COLUMN IBEGIN
! DOES TESTR CONTAIN A ( BEYOND COLUMN IBEGIN
      DO L=IBEGIN,LEN
            IF(TESTR(L:L).EQ.RP) THEN
! I HAVE VARNAME OF AN ARRAY
                  IRP=L
! EXPECT A ) TO TERMINATE VARNAM. FIND IT
                  DO I=IRP,LEN
                        IF (TESTR(I:I).EQ.LP) THEN
                              ILP=I
                              IEND=I
                              GOTO 40
                        END IF
                  END DO
! THERE IS AN UNMATCHED PARENTHESIS SOMEWHERE IN TESTR
                  WRITE(*,*)'ERROR ENCOUNTERED! THERE IS NO CLOSING PAR&
        &ENTHESIS IN LIN      E BEGINNING WITH: '
                        WRITE(*,*) TESTR(1:72)
                              RETURN
            END IF
      END DO
! ---------------------------------------------------------------------
! BEGIN STEP 2;SEARCHING FOR NON-ARRAY VAR NAMES, COMMA OR SPC IS END+1
! ---------------------------------------------------------------------      
        30      DO L=IBEGIN,LEN
            IEND=L
            INP=TESTR(L:L)
            IF(INP.EQ.SPC.OR.INP.EQ.',') THEN
                  IEND=L-1
                  GOTO 40
            END IF
!            IF(M.GE.LEN) THEN
!                  WRITE(*,*)'END OF VARIABLE NAME NOT FOUND IN LINE:'
!                  WRITE(*,*)TESTR
!                  RETURN
!            END IF
      END DO
! ---------------------------------------------------------------------
!  STEP 3: SAVE
! ---------------------------------------------------------------------
   40      NVARS=NVARS+1
      VARINF(NVARS)=TESTR(IBEGIN:IEND)
! ARE THERE ANY MORE VARIABLES IN THE LINE? IF VARNAM ENDED AT A COMMA
! THEN THE ANSWER IS YES, AND I NEED TO RESET IBEGIN AND RETURN TO STEP1
      IF (TESTR(IEND+1:IEND+1).EQ.',') THEN
            IBEGIN=IEND+2
            GOTO 15
      ELSE 
            RETURN
      END IF
! NEXT LINE SHOULD NEVER BE REACHED
      WRITE(*,*)' ** SOMETHING IS REALLY WRONG **'
         END SUBROUTINE VNSRCH
! *********************************************************************
      SUBROUTINE PAKDW(WRKLIN,LLEN,CLNPOS)
! PACK TYPE DECLARATION STATEMENTS IN COLUMNS BEYOND ":: "
! RETURN PACKED LENGTH AS  LLEN AND **BEGINNING** OF VAR NAMES AS
! CLNPOS
      CHARACTER(LEN=1450) :: WRKLIN,TMPLIN
      INTEGER(kind=2) :: LLEN,CLNPOS,I,J,K,INLEN
! ALL VALID DATA TYPE DECLARATION STMTS SHOUKD CONTAIN THE ":: " STRING
      DO I=1,1450
            TMPLIN(I:I)=' '
      END DO
      INLEN=LLEN
      DO I=7,INLEN-2
            IF(WRKLIN(I:I+1).EQ.'::') THEN
                  CLNPOS=I+3
                  TMPLIN(1:CLNPOS-1)=WRKLIN(1:CLNPOS-1)
                  K=CLNPOS-1
                  DO J=CLNPOS,INLEN
                        IF(WRKLIN(J:J).NE.' ') THEN
                              K=K+1
                              TMPLIN(K:K)=WRKLIN(J:J)
                        END IF
                  END DO
!                  CLNPOS=K
                  LLEN=K
                  CALL CLRLLIN(WRKLIN)
                  WRKLIN(1:LLEN)=TMPLIN(1:LLEN)
                  GOTO 1000
            END IF 
      END DO
 1000      RETURN      
      END SUBROUTINE PAKDW
! *********************************************************************
      SUBROUTINE PCOMMN (CMNNAM,NFLAG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: MYCDEF
      CHARACTER(LEN=16)  , INTENT(INOUT) :: CMNNAM
      INTEGER(2), INTENT(INOUT) :: NFLAG
!    COMMON BLOCK PROCESSOR, CALLED BY SUBROUTINE 'PRE'
!    UPON ENTRY, CLINE() SHOULD CONTAIN DATA FROM ANY ORIGINAL
!    CONTINUATION CARDS AND OUGHT TO HAVE "COMMON" IN CLINE(8)-
!    CLINE(13) [OR ALINE(7)-ALINE(12)], BUT NO COMPRESSION WILL
!    HAVE BEEN DONE.
!    RETURNS NFLAG = 0 (UN-NAMED COMMON BLOCK)
!            >=1 (NO OF CHARS IN NAME OF BLOCK)
!
      CHARACTER(LEN=1) :: ALINE(1450)
      INTEGER(2) :: I,IK, NNAMED, ICN1, ICN2, J,id1,id2
!    REMOVE ALL SPACE CODES
      CMNNAM='          '
      IK=6
      NNAMED=0
      ICN1=0
      ICN2=0
      DO I=1,6
      ALINE(I)=CLINE(I+1)
      END DO
      DO I=8,ICLEN
         IF(ICHAR(CLINE(I)).EQ.255)GO TO  20
         IF(CLINE(I).NE.' ')THEN
      IK=IK+1
      ALINE(IK)=CLINE(I)
      IF(ALINE(IK).EQ.'/'.AND.ICN1.EQ.0)THEN
         ICN1=IK
      END IF
      IF(ALINE(IK).EQ.'/')THEN
         IF(IK.GT.ICN1)THEN
            ICN2=IK
         END IF
      END IF
         END IF
! NEXT LINE MANUALLY MOVED INSIDE DO-LOOP 6-20-97
   20 MYCDEF=0
      END DO
!    ALINE SHOULD NOW CONTAIN NO SPACE CODES AND NEW LENGTH IS
!    IK
!
!    REWRITE CLINE AS COMPRESSED ABOVE, NOTING THAT THE 0XFF CODES
!    USED AS SPACE-CODE HOLDERS HAVE NOW BEEN DELETED!!
      DO I=1,1450
         CLINE(I)=' '
      END DO
      DO I=1,IK
      CLINE(I+1)=ALINE(I)
      END DO
!    SEE IF WE HAVE A "NAMED" COMMON BLOCK
      IF(ICN2.GT.ICN1)THEN
         NNAMED=1
         ICN1=ICN1+1
         ICN2=ICN2-1
         DO J=ICN1,ICN2
         CMNNAM(J+1-ICN1:J+1-ICN1)=ALINE(J)
         END DO
      ELSE
         NNAMED=0
      END IF
!
! THERE IS AT LEAST ONE MORE PROBLEM: IF WE DO NOT HAVE A
! "NAMED" COMMON BLOCK, WE NEED TO REINSERT A PROTECTED-SPC
! CODE AFTER THE WORD "COMMON", IE IN COLUMN 13
!
      ICLEN=IK+1
      IF(NNAMED.EQ.0)THEN
            id1=14
            id2=1
         CALL MVRT (id1,id2)
         CLINE(14)=' '
         NFLAG=0
      ELSE
         NFLAG=ICN2-ICN1+1
!     MOVE THE /NAMESS/ TO RIGHT
            id1=14
            id2=1
         CALL MVRT (id1,id2)
         CLINE(14)=' '
            id1=icn2+4
            id2=1
         CALL MVRT (id1,id2)
         CLINE(ICN2+4)=' '
      END IF
!
      RETURN
      END SUBROUTINE PCOMMN
! *********************************************************************
      SUBROUTINE MKCMBK (CMNNAM,NFLAG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN
      !##
      CHARACTER(LEN=16)  , INTENT(INOUT) :: CMNNAM
      INTEGER(2), INTENT(INOUT) :: NFLAG
      CHARACTER(LEN=79) :: TRASH
      CHARACTER(LEN=79) :: MISC
      CHARACTER(LEN=16) :: CMVLST(100),WRKNAM
      CHARACTER(LEN=1) :: EXCLAM
      INTEGER(2) :: I, J,  K, JJ, ILEN, NTOP, NVARS, IDUM
      EXCLAM= '!'
   10 FORMAT(79A1)
!
!
! OUTPUT TO TEMPORARY FILE LUN=ITMPF
! PRIOR TO MAY 11 (LATE AFTERNOON) THERE WAS A
!     REWIND ITMOD
! STATEMENT HERE. THAT WAS WIPING OUT INFO IN THE
! FINAL MODULES FILE, SO I DELETED IT FROM HERE AND
! MOVED IT TO MAIN PGM WHERE WE RECYCLE OVER PROGRAM
! UNITS WITHIN THE IOIN FILE.
!
! BUT, NOW I AM GETTING SAME MODULE NAMES MORE THAN ONCE!
! WHAT NEXT ????
!
      TRASH='      MODULE '
      IF(NFLAG.EQ.0)THEN
         TRASH(14:19)='DEFALT'
         WRKNAM='DEFALT'
         CMNNAM=WRKNAM
      ELSE
         WRKNAM='      '
         DO J=1,NFLAG
      TRASH(13+J:13+J)=CMNNAM(J:J)
      WRKNAM(J:J)=CMNNAM(J:J)
         END DO
      END IF
!
!## ?? ON *6 -> *16 : 12/2/1998
! ADD MODULE IDENTIFIER TO LIST 'NMODS*16(100)'
! IF IT IS NOT ALREADY THERE
      IF(NUMMOD.EQ.0)THEN
         NMODS(1)=WRKNAM
         NUMMOD=1
      ELSE
         NTOP=NUMMOD
         DO K=1,NTOP
!     ADD A MODULE NAME & INFO ONLY ONCE!
!        CHECK TO SEE IF THIS MODULE NAME HAS ALREADY BEEN USED:
      IF(NMODS(K).EQ.WRKNAM)GO TO  80
         END DO
         NUMMOD=NUMMOD+1
         NMODS(NUMMOD)=WRKNAM
! INSERT AN EMPTY COMMENT-LINE BETWEEN MODULES
!         WRITE (ITMOD,*) "!"
         WRITE(ITMOD,10)EXCLAM
         GO TO 40
      END IF
   40 IJKLMN=1
!
      IDUM=79
      CALL GETLEN(TRASH,IDUM,ILEN)
      WRITE (ITMOD,10) (TRASH(JJ:JJ),JJ=1,ILEN)
      MISC='      IMPLICIT NONE'
!      WRITE (ITMOD,*) '      IMPLICIT NONE'
      ILEN=19
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!     MAKE A LIST OF VARIABLES FOUND IN CLINE
      CALL CMVARS (CMVLST,NVARS,NFLAG)
      IF(NVARS.EQ.0)THEN
         WRITE (*,*) 'ERROR IN CMVARS!!! NO VARS FOUND!'
         GO TO 70
      END IF
!
      MISC='! THE FOLLOWING VARIABLES WERE DETECTED. IT IS YOUR'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!
      MISC='! JOB TO BE SURE THAT THE ''UNKNOWN'' TYPE DECLARATIONS ARE'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!
      MISC='! PROPERLY REVISED TO REFLECT CORRECT INFORMATION.'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!
      MISC='! ** NOTE : YOU MAY NEED TO DELETE SOME TYPE-DECLARATIONS FR&
     &OM'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!
      MISC='! YOUR SOURCE FILE BECAUSE SOME MAY HAVE BEEN COPIED INTO TH&
     &E'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!
      MISC='! MODULES.OUT FILE.'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!
      WRITE (ITMOD,10) EXCLAM(1:1)
!
      DO I=1,NVARS
         TRASH='      UNKNOWN :: '
!## 18:23 -> 18:33
         TRASH(18:33)=CMVLST(I)
         CALL GETLEN(TRASH,IDUM,ILEN)
         WRITE(ITMOD,10)( TRASH(JJ:JJ), JJ=1,ILEN)
!         WRITE (ITMOD,*) TRASH
      END DO
      MISC='! END LIST OF DETECTED COMMON BLOCK VARS.'
      CALL GETLEN(MISC,IDUM,ILEN)
      WRITE(ITMOD,10)( MISC(JJ:JJ), JJ=1,ILEN)
!      WRITE (ITMOD,*) '! END LIST OF DETECTED COMMON BLOCK VARS.'
!
      TRASH='      END MODULE '
      IF(NFLAG.EQ.0)THEN
         TRASH(18:23)='DEFALT'
      ELSE
         DO J=1,NFLAG
         TRASH(17+J:17+J)=CMNNAM(J:J)
         END DO
      END IF
!   60 WRITE (ITMOD,*) TRASH
   70 CALL GETLEN(TRASH,IDUM,ILEN)
      WRITE(ITMOD,10)(TRASH(JJ:JJ),JJ=1,ILEN)
!
   80 RETURN
      END SUBROUTINE MKCMBK
! *********************************************************************
      SUBROUTINE CMVARS (CMVLST,NVARS,NFLAG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
      CHARACTER(LEN=16)  , INTENT(INOUT) :: CMVLST(100)
      INTEGER(2), INTENT(INOUT) :: NVARS, NFLAG
!
!     PURPOSE IS TO PARSE CLINE FOR COMMONBLOCK CASES AND RETURN
!     A LIST OF VARIABLE NAMES FOUND TO RIGHT OF COLUMN 13 OR RIGHT MOST
!     COLUMN CONTAINING A "/"
!
!## TWO CHANGES 6-> 16 12/2/98
      CHARACTER(LEN=16) :: WRKNAM
      CHARACTER(LEN=1) :: COMMA
      CHARACTER(LEN=16) :: NONAME
      INTEGER(2) :: I, ISTRT, J, K, NCHRS
!* WARNING: CANNOT CONVERT "DATA" STATEMENTS
      COMMA=','
      NONAME='      '
! INITIALIZE VARLST
      DO I=1,100
         CMVLST(I)=NONAME
      END DO
      NVARS=0
!
      IF(NFLAG.EQ.0)THEN
         ISTRT=14
      ELSE
!     ALLOWING FOR SPC/NAME/SPC,
!     WITH FIRST SPC IN COLUMN 14(REMEMBER OFFSET BY 1 COL)
         ISTRT=15+NFLAG+2
      END IF
   20 IJKLMN=1
      J=0
      DO I=ISTRT,ICLEN
         K=I
         IF(ICHAR(CLINE(I)).EQ.255)GO TO  30
         IF(CLINE(I).EQ.' ')GO TO  30
         IF(CLINE(I).EQ.COMMA)GO TO  40
         J=J+1
         WRKNAM(J:J)=CLINE(I)
   30    MYCDEF=0
      END DO
! NEXT LINE MANUALLY MOVED INSIDE DO-LOOP 6-20-97
!     HAVE WE REACHED THE END OF CLINE ???
      IF(K.EQ.ICLEN.AND.J.EQ.0)GO TO  80
   40 NCHRS=J
      IF(J.LT.16)THEN
         DO J=NCHRS+1,16
         WRKNAM(J:J)=' '
         END DO
      END IF
      ISTRT=K+1
!     ADD TO CMVLST
      DO I=1,100
         IF(CMVLST(I).NE.NONAME)GO TO  60
         CMVLST(I)=WRKNAM
         NVARS=NVARS+1
!     GET OUT OF VAR-NAME HUNTING LOOP
         GO TO 70
! NEXT LINE MANUALLY MOVED INSIDE DO-LOOP 6-20-97
   60    MYCDEF=0
      END DO
!     RECYCLE
   70 GO TO 20
   80 RETURN
      END SUBROUTINE CMVARS
! *********************************************************************
      SUBROUTINE JLEFT(ATEST,LENGTH)
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN
      CHARACTER(LEN=127)  , INTENT(INOUT) :: ATEST
      INTEGER, INTENT(INOUT) :: LENGTH
!
! LEFT JUSTIFY ATEST
!
! MS FORTRAN 5.1 WILL NOT ACCEPT NEXT STATMENT.
! IT DEMANDS ACTUAL NUMERICAL VALUE AS LENGTH
!      CHARACTER*(LENGTH) ATEST
! SO USE GENERIC LENGTH; LENGTH OF CALLER'S ATEST MUST NOT EXCEED 127!
!
      INTEGER(2) :: ITOP,M3
   10 IF(ATEST(1:1).NE.' ')GO TO  30
      ITOP=LENGTH-1
      DO M3=1,ITOP
         ATEST(M3:M3)=ATEST(M3+1:M3+1)
      END DO
!     NOW REPLACE RIGHT-MOST ENTRY WITH A SPACE CODE
      ATEST(LENGTH:LENGTH)=' '
      GO TO 10
!
   30 RETURN
      END SUBROUTINE JLEFT
! *********************************************************************
      SUBROUTINE SBVARS (ISTRT,NRTYPE)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN,MYCDEF
      INTEGER(2), INTENT(INOUT) :: ISTRT, NRTYPE
!
!     PURPOSE IS TO PARSE CLINE FOR SUBR/FUNC CASES AND RETURN
!     A LIST (PRMLST) OF PARAMETERS
!     ON ENTRY, ISTART SHOULD IDENFIFY COL CONTAINING FIRST LPAREN IN
!                CLINE
!     RETURNS PRMLST VIA COMMON /REN/ (SEE EZUP.IN)
!               NPRMS  = NUMBER OF VALID PARAMETERS
!       NRTYPE = TYPE OF ROUTINE
!                0 MEANS NOT A SUBROUTINE OR FUNCTION, OR ELSE
!            THERE WERE NO PARAMETERS
!                1 MEANS SUBROUTINE      KEYWDS(24)
!                2 MEANS FUNCTION        ALA KEYWDS(12)
!
!##
      CHARACTER(LEN=16) :: WRKNAM
      CHARACTER(LEN=1) :: COMMA
      CHARACTER(LEN=1) :: LPAREN
      CHARACTER(LEN=1) :: RPAREN
      CHARACTER(LEN=16) :: NONAME
      CHARACTER(LEN=4) :: TWD
      INTEGER(2) :: I,J,K,NCHRS, NPRNS
      COMMA  = ','
      NONAME = '          '
      LPAREN = '('
      RPAREN = ')'
! INITIALIZE SPBLST
      DO I=1,25
      PRMLST(I)=NONAME
      END DO
      NPRMS=0
!     FIND TYPE OF ROUTINE
      DO I=1,4
      TWD(I:I)=CLINE(6+I)
      END DO
      IF(TWD.EQ.KEYWDS(12))NRTYPE=2
      IF(TWD.EQ.KEYWDS(24))NRTYPE=1
!
!
!     ALLOWING FOR SPC/NAME/SPC
! COLUMN ISTRT+1 SHOULD CONTAIN LPAREN IF THERE ARE PARAMERERS
      IF(CLINE(ISTRT).NE.LPAREN)THEN
         NRTYPE=0
         NPRMS=0
         RETURN
      END IF
!     SEARCH FOR PARAM NAMES, SKIP THE LPAREN
      ISTRT=ISTRT+1
   30 IJKLMN=1
      J=0
      NPRNS=1
      DO I=ISTRT,ICLEN
         K=I
         IF(ICHAR(CLINE(I)).EQ.255)GO TO  40
         IF(CLINE(I).EQ.' ')GO TO  40
         IF(CLINE(I).EQ.COMMA)GO TO  50
         IF(CLINE(I).EQ.LPAREN)NPRNS=NPRNS+1
         IF(CLINE(I).EQ.RPAREN)THEN
      NPRNS=NPRNS-1
      IF(NPRNS.EQ.0)GO TO  50
         END IF
         J=J+1
         WRKNAM(J:J)=CLINE(I)
!NEXT MOVED INSIDE MANUALLY 6-21-97
   40 MYCDEF=0
      END DO
!     HAVE WE REACHED THE END OF CLINE ???
      IF(K.EQ.ICLEN.AND.J.EQ.0)GO TO  90
   50 NCHRS=J
!## TWO CHANGES: 12/2/98
      IF(J.LT.16)THEN
         DO J=NCHRS+1,16
         WRKNAM(J:J)=' '
         END DO
      END IF
      ISTRT=K+1
!     ADD TO PRMLST
      DO I=1,25
         IF(PRMLST(I).NE.NONAME)GO TO  70
         PRMLST(I)=WRKNAM
         NPRMS=NPRMS+1
!     GET OUT OF VAR-NAME HUNTING LOOP
         GO TO 80
!NEXT MOVED MANUALLY TO INTEROR OF LOOP
   70 MYCDEF=0
      END DO
!     RECYCLE
   80 IF(NPRNS.NE.0)GO TO  30
   90 RETURN
      END SUBROUTINE SBVARS
! *********************************************************************
      SUBROUTINE PSBFN (SBNAM,NFLAG)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) ::  MYCDEF
!## 12/2/98
      CHARACTER(LEN=16)  , INTENT(INOUT) :: SBNAM
      INTEGER, INTENT(INOUT) :: NFLAG
!    COMMON BLOCK PROCESSOR, CALLED BY SUBROUTINE 'PRE'
!    UPON ENTRY, CLINE() SHOULD CONTAIN DATA FROM ANY ORIGINAL
!    CONTINUATION CARDS AND OUGHT TO HAVE "COMMON" IN CLINE(8)-
!    CLINE(13) [OR ALINE(7)-ALINE(12)], BUT NO COMPRESSION WILL
!    HAVE BEEN DONE.
!    RETURNS NFLAG = 0 (UN-NAMED COMMON BLOCK)
!            >=1 (NO OF CHARS IN NAME OF BLOCK)
      CHARACTER(LEN=1) :: ALINE(1450)
!      CHARACTER(LEN=6) :: SBNAM
      INTEGER(2) :: I, IK,J, NNAMED, ICN1, ICN2,id1,id2
!
!    REMOVE ALL SPACE CODES
      SBNAM='      '
      IK=6
      NNAMED=0
      ICN1=0
      ICN2=0
      DO I=1,6
      ALINE(I)=CLINE(I+1)
      END DO
      DO I=8,ICLEN
         IF(ICHAR(CLINE(I)).EQ.255)GO TO  20
         IF(CLINE(I).NE.' ')THEN
      IK=IK+1
      ALINE(IK)=CLINE(I)
      IF(ALINE(IK).EQ.'/'.AND.ICN1.EQ.0)THEN
         ICN1=IK
      END IF
      IF(ALINE(IK).EQ.'/')THEN
         IF(IK.GT.ICN1)THEN
            ICN2=IK
         END IF
      END IF
         END IF
!NEXT MANUALLY MOVED INSIDE 6-21-97
   20 MYCDEF=0
      END DO
!    ALINE SHOULD NOW CONTAIN NO SPACE CODES AND NEW LENGTH IS
!    IK
!
!    REWRITE CLINE AS COMPRESSED ABOVE, NOTING THAT THE 0XFF CODES
!    USED AS SPACE-CODE HOLDERS HAVE NOW BEEN DELETED!!
      DO I=1,1450
      CLINE(I)=' '
      END DO
      DO I=1,IK
      CLINE(I+1)=ALINE(I)
      END DO
!    SEE IF WE HAVE A "NAMED" COMMON BLOCK
      IF(ICN2.GT.ICN1)THEN
         NNAMED=1
         ICN1=ICN1+1
         ICN2=ICN2-1
         DO J=ICN1,ICN2
         SBNAM(J+1-ICN1:J+1-ICN1)=ALINE(J)
         END DO
      ELSE
         NNAMED=0
      END IF
!
! THERE IS AT LEAST ONE MORE PROBLEM: IF WE DO NOT HAVE A
! "NAMED" COMMON BLOCK, WE NEED TO REINSERT A PROTECTED-SPC
! CODE AFTER THE WORD "COMMON", IE IN COLUMN 13
!
      ICLEN=IK+1
      IF(NNAMED.EQ.0)THEN
            id1=14
            id2=1
         CALL MVRT (id1,id2)
         CLINE(14)=' '
         NFLAG=0
      ELSE
         NFLAG=ICN2-ICN1+1
!     MOVE THE /NAMESS/ TO RIGHT
         CALL MVRT (id1,id2)
         CLINE(14)=' '
            id1=icn2+4
         CALL MVRT (id1,id2)
         CLINE(ICN2+4)=' '
      END IF
!
      RETURN
      END SUBROUTINE PSBFN
! *********************************************************************
      SUBROUTINE SBVCHK ()
      USE RENCOM
      IMPLICIT NONE
        SAVE M1
      INTEGER(2) :: IJKLMN,MYCDEF
!
!     SEE IF WE CAN FIND TYPE DECLARATIONS FOR ANY OF THE VARS
!     TYPED AS 'UNKNOWN, INTENT(INOUT) :: ' IN THE REVISED.TMP (LUN=21)
! * I        MUST CALL THIS ROUTINE BEFORE REVISED.TMP IS OVERWRITTEN BY
! * PROCESSING OF ANOTHER PROGRAM UNIT!!!
!
      CHARACTER(LEN=80) :: OLDTXT,ORITXT
      CHARACTER(LEN=16) :: VARNAM,TMPVNM
      CHARACTER(LEN=31) :: IDSTR1,NSTRNG,TSTRNG,MSTRNG
      CHARACTER(LEN=4) :: TESTIT
      CHARACTER(LEN=1) :: INP
      INTEGER(2) :: I, J, K, KK, ILEN, JJ, ISTRT, M1, M3, NLPARN, NRPARN
      INTEGER(2) :: L, M, LINLEN, LOOP, KL, ITMP
      IDSTR1='      UNKNOWN, INTENT(INOUT) ::'
! THE ABOVE IDSTR1 PHRASE WILL NOT WORK FOIR CHECKS IF ONLY (OUT) APPEARS
      MSTRNG='MODULE'
!
   10 FORMAT (A80)
!
! BEGIN CYCLING THROUGH THE TEMPORARY PGM UNIT FILE AND EXTRACT
! VARIABLE NAMES AS VARNAM
!
      REWIND  ITSBR
      DO I=1,9999
         READ(ITSBR,10,END=220)ORITXT
!## 7:12 -> 7:22
         TSTRNG=ORITXT(7:12)
!## WHY 1:31 ??????? 
         NSTRNG=ORITXT(1:31)
         IF(NSTRNG.NE.IDSTR1)THEN
			ITMP=80
            CALL GETLEN (ORITXT,ITMP,ICLEN)
            WRITE(INTRFC,180) (ORITXT(KK:KK),KK=1,ICLEN)
            GO TO 210
         END IF
!## WHY 33:38?? TRY 33:48
         VARNAM=ORITXT(33:48)
         REWIND  ITMPF
         DO J=1,10000
! WANT TO EXAMINE ONLY DATA TYPE STMTS:KEYWDS(1) AND
! KEYWDS(3 THROUGH 8). THE (2) ENTRY WAS POORLY SELECTED!!!
!
         CALL CLR80(OLDTXT)
         READ(ITMPF,10,END=200)OLDTXT
         TESTIT=OLDTXT(7:10)
! 6-12-97: THERE SEEM TO BE A LOT OF COMBINATIONS I NEED TO IGNORE
! SUCH AS 'EQUIVALENCE' - FOR STARTERS
         IF(OLDTXT(1:1).EQ.'!')GO TO  190
         IF(TESTIT.EQ.'EQUI')GO TO  190
         IF(TESTIT.EQ.'DIME')GO TO  190
! AND FOR THE PRESENT, ALSO IGNORE ANY CHARACTER STMT WHICH CONTAINS A *
         IF(TESTIT.EQ.'CHAR')THEN
! IF THERE AN ASTERISK IN THE LINE, THEN IGNORE IT
            ITMP=72
            CALL GETLEN(OLDTXT,ITMP,ILEN)
            DO JJ=1,ILEN
               IF(OLDTXT(JJ:JJ).EQ.'*')GO TO  190
            END DO
         END IF
         IF(TESTIT.EQ.KEYWDS(2))GO TO  190
         DO K=1,8
            IF(TESTIT.EQ.KEYWDS(K))GO TO  50
         END DO
         GO TO 190
   50      IJKLMN=1
!
! OK TESTIT CONTAINS A DATA-TYPE STMT (I HOPE) SO SEARCH THE
! INPUT LINE FROM THE RIGHT TO PICKOUT VAR NAMES - WITH LH END
! OF NAME THE CHAR TO RT OF COMMA OR = SIGN. STOP SEARCHING WHEN
! =SIGN IS FOUND
!
! $$ 10-15-1999:EXPTL CHANGE OF ISTRT=72 TO ISTRT=73
      ISTRT=73
      KL=0
!##12/5/98
! 13 Oct 2009: What is magical about "17" ??? M1 
   60 M1=17
      TMPVNM='          '
      NLPARN=0
      nrparn=0
      DO L=1,ISTRT-1
         M=ISTRT-L
         INP=OLDTXT(M:M)
         IF(INP.EQ.':')GO TO  80
         IF(INP.EQ.' ')GO TO  70
         IF(INP.EQ.','.AND.NRPARN.EQ.0)GO TO  80
!     5/29/97: I HAVE DISCOVERED A SERIOUS PROBLEM IN FINDING TMPVNM
!        IN SITUATIONS SUCH AS CHARACTER ACHAR(7) OR REAL AVAL(3)
!     BECAUSE I DID NOT ALLOW FOR THE APPEARANCE OF (ANYTHING),
!     THAT IS, I DID NOT DEAL WITH DIMENSIONS APPEARING IN KEYWDS
!     EXPRESSIONS WHEN I TRIED TO EXTRACT VARIABLE NAMES
! *6-12-97* I NOW FIND THAT THIS PART OF EZUP ALSO CHOKES ON THINGS SUCH
! CHARACTER WORD3*3
         IF(INP.EQ.')')THEN
            NRPARN=NRPARN+1
         END IF
         IF(INP.EQ.'(')THEN
              IF (NRPARN.EQ.1) GOTO 70
            NRPARN=NRPARN-1
            IF(NRPARN.EQ.0)GO TO  70
         END IF
         IF(NRPARN.NE.0)THEN
            GO TO 70
         END IF
         M1=M1-1
         IF(M1.LT.1)THEN
! 2 JULY 2009: THERE IS A RECENTLY DISCOVERED BUG HERE: IF A CLOSING
! PAREN IS ON A CONTINUATION CARD THIS STOP OCCURS ,. BUT SHOULDN'T!
!N UNCLOSED ( MAY MEAN THAT THE CHARACTERS TO THE LEFT OF THE MOST
! RECENT INP ARE DIMENSIONS AND THAT I NEED TO LOOK FOR THE NEAREST
! OPENING PAREN BEFORE I WILL FIND A VALID ARRAY NAME
!                  IF(ISAND.AND.(KL.EQ.1)) THEN
            WRITE(IOOUT,*)'! ** WARNING ! ** CLOSING PARENTHESIS NO&
     &T FOUND IN LINE: '
            WRITE(IOOUT,*)'! LINE ',I,OLDTXT
            STOP 401
         END IF
         TMPVNM(M1:M1)=INP
!NEXT MOVED MANUALLY INSIDE THE LOOP 6-21
   70       IJKLMN=1
      END DO
!     ??? WHAT SHOULD I DO IF NO BRANCH ???????
      GO TO 190
!
! LEFT JUSTIFY TMPVNM
             LOOP =1
   80       ISTRT=M
             IF(TMPVNM.EQ.'          ') THEN
                GO TO 60
!                STOP
             END IF
!******************************************************************
!10-12-1999: I SEEM TO HAVE ENCOUNTERED A SITUATION IN WHICH TMPVNM
!           HAS BECOME FILLED WITH SPC CODES! AS A RESULT OF THAT,
!           THE PGM NEVER GETS OUT OF FOLLOWING BLOCK
   90       IF(TMPVNM(1:1).NE.' ')GO TO  110
      DO M3=1,15
      TMPVNM(M3:M3)=TMPVNM(M3+1:M3+1)
      END DO
!          NOW REPLACE RIGHT-MOST ENTRY WITH A SPACE CODE
      TMPVNM(16:16)=' '
      GO TO 90
! END OF THE INFINITE LOOP FOUND 10-12-1999 WORKING WITH 
! SUBROUTINE LPMOON OF SMOO98.FOR
!******************************************************************
!
! NO LABEL-SPACE LEFT, BUT HERE IS PLACE TO COMPARE THE
! TMPVNM FOUND IN IOOUT FILE WITH VARNAM FOUND IN MODULES.OUT
!
  110      IJKLMN=1
         IF(VARNAM.EQ.TMPVNM)GO TO  120
      IF(VARNAM.NE.TMPVNM.AND.INP.NE.':')GO TO  60
      GO TO 190
!
! OK, WE HAVE A MATCH! FIND COL CONTAINING LEFTMOST COLON
! AND REPLACE EVERYTHING (IE,'      UNKNOWN ::') BY
! CORRESP DATA TYPE STATEMENT FROM THE OLDTXT LINE
!
  120       IJKLMN=1
!
! LOCATE COMPLETE TYPE-DECLARATION IN OLDTXT
      DO JJ=1,72
         M=JJ
         IF(OLDTXT(M:M).EQ.':')GO TO  140
      END DO
!        HMMMM NO COLON WAS FOUND!!
      WRITE (*,*) 'BUG 1 IN SBVCHK- JOB CANCELLED.'
      WRITE (*,*)'TROUBLESOME LINE WAS :'
      WRITE(*,*) OLDTXT
      STOP 402
!
!    COPY STUFF TO CLINE SO I CAN USE THE MVRT, MVLF FUNCTIONS IF NEEDED
!
! WHAT I REALLY WANT TO DO NOW IS TO REPLACE THE LEADING
! "UNKNOWN" BY THE DETECTED DATA-TYPE
! THE DATA-TYPE DELARATION IS IN COLUMNS 7:M+1 OF OLDTXT
! WHILE IT IS THE ORITXT LINE I WANT TO MODIFY
  140       CALL CLRLL(CLINE)
            DO JJ=1,M-1
      CLINE(JJ)=OLDTXT(JJ:JJ)
      END DO
!   INSERT A SPACE CODE
      CLINE(M)=' '
      ICLEN=M
!   NOW ATTACH REMAINING PART OF THE INTENT STATEMENT
      DO JJ=14,32
         ICLEN=ICLEN+1
      CLINE(ICLEN)=ORITXT(JJ:JJ)
      END DO
!
      M=ICLEN
      DO JJ=1,16
         ICLEN=ICLEN+1
      CLINE(ICLEN)=VARNAM(JJ:JJ)
      END DO
  180       FORMAT (80A1)
      WRITE (INTRFC,180) (CLINE(JJ),JJ=1,ICLEN)
      GO TO 210
!
!
! EASIER SAID THAN DONE! NOT SO SIMPLE TO REPLACE THE
! CURRENT LINE IN THE MODULES FILE!!!!! UNLESS I USE ANOTHER
! TEMPORARY BUFFER FILE INTO WHICH I COPY THE MODULES.TXT
! CONTENTS AS I GO ALONG!
!
!NEXT MOVED MANUALLY INSIDE LOOP 6-21
! END OF J-LOOP
!
  190    IJKLMN=1
         END DO
!
!     IF WE EXIT FROM LOOP OVER SOURCE FILE WITHOUT A BRANCH
!     FOR HANDLING THE CURRENT LINE FROM MODULES.OUT IT PROBABLY
!     MEANS THAT WE DID NOT FIND ANY "TYPED" VARIABLE WHOSE
!     NAME MATCHED VARNAM FROM THE MODULE, 'THO THAT NEVER ACTUALLY
!     SEEMS TO HAPPEN.
!     IN THAT CASE, OR IF I REACH EOF ON THE SOURCE FILE, THEN
!     JUST PASS PASS THE LINE FROM "MODULES.OUT"  AS IT STANDS
!
  200    ITMP=80
         CALL GETLEN (ORITXT,ITMP,LINLEN)
         IF(LINLEN.GT.72)LINLEN=72
         WRITE (INTRFC,180) (ORITXT(JJ:JJ),JJ=1,LINLEN)
!
!MANUALLY MOVED INSIDE LOOP 6-21-97
  210 MYCDEF=0
      END DO
!
  220 IJKLMN=1
!
      RETURN
      END SUBROUTINE SBVCHK
! *********************************************************************
!** WARNING: NEXT FUNCTION-NAME'S DATA-LENGTH DECLARATIONS INCOMPLETE!
      LOGICAL FUNCTION ISSBP(VARNAM)
      USE RENCOM
      IMPLICIT NONE
!      INTEGER(2) :: IJKLMN
!     LOGICAL, INTENT(OUT) ::  ISSBP
      CHARACTER(LEN=6)  , INTENT(INOUT) :: VARNAM
      INTEGER(2) :: I
!     IS VARNAM A MEMBER OF CURRENT SUBROUTINE PARAMETER LIST
!     IE, IS IT IN PRMLST?
!     VARNAM SHOULD BE LEFT JUSTIFIED UPON ENTRY
!
      DO I=1,NPRMS
         IF(VARNAM.EQ.PRMLST(I))THEN
      ISSBP=.TRUE.
      RETURN
         END IF
      END DO
      ISSBP=.FALSE.
      RETURN
      END FUNCTION ISSBP
! *********************************************************************
      SUBROUTINE PARSEC (ISTART)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN, MYCDEF
      INTEGER(2), INTENT(INOUT) :: ISTART
!
!     PURPOSE IS TO PARSE CLINE AND RETURN A LIST (VLST) OF
!     VARIABLE NAMES IN THE LINE.
!     ******************************************************
!     *NOTE WELL* THIS ROUTINE IS INITIALLY INTENDED TO FIND
!     VARIABLES ONLY IN TYPE-DECLARATION STATMENTS!
!     * DOES NOT DO MATHEMATICAL PARSING!!! *
!     ******************************************************
!
!     ON ENTRY, ISTART SHOULD IDENFIFY LEFT-MOST COLUMN IN
!     WHICH THE SEARCH SHOULD BEGIN. THE CALLER MUST SET ISTRT
!                CLINE
!     RETURNS VLST VIA COMMON /REN/ (SEE EZUP.IN)
!           NVS  = VARIABLES FOUND
!
      CHARACTER(LEN=6) :: WRKNAM
      CHARACTER(LEN=1) :: COMMA
      CHARACTER(LEN=1) :: LPAREN
      CHARACTER(LEN=1) :: RPAREN
      CHARACTER(LEN=6) :: NONAME
      INTEGER(2) :: I, ISTRT, J,K, NPRNS, NCHRS,KK, IJK
      COMMA = ','
      NONAME = '      '
      LPAREN = '('
      RPAREN = ')'
!
! INITIALIZE VLST
      DO I=1,50
      VLST(I)=NONAME
      END DO
      NVS=0
      ISTRT=ISTART
!     SEARCH FOR VARIABLE NAMES, SKIPPING PARENS
   20 IJKLMN=1
      J=0
      NPRNS=0
      IF(ICHAR(CLINE(ISTRT)).EQ.255)ISTRT=ISTRT+1
      DO I=ISTRT,ICLEN
         K=I
         IF(ICHAR(CLINE(I)).EQ.255)GO TO  30
         IF(CLINE(I).EQ.' ')GO TO  30
         IF(CLINE(I).EQ.COMMA)GO TO  40
         IF(CLINE(I).EQ.LPAREN)NPRNS=NPRNS+1
         IF(CLINE(I).EQ.RPAREN)THEN
      NPRNS=NPRNS-1
      IF(NPRNS.EQ.0)GO TO  40
         END IF
         J=J+1
         WRKNAM(J:J)=CLINE(I)
!NEXT MANUALLY MOVED INSIDE LOOP 6-21-97
   30 MYCDEF=0
      END DO
!     HAVE WE REACHED THE END OF CLINE ???
      IF(K.EQ.ICLEN.AND.J.EQ.0)GO TO  90
   40 NCHRS=J
      IF(J.LT.6)THEN
         DO J=NCHRS+1,6
         WRKNAM(J:J)=' '
         END DO
      END IF
!     DOES WRKNAM ALSO APPEAR IN THE SUBR PARAM LIST ?
      DO KK=1,NPRMS
         IF(WRKNAM.EQ.PRMLST(KK))THEN
      IJK=1
         END IF
      END DO
!     ADD TO VLST
      DO I=1,50
         IF(VLST(I).NE.NONAME)GO TO  70
         VLST(I)=WRKNAM
         NVS=NVS+1
!     GET OUT OF VAR-NAME HUNTING LOOP
         GO TO 80
!NEXT MOVED MANUALLY 6-21-97
   70 MYCDEF=0
      END DO
!     RECYCLE
!   70 IF (NPRNS.NE.0) GO TO 20
   80 ISTRT=K+1
      GO TO 20
   90 RETURN
      END SUBROUTINE PARSEC
! *********************************************************************
      SUBROUTINE BLDNFC
         USE RENCOM
         IMPLICIT NONE
! THE AIM OF THIS SUBROUTINE IS TO CREATE A FILE CONTAINING
! INTERFACE INFORMATION WHICH CAN BE TRANSFERRED (MANUALLY)
! TO PROGRAM UNITS WHICH NEED THEM. IT WILL READ THE TEMPORARY
! FILE INTRFACE.TMP (LUN=INTRFC) AND WRITE TO INTRFACE.OUT(LUN=35)
! IT WILL COPY EVERYTHING FROM A PROGRAM UNIT DOWN TO THE
! END OF THE EZUP GENERATED INTENT STATEMENTS, AND THEN SKIP OVER
! ALL STATAMENTS EXCEPT THE END SUBROUTINE OR END FUNCTION STMTS
! WRITES TO LUN=35 ARE TO BE "APPENDS" .. NEVER REWIND IT BETWEEN
! PASSES TO NEW PEOGRAM UNITS.
      CHARACTER(LEN=12) :: WD1, WD2, WD3, WD4, TESTWD
         CHARACTER(LEN=72)  :: ORITXT
         INTEGER(2) :: I, J, K, ILEN
         INTEGER(2) :: ITMP,ijklmn
         LOGICAL :: START, NDFLAG, AFLAG
!
      WD1='END FUNCTION'
         WD2='END SUBROUTI'
         WD3='END PROGRAM '
         WD4='! **********'
         START=.TRUE.
         NDFLAG=.FALSE.
         AFLAG=.TRUE.
      REWIND INTRFC
         DO I=1,10000
   10     READ(INTRFC,'(A72)',END=100)ORITXT
!IF THIS IS NOT A SUBROUTINE OR A FUNCTION TAKE SPECIAL STEPS
!TO SKIP OVER EVERYTHING UNTIL WE FIND ONE OR RUN OUT OF FILE
!unit 35 is opened with filiename INTRFCxx.
      IF (ORITXT(7:13).EQ.'PROGRAM') GO TO 20
         IF(ORITXT(1:12).EQ.WD4) GO TO 90
         IF (ORITXT(1:18).EQ.'! ** END OF EZUP-G') THEN
             START=.FALSE.
                  ITMP=72
         CALL GETLEN(ORITXT,ITMP, ILEN)
         WRITE(35,'(72A1)')(ORITXT(J:J),J=1,ILEN)
               GO TO 15
           END IF
!
         TESTWD(1:12)=ORITXT(7:20)
         IF (TESTWD.EQ.WD1 .OR. TESTWD.EQ.WD2) THEN
               NDFLAG =.TRUE.
             ITMP=72
             CALL GETLEN(ORITXT,ITMP, ILEN)
             WRITE(35,'(72A1)')(ORITXT(J:J),J=1,ILEN)
             WRITE(35,'(A19)')'     END INTERFACE'
             WRITE(35,'(A12)') WD4
             GO TO 100
         END IF
!
   15      IF (START) THEN
        IF (AFLAG) THEN
           WRITE(35,'(A15)')'     INTERFACE'
             AFLAG=.FALSE.
        END IF
! OMIT LEADING INTEGER(2) :: IJKLMN, MYCDEF LINES!
        IF(ORITXT(7:23).EQ.'INTEGER(2) :: IJKLMN') GO TO 90
              ITMP=72
            CALL GETLEN(ORITXT,ITMP, ILEN)
        WRITE(35,'(72A1)')(ORITXT(J:J),J=1,ILEN)
         END IF
         GO TO 90
   20 DO K=1,10000
!READ UNTIL WE FIND AN END PROGRAM STATEMENT
         READ(INTRFC,'(A72)',END=100) ORITXT
       IF (ORITXT(7:20).EQ.WD3) GO TO 90 
      END DO
   90 ijklmn=1
      END DO
  100 RETURN
        END SUBROUTINE BLDNFC
! *********************************************************************
      subroutine clr80(text)
      character(len=80) :: text
      integer(2) :: i
      do i=1,80
            text(i:i)=' '
      end do
      return
      end subroutine clr80
! *********************************************************************

      SUBROUTINE POSTPROC()
!
! 09 AUGUST 2009
! THIS ROUTINE IS AN EZUP POST PROCESSOR WHICH WILL LOOK AT THE MOST
! RECENT EZUP CREATED .F90 OUTPUT FILE AND THE MOST RECENT 
! VARNAMES.TMP FILE AND ATTEMPT TO REMOVE ANY DATA TYPE DECLARATIONS
! FOR VARIABLE NAMES FOUND FOUND IN THE PROGRAM CODE THAT ALSO APPEAR IN
! THE VARNAMES.TMP FILE
! 
! THINGS ARE SUPPOSED TO WORK LIKE THIS:
! NEAR THE END OF THE EZUP MAIN PROGRAM (EZMAIN) IT CALLS A SUBROUTINE
! NAME 'COMMVARS' THAT SEARCHES THE MODULEXX.F90 FILE (CREATED BY EZUP) 
! THAT MAKES A LIST OF ALL VARIABLE NAMES FOUND IN THE MODULEXX.F90 FILE
! POSTPROC THEN SEARCHES THE INITIAL OUTPUT SOURCE CODE FILE (CREATED BY
! EARLIER EZUP STEPS) FOR DATA TYPE DECLARATION STATEMENTS FOR THOSE
! VARIABLE NAMES INITIALLY TYPED AS 'UNKNOWN' IN MODULESXX.F90.IF AN
! APPROPRIATE DATA TYPE DECLARATION IS FOUND, THEN THE 'UNKNOWN' TYPES
! WILL BE REPLACED BY WHATEVER DATA TYPE WAS FOUND FOR THAT VARIABLE IN
! THE INITIAL EZUP OUTPUT FILE. POSTPROC ALSO TRIES TO REMOVE THOSE TYPE
! DECLARATION STATEMENTS FROM THE INITIAL EZUP OUTPUT FILE IN ORDER TO
! TRY TO MINIMIZE MULTIPLE TYPE DECLARATION ERRORS DURING SUBSEQUENT
! COMPILATIONS.
!
! NOTES: SUBROUTINE CMVCHK      CREATES A FILE NAMES 'VARNAMES.TMP' LISTING
!      VARIABLE NAMES AND DATA TYPES FOUND IN THE INITIAL EZUP OUTPUT 
!     FILE. AT THE MOMENT THAT FILE IS UNUSED.
!
! INNAME IS THE NAME A USER CHOOSES FOR THE FINAL OUTPUT FILE
!
      USE RENCOM
      IMPLICIT NONE
      INTERFACE
            FUNCTION GETLLEN(NAME)
            CHARACTER(LEN=1450) :: NAME
            INTEGER(2) :: GETLLEN
            END FUNCTION GETLLEN
      END INTERFACE
      INTERFACE
         SUBROUTINE READCC(SLINE,WRKLIN,LEN1,LUIN)
         CHARACTER(LEN=73) :: SLINE
         CHARACTER(LEN=1450) :: WRKLIN
         INTEGER(2) :: LEN1
         integer luin
         END SUBROUTINE
      END INTERFACE
      INTERFACE
         SUBROUTINE VNSRCH(TESTR,VARINF,VARTYP,NVARS)
         CHARACTER(LEN=32) :: VARINF(256),VARTYP
         CHARACTER(LEN=1450) :: TESTR
         INTEGER(2) :: NVARS
         END SUBROUTINE VNSRCH
      END INTERFACE
!
      INTEGER(2) :: IJKLMN
!!      CHARACTER(LEN=96), INTENT(INOUT) :: INNAME
!
      CHARACTER(LEN=4) :: DWDS(6)
      CHARACTER(LEN=16) :: VARNAM(256),TMPNAM,PRGVAR
      CHARACTER(LEN=32) :: VARINF(256),VARTYP,BIGNAM,TYPNAM
      CHARACTER(LEN=73) :: SLINE
      CHARACTER(LEN=1) :: INP,SPC,AMPERS,LP,RP
      CHARACTER(LEN=1450) :: WRKLIN,TMPLIN
      INTEGER(2) :: ISRCF,I,J,L,INLEN,NAMLEN, NWRK
      INTEGER(2) :: NVARS,I4,I5,IDUM,LLEN,CLNPOS,ID1,ID2
      INTEGER(KIND=2) :: NV,IRP,ILP,IBEGIN,IEND,JJ,ILEN
      integer luin,LUO
      LOGICAL :: MORVAR,EXST,OPND,IOPN
!
      DWDS(1)='INTE'
      DWDS(2)='REAL'
      DWDS(3)='LOGI'
      DWDS(4)='COMP'
      DWDS(5)='CHAR'
      DWDS(6)='DOUB'
      RP='('
      LP=')'
!
      INQUIRE(FILE='PASS1.F90',EXIST=EXST)
      IF (.NOT.EXST) THEN
            WRITE(*,*)'CANNOT OPEN FILE PASS1.FOR. ABORTING.'
            RETURN
      END IF

      SPC=' '
      AMPERS='&'
      LUO=40
      ISRCF=42
      LUIN=43
      nwrk=73
      OPEN(UNIT=LUIN,FILE='COMMVARS.TMP',STATUS='OLD')
      DO I=1,256
         READ(LUIN,1001,END=10)BIGNAM,TYPNAM
            PRGVAR(1:16)=BIGNAM(1:16)
            VARNAM(I)(1:16)=PRGVAR(1:16)
            NVARS=I
            J=I
      END DO
      CLOSE(LUIN)
   10 INQUIRE(FILE='PASS1.F90',OPENED=OPND)
! THERE MAY BE TWO UNIT NUMBERS; WHICH ONE IS OPEN?
         IF(OPND) THEN
            IOPN=.FALSE.
            INQUIRE(UNIT=IOOUT,OPENED=IOPN)
            IF(IOPN) CLOSE(IOOUT)
            INQUIRE(UNIT=47,OPENED=IOPN)
            IF(IOPN) CLOSE(47)
            INQUIRE(UNIT=43,OPENED=IOPN)
            IF(IOPN) CLOSE(43)
         END IF
         OPEN(UNIT=43,FILE='PASS1.F90',STATUS='OLD')
      12      OPEN(UNIT=LUO,FILE=FNAME2,STATUS='UNKNOWN')
      MORVAR=.FALSE.
!     THE IS A RECYCLING POINT TO READ THE NEXT CARD  TO BE PROCESSED
   15      CALL CLRLLIN(WRKLIN)
      CALL CLRLLIN(TMPLIN)
      READ(43,1002,END=1000)SLINE
      CALL GETLEN(SLINE,nwrk,ILEN)
!DEBUG STEPS
      IF(SLINE(7:10).EQ.'EXTE') THEN
            IJKLMN=1
      END IF
! PASS ANY COMMENT LINES TO THE OUTPUT FILE
      IF(SLINE(1:1).EQ.'!') THEN 
            CALL GETLEN(SLINE,nwrk,ILEN)
            WRITE(LUO,'(80A1)')(SLINE(JJ:JJ),JJ=1,ILEN)
!            WRITE(LUO,*)SLINE
            GOTO 15
      END IF
! TEST LINE TO SEE IF IT HAS ANY C-CARDS
      IF (SLINE(73:73).EQ.'&'.OR.SLINE(72:72).EQ.'&') THEN
            CALL READCC(SLINE,WRKLIN,INLEN,LUIN)
            LLEN=GETLLEN(WRKLIN)
      ELSE
            CALL GETL73(SLINE,nwrk,LLEN)
            WRKLIN(1:LLEN)=SLINE(1:LLEN)
      END IF
! 17 AUG 2009: I ALSO WANT TO AVOID COMPRESSION OF FORMAT, WRITE, AND
! PERHAPS SOME OTHER AS YET UNDISCOVERED STATEMENTS
!
      CALL PAKDW(WRKLIN,LLEN,CLNPOS)
! AT THIS POINT, WRKLIN SHOULD HAVE BEEN PACKED SO THAT ANY TYPE DECL
! KEYWORDS WILL APPEAR IN COLS 7:10; LLEN IS THE LENGTH OF THE PACKED
! LINE AND CLNPOS POINTS TO SECOND CHARARACTER AFTER ::
      DO I=1,6
            IF (WRKLIN(7:10).EQ.DWDS(I)) GO TO 21
      END DO
! JUST PASS ALONG ANY FORMAT STMTS
      IF(WRKLIN(7:10).EQ.'FORM') THEN
! CHECK FOR AND READ ANY ASSOCIATED CCARDS AND THEN PASS THEN TO NEWPRG
!            CALL READCC(SLINE,WRKLIN,INLEN,LUIN)
            CALL PUTLIN(WRKLIN,LUO)
            IDUM=0
      ELSE
            CALL PUTLIN(WRKLIN,LUO)
      END IF
      GOTO 15
21    IJKLMN=1
      CALL CLRLLIN(TMPLIN)
      TMPLIN(1:LLEN)=WRKLIN(1:LLEN)
      IBEGIN=CLNPOS-1
      I4=CLNPOS
! WE SHOULD ARRIVE HERE ONLY IF A DWD HAS BEEN DETECTED IN WRKLIN
! I CAN NOW TRY CALLING VNSRCH WITH WRKLIN AS THE INPUT LINE. IT
! SHOULD RETURN AN ARRAY OF VARIABLE NAMES AS VARINF, WITH TYPE=VARTYP
      CALL VNSRCH(WRKLIN,VARINF,VARTYP,NV)
! NOW I WANT TO ACTUALLY SEARCH FOR ONE OR MORE VARIABLE NAMES, 
! BEGINNING AT POSITION L1+1. L1  WILL BE ADJUSTED IF MULTIPLE VARNAMES
! ARE FOUND. NEXT LINE IS THE "BEGIN SEARCH FOR NEXT VARNAME" POINT
! ---------------------------------------------------------------------
!         STEP 1
! --------------------------------------------------------------------
25      ILP=0
      IRP=0
      CALL CLRTN(TMPNAM)
! VARNAME PRESUMABLY BEGINS IN COLUMN IBEGIN
! DOES WRKLIN CONTAIN A ( BEYOND COLUMN IBEGIN ?
      DO L=IBEGIN,LLEN
            IF(WRKLIN(L:L).EQ.RP) THEN
! I HAVE VARNAME OF AN ARRAY
                  IRP=L
! EXPECT A ) TO TERMINATE VARNAM. FIND IT
                  DO I=IRP,LLEN
                        IF (WRKLIN(I:I).EQ.LP) THEN
                              ILP=I
                              IEND=I
                              NAMLEN=IEND-IBEGIN+1
                              TMPNAM(1:NAMLEN)=WRKLIN(IBEGIN:IEND)
                              INP=WRKLIN(IEND+1:IEND+1)
                              IF(INP.EQ.',') THEN
                                    MORVAR=.TRUE.
                              ELSE
                                    MORVAR=.FALSE.
                              END IF
                              GOTO 35
                        END IF
                  END DO
! THERE IS AN UNMATCHED PARENTHESIS SOMEWHERE IN WRKLIN
                  WRITE(*,*)'ERROR ENCOUNTERED! THERE IS NO CLOSING PAR&
        &ENTHESIS IN LINE BEGINNING WITH: '
                        WRITE(*,*) WRKLIN(1:72)
!                              RETURN
            END IF
      END DO
! ---------------------------------------------------------------------
! BEGIN STEP 2;SEARCHING FOR NON-ARRAY VAR NAMES, COMMA OR SPC IS END+1
! ---------------------------------------------------------------------      
   30 CALL CLRTN(TMPNAM)
        DO L=IBEGIN,LLEN
            IEND=L
            INP=WRKLIN(L:L)
            IF(INP.EQ.SPC.OR.INP.EQ.',') THEN
                  IF(INP.EQ.',') THEN 
                        MORVAR=.TRUE.
                  ELSE
                        MORVAR=.FALSE.
                  ENDIF
                  IEND=L-1
                  NAMLEN=IEND-IBEGIN+1
                  TMPNAM(1:NAMLEN)=WRKLIN(IBEGIN:IEND)
                  GOTO 28
            END IF
      END DO
! ---------------------------------------------------------------------
!  STEP 3: SAVE      ??????????????
! ---------------------------------------------------------------------
   35      IJKLMN=1
! ARE THERE ANY MORE VARIABLES IN THE LINE? IF VARNAM ENDED AT A COMMA
! THEN THE ANSWER IS YES, AND I NEED TO RESET IBEGIN AND RETURN TO STEP1
! REMOVE ANY LEADING SPC CODES FROM TMPNAM
28                  ID1=1
                  ID2=32
                  CALL PAKLFT(TMPNAM,ID1,ID2)
! AT THIS POINT I HAVE PRESUMABLY FOUND A VARNAME IN THE .F90 FILE
! NOW I NEED TO SEE IF THE SAME VARNAME APPEARS IN THE VARNAMES.TMP
! FILE. IF IT DOES, THEN I WANT TO DELETE IT FROM SLINE
!
                  IF(TMPNAM(1:6).EQ.'PSINVB') THEN
                        IJKLMN=1
                  END IF
                  CALL CNVNUL(TMPNAM)
                  DO I5=1,NVARS
                        CALL CNVNUL(VARNAM(I5))
                        IF (TMPNAM.EQ.VARNAM(I5)) THEN
                              GOTO 40
                        END IF
                  END DO
!
! WHAT SHOULD I DO IF EXECUTION GETS TO HERE? THAT WILL HAPPEN IF TMPNAM
! IS NOT FOUND IN A MODULE
                  CALL PUTLIN(WRKLIN,LUO)
                  GOTO 15
!
   40 IJKLMN=1
! A JUMP TO HERE MEANS THAT THE VARNAME (TMPNAM) IN THE PROGRAM FILE
! WAS FOUND IN THE MODULE VARIABLES FILE VARNAMES.TMP, SO THAT I SHOULD
! GO AHEAD AND DELETE IT FROM SOURCELINE 'SLINE'
                  idum=iend+1
                  CALL RMVNAM(WRKLIN,IBEGIN,idum)
                  IF (.NOT.MORVAR) THEN
! I MAY NOW HAVE A TYPE DECL WITHOUT ANY VARNAMES IN THE LINE. IF SO, I
! DO NOT EVEN WANT TO PASS THIS LINE TO THE OUTPUT FILE.
                        LLEN=GETLLEN(WRKLIN)
                        IF (LLEN.GT.CLNPOS-2) THEN
                              CALL PUTLIN(WRKLIN,LUO)
                        END IF
                        GOTO 15
                  ELSE
! NEED TO CONTINUE SEARCH OF CURRENT LINE FOR MORE VARNAMES
! BEFORE GOING BACK FOR NEXT VAR NAME I NEED TO REMOVE THIS ONE FROM WRKLIN
! AND LATER WRITE RESULTS TO A REPLACEMENT FOR ORIG OUTPUT FILE FNAME2
                        GOTO 25
                  END IF
      GOTO 15
!
! THIS IS THE END OF POSTPROC OPERATIONS
!
 1000 CLOSE(43)
      CLOSE(42)
      CLOSE(LUO)
!
 1001 FORMAT(A32,1X,A32)
 1002 FORMAT(A73)
 1003 FORMAT(A1)
      END SUBROUTINE POSTPROC
! *********************************************************************
      SUBROUTINE CLRTN(NAME)
!     SET ALL CHARACTERS IN INCOMING STRING "NAME" TO SPACE CODES
      CHARACTER(LEN=16) :: NAME
      INTEGER(2) :: I
      DO I=1,16
            NAME(I:I)=' '
      END DO
      RETURN
      END SUBROUTINE CLRTN
!
      SUBROUTINE HEADER(VERSNO)
      IMPLICIT NONE
      REAL, INTENT(INOUT) :: VERSNO
   10 FORMAT(25(/))
   20 FORMAT(                                   &
     & 14X,  'EZUP: FORTRAN77 TO FORTRAN90 CONVERSION HELPER'//         &
     & 14X,  '     COPYRIGHT (C) BY AUGUST MILLER  1998'//        &
     & 14X,  '       ALL RIGHTS RESERVED'//                 &
     & 14X,  '       ** VERSION ',F4.2,'  ** ',5(/))
      WRITE(*,10)
      WRITE(*,20)VERSNO
      RETURN
      END SUBROUTINE HEADER
! **********************************************************************
      SUBROUTINE UC1(ALFA)
      IMPLICIT NONE
      INTEGER(2) :: INX
      CHARACTER(LEN=1)  , INTENT(INOUT) :: ALFA
!     CONVERTS 'ALFA' TO UPPER CASE IF IT IS ALPHABETIC LOWER CASE
      INX=ICHAR(ALFA)
      IF(INX.GE.97.AND.INX.LE.122)ALFA=CHAR(INX-32)
      RETURN
      END SUBROUTINE UC1
! **********************************************************************
      SUBROUTINE UCA(AL)
      IMPLICIT NONE
      INTEGER(2) :: MYCDEF, I, INEW
! ** BEGIN  EZUP-GENERATED 'INTENT' STATEMENTS **
      CHARACTER(LEN=4)  , INTENT(INOUT) :: AL
! ** END OF EZUP-GENERATED 'INTENT' STATEMENTS **
!      CHARACTER CAL(4)
      CHARACTER(LEN=4) :: CAL
      CHARACTER(LEN=4) :: DUMMY
!     ------------------------------------------------------------------
!
!     THIS ROUTINE TAKES AN INCOMING CHARACTER*4 VARIABLE 'AL' AND CONVE
!     ALL FOUR ELEMENTS TO UPPER CASE. ONLY ELEMENTS CORRESPONDING TO
!     (A-Z) ARE AFFECTED.
!
!     FOR EXAMPLE, IF AL IS DEFINED BY
!     DATA AL/'PATH'/
!
!     THEN AL IS RETURNED AS PATH
!
!     --------------------------------------------------------------
!      EQUIVALENCE(CAL(1),DUMMY)
      DUMMY=AL
      DO I=1,4
         INEW=ICHAR(CAL(I:I))
         IF(INEW.LT.96.OR.INEW.GT.122)GO TO  10
         CAL(I:I)=CHAR(INEW-32)
! NEXT MANUALLY MOVED INSIDE LOOP 6-23-97
   10 MYCDEF=0
      END DO
      AL=DUMMY
      RETURN
      END SUBROUTINE UCA
!  ****************************************************************
      SUBROUTINE KPRESS
      IMPLICIT NONE
!
!     CALL TO WAIT FOR INPUT FROM KBD
!
      CHARACTER(LEN=1) :: INP
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   10 FORMAT(//24X,'PRESS RETURN KEY TO CONTINUE. ')
!* WARNING: CANNOT CONVERT "FORMAT" STATEMENTS
   20 FORMAT(A1)
   30 WRITE(*,10)
      READ(*,20,ERR=30)INP
      RETURN
      END SUBROUTINE KPRESS
! **********************************************************************
      SUBROUTINE GETINF(LUNIN,IERR)
      use rencom
      IMPLICIT NONE
      INTEGER(2), INTENT(INOUT) :: IERR
      integer lunin
!      CHARACTER(LEN=96)  , INTENT(INOUT) :: FNAME1
!
!     REVISED 27 APR 1989
!
!     ASKS FOR NAME OF A PRE-EXISTING FILE TO BE OPENED AS LOGICAL
!     UNIT = LUNIN.
!     RETURNS IERR = 0 FOR SUCCESSFUL OPEN OPERATIONS
!            = -1 IF FILE DOES NOT EXIST AND USER CHOOSES TO
!                 ABORT.
! -------------------------------------------------------------------
      CHARACTER(LEN=1) :: INP
      CHARACTER(LEN=1) :: ACHAR
      CHARACTER(LEN=1) :: RCHAR
      CHARACTER(LEN=4) :: ABORT, TEMP
      LOGICAL :: EX, OD
      DATA ABORT/'QUIT'/ ACHAR/'A'/ RCHAR/'R'/
   10 FORMAT(A96)
   20 FORMAT(//' PLEASE ENTER NAME OF INPUT DATA FILE : ')
   30 FORMAT(/' INPUT FILE DOES NOT EXIST OR OTHER ERROR DETECTED.'/' RE&
     &-ENTER NAME (OR ENTER UPPER-CASE ''QUIT''  TO ABORT)..'/)
   40 FORMAT(A1)
   50 FORMAT(/1X,A96,' IS ALREADY OPEN.'/' ENTER ''A'' TO ABORT OR ''R''&
     & TO REWIND IT AND CONTINUE..'/)
!
   60 WRITE(*,20)
   70 READ(*,*,ERR=60)FNAME1
      TEMP=FNAME1
      CALL UCA(TEMP)
      IF(TEMP.EQ.ABORT)GO TO  120
!
!     SEE IF IT EXISTS
!
      INQUIRE(FILE=FNAME1,EXIST=EX,OPENED=OD)
!
!     IF NOT, THEN ASK FOR NEW NAME OR ABORT
!
      IF(.NOT.EX)THEN
         WRITE(*,30)
         GO TO 70
      END IF
!
!     IF IT DOES EXIST, SEE IF IT IS ALREADY OPEN
!
      IF(OD)THEN
!
!     AND IF IT IT OPEN, GIVE USER CHOICE OF ABORTING OR REWINDING
!     IT FOR RE-USE
!
   90    WRITE(*,50)FNAME1
         READ(*,40)INP
         CALL UC1(INP)
         IF(INP.EQ.ACHAR)GO TO  120
         IF(INP.NE.RCHAR)THEN
      WRITE(*,*)'YOU MUST CHOOSE ''A'' OR ''R'''
      GO TO 90
         END IF
!
!    REWIND THE UNIT AND TRY TO USE IT AS IS
!
         REWIND  LUNIN
         IERR=0
         RETURN
      END IF
!
!     IT EXISTS AND ISN'T OPEN, SO GO AHEAD AND OPEN IT
!
!   NEXT LINE EXPANDED 11 AUG 2009 TO AVOID LF90 RUNTIME PROBLEMS;ADDED 
!  ",ACTION='READ'"
      OPEN(LUNIN,FILE=FNAME1,STATUS='OLD',ACCESS='SEQUENTIAL',ERR=110  ,&
     &ACTION='READ')
!     GET HERE IF INPUT FILE WAS OPENED SUCCESSFULLY
      IERR=0
      RETURN
  110 WRITE(*,30)
      GO TO 60
  120 IERR=-1
      WRITE(*,*)'ABORT COMMAND DETECTED AND BEING EXECUTED IN ROUTINE GE&
     &TINF.'
      RETURN
      END SUBROUTINE GETINF
! **********************************************************************
      SUBROUTINE GETOUF(LUOUT,IERR)
      use rencom
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN,IVAL
      INTEGER :: NUM
      INTEGER LUOUT
      INTEGER(2), INTENT(OUT) :: IERR
!      CHARACTER(LEN=96)  , INTENT(INOUT) :: FNAME2
!
!     27 APR 1989
!
!     USED SOLICIT FILE NAME AND THEN OPEN AN OUTPUT DATA FILE TO BE
!     ASSIGNED TO LUN = LUOUT.
!     WILL CREATE THE FILE IF IT DOES NOT ALREADY EXIST
!     IF FILE ALREADY EXISTS, USER IS GIVEN OPTION OF OVERWRITING IT,
!     ENTERING A NEW NAME OR ABORTING.
!
!     RETURNS IERR = 0 FOR SUCCESSFUL OPENING OF THE FILE
!            = -1 TO INDICATE USER CHOICE TO ABORT RATHER THAN
!                 OVERWRITE AND EXISTING FILE OR CHOOSE A
!                 DIFFERENT FILE NAME.
!            = + 1 TO INDICATE THAT USER  WANTS TO USE CONSOLE
!            FOR OUTPUT.
! -------------------------------------------------------------------
!
      CHARACTER(LEN=1) :: INP
      CHARACTER(LEN=1) :: YES
      CHARACTER(LEN=1) :: NO
      CHARACTER(LEN=4) :: ABORT,TERM,TEMP,NULL
      LOGICAL :: EX,OD
      REAL :: VALUE
      DATA YES/'Y'/ NO/'N'/
      DATA ABORT/'QUIT'/ TERM/'CONS'/
      DATA NULL /'    '/
   10 FORMAT(A96)
   20 FORMAT(A1)
   30 FORMAT(//' PLEASE ENTER NAME FOR OUTPUT FILE : (USE ''CONS'' FOR C&
     &ONSOLE). '/)
   40 FORMAT(' FILE ALREADY EXISTS! OVERWRITE IT (Y/N) ? ..')
   50 FORMAT(' PLEASE ENTER ANOTHER NAME FOR THE OUTPUT FILE '/' (OR ENT&
     &ER ''QUIT'' TO ABORT) .')
   60 FORMAT(//' ** OUTPUT WILL DE DIRECTED TO STANDARD OUTPUT UNIT **'/&
     &)
!
!     SEE IF UNIT LUOUT IS ALREADY BUSY
!
      INQUIRE(UNIT=LUOUT,OPENED=OD)
!
!     IF IT IS, CLOSE IT AND DON'T LOOK BACK
!
      IF(OD)THEN
         WRITE(*,*)'ROUTINE GETOUT IS CLOSING LOGICAL UNIT NUMBER ',LUOU&
     &T
         WRITE(*,*)'WILL RE-OPEN WITH FILE NAME TO BE ENTERED BELOW'
         WRITE(*,*)' '
         CLOSE(LUOUT)
      END IF
!
!     GET OUTPUT FILE NAME AND TRY TO OPEN IT
   70 WRITE(*,30)
      READ(*,10,ERR=70)FNAME2
      IF(FNAME2.EQ.NULL)THEN
         WRITE(*,*)'* NAME MAY NOT BE NOTHING BUT SPACES OR <RETURN>*.'
         WRITE(*,*)
         GO TO 70
      END IF
!
!     PICK MAX OF FOUR CHARACTERS AND CONVERT TO UPPER CASE
!
      TEMP=FNAME2
      CALL UCA(TEMP)
      IF(TEMP.EQ.ABORT)GO TO  130
!
!     TAKE SPECIAL ACTIONS IF OUTPUT FILE IS TO BE THE USER'S CONSOLE
!
      IF(TEMP.EQ.TERM)GO TO  140
!
!     CHECK TO SEE IF IT IS ALREADY OPEN
!
      INQUIRE(FILE=FNAME2,EXIST=EX,OPENED=OD,NUMBER=NUM)
!
!     IF IT DOESN'T EVEN EXIST, OPEN IT AND RETURN
!
      IF(.NOT.EX)THEN
         WRITE(*,*)'OPENING NEW FILE ',FNAME2
         OPEN(LUOUT,FILE=FNAME2,STATUS='NEW')
         IERR=0
         RETURN
      END IF
!
!     BUT IF IT DOES EXIST AND ISN'T ALREADY OPEN, USER NEEDS TO BE
!     ABLE TO ABORT OVERWRITE
!
      IF(.NOT.OD)THEN
   80    WRITE(*,40)
         READ(*,20,ERR=80)INP
         CALL UC1(INP)
         IF(INP.EQ.NO)THEN
      WRITE(*,50)
      GO TO 70
         END IF
!
!     GO AHEAD AND OPEN IT FOR OVERWRITES
!
         OPEN(LUOUT,FILE=FNAME2,STATUS='OLD')
         IERR=0
         RETURN
!
      END IF
!     IF THE FILE IS IN USE, GIVER USER CHOICES
!
!     THERE ARE SEVERAL POSSIBILITIES:
!     1) FILE IS ALREADY OPEN ON UNIT LUOUT
!        OPTIONS:
!        REWIND AND OVERWRITE IT
!        APPEND TO THE FILE AT NEXT RECORD POSITION
!        CLOSE IT AND ASK FOR ANOTHER FILE NAME
!        ABORT
!     2) FILE IS OPEN ON SOME OTHER LUN
!        OPTIONS:
!        CLOSE THAT LUN, REWIND THE FILE AND OVERWRITE ON LUOUT
!        CLOSE THAT LUN, APPEND TO FILE (NOT A GOOD CHOICE)
!
      IF(OD.AND.(NUM.NE.LUOUT))THEN
   90    WRITE(*,*)'THAT FILE IS ALREADY IN USE FOR SOME OTHER PURPOSE.'
         WRITE(*,*)'DO YOU WANT TO USE ANOTHER NAME FOR THE OUTPUT FILE &
     &(Y/N) ? .'
         READ(*,*,ERR=90)INP
         CALL UC1(INP)
         IF(INP.EQ.YES)GO TO  70
         GO TO 130
      END IF
!
  100 FORMAT(/' FILE ',A96,' IS ALREADY OPEN.'// ' OPTIONS ARE: 1.0 REWI&
     &ND AND OVERWRITE IT ANYWAY.'/ '        2.0 BEGIN WRITING AT &
     &NEXT AVAILABLE RECORD.'/ '        3.0 CLOSE IT AND ENTER A N&
     &EW FILENAME.'/ '        4.0 ABORT THIS RUN.'/' ENTER NUMBER &
     &FOR YOUR CHOICE'/)
  110 FORMAT(/' TERMINATING UPON USER COMMAND TO ABORT RUN.')
!
      IF(OD.AND.(NUM.EQ.LUOUT))THEN
  120    WRITE(*,100)FNAME2
         READ(*,*,ERR=120)VALUE
         IVAL=NINT(VALUE)
         IF(IVAL.LE.0.OR.IVAL.GT.4)THEN
      WRITE(*,*)'CHOICE MUST BE IN RANGE 1.0 - 4.0'
      GO TO 120
         END IF
!
         IF(IVAL.EQ.1)THEN
      REWIND  LUOUT
      IERR=0
      RETURN
         END IF
!
         IF(IVAL.EQ.2)THEN
      IERR=0
      RETURN
         END IF
!
         IF(IVAL.EQ.3)THEN
      CLOSE(LUOUT)
      GO TO 70
         END IF
!
         IF(IVAL.EQ.4)GO TO  130
      END IF
!
  130 IJKLMN=1
      IERR=-1
      WRITE(*,110)
      RETURN
!
!     THE OLD USE OF IERR TO IMPLY USE OF CONSOLE FOR OUTPUT MAY
!     CAUSE TROUBLE IN RTD, ETC.
!
  140 IJKLMN=1
!
      WRITE(*,60)
!
!      SET IERR = + 1 TO SIGNAL THAT CONSOLE IS TO BE USED FOR OUTPUT
!
      IERR=1
      RETURN
      END SUBROUTINE GETOUF
! *********************************************************************
      SUBROUTINE VARCHK(VARNAM,ISVAR)
      USE RENCOM
      IMPLICIT NONE
      INTEGER(2) :: IJKLMN
      CHARACTER(LEN=1)  , INTENT(INOUT) :: VARNAM(16)
      LOGICAL, INTENT(INOUT) :: ISVAR
!
! LOOK THROUGH CLINE FOR AN = SIGN AND COLLECT ANY CHARS TO LEFT OF IT
! AND TO RIGHT OF COL6 AS VARNAM
!
!      INCLUDE 'EZUP.INC'
      CHARACTER(LEN=1) :: EQL
      CHARACTER(LEN=1) :: SPC
      CHARACTER(LEN=16) :: SKIPIT (30),CHKNAM,OLDNAM
      INTEGER(2) :: I, J, K, M, N, NAMLEN
      SKIPIT(1)='END   '
      SKIPIT(2)='ERR   '
      SKIPIT(3)='FILE'
      SKIPIT(4)='UNIT  '
      SKIPIT(5)='FMT   '
      SKIPIT(6)='BLANK '
      SKIPIT(7)='BLOCKS'
      SKIPIT(8)='FORM  '
      SKIPIT(9)='IOSTAT'
      SKIPIT(10)='MODE  '
      SKIPIT(11)='RECL  '
      SKIPIT(12)='SHARE '
      SKIPIT(13)='STATUS'
      SKIPIT(14)='REC   '
      SKIPIT(15)='NML   '
      SKIPIT(16)='BINARY'
      SKIPIT(17)='DIRECT'
      SKIPIT(18)='EXIST '
      SKIPIT(19)='FORMAT'
      SKIPIT(20)='NAME  '
      SKIPIT(21)='NAMED '
      SKIPIT(22)='NEXTRE'
      SKIPIT(23)='NUMBER'
      SKIPIT(24)='OPENED'
      SKIPIT(25)='SEQUEN'
      SKIPIT(26)='UNFORM'
      SKIPIT(27)='LOCKMO'
      SKIPIT(28)='RECORD'
      SKIPIT(29)='STAT  '
      SKIPIT(30)='BLANK '
!
      EQL='='
      SPC=' '
!
      IF(CLINE(1).EQ.'!')THEN
         ISVAR=.FALSE.
         GO TO 140
      END IF
!##
      DO J=1,16
      VARNAM(J)=' '
      END DO
      DO I=7,ICLEN
         K=I
      IF(CLINE(I).EQ.EQL)GO TO  30
      END DO
   30 IF(K.EQ.ICLEN)THEN
! DID NOT FIND = SIGN
         ISVAR=.FALSE.
         GO TO 140
      ELSE
! FOUND = SIGN. LOOK FOR THE VARNAME
         IF(K.LE.7)THEN
      ISVAR=.FALSE.
      GO TO 140
         END IF
      END IF
!
! LOOK LEFTWARD AND EXTRACT NON SPACE CHARS AS VAR NAME, BUT ADD
! SOME RESTRICTIONS.. IE MAX LENGTH = CHARS
      J=K
!## TRY SETTING M=17 INSTEAD OF 7 : 12-3-1999 ; DOESN'T HELP
      M=17
   40 J=J-1
      M=M-1
      IF(M.LT.1)GO TO  50
      N=ICHAR(CLINE(J))
! MAKE ANY NON ALPHABETIC OR NUMERAL
      IF(N.EQ.32)GO TO  50
      IF(N.GE.123)GO TO  50
      IF(N.GE.91.AND.N.LE.96)GO TO  50
      IF(N.LE.64.AND.N.GE.57)GO TO  50
      IF(N.LE.47)GO TO  50
      IF(CLINE(J).NE.SPC)THEN
         VARNAM(M)=CLINE(J)
         GO TO 40
      END IF
!
! VARNAM MAY HAVE BEEN TRUNCATED
   50 IJKLMN=1
!##
      NAMLEN=16-M
!##
      IF(NAMLEN.LT.1.OR.NAMLEN.GT.16)THEN
         ISVAR=.FALSE.
      ELSE
         ISVAR=.TRUE.
! LEFT JUSTIFY?
!##
         IF(NAMLEN.LT.16)THEN
! VARNAM BEGINS IN COL 6-NAMLEN +1; MOVE TO J=1
! NEXT CHAR IS IN  (6-NAMLEN+1)+2; MOVE TO J=2
!##
      DO J=1,16
!## NEXT LINE TOO 6 -> 16
         K=16-NAMLEN+J
!##
         IF(K.GT.16)GO TO  70
      VARNAM(J)=VARNAM(K)
      END DO
   70       K=NAMLEN+1
!##
      DO J=K,16
      VARNAM(J)=SPC
      END DO
         END IF
      END IF
!
!     RECHECK AND THROW OUT THINGS WHICH PROBABLY BELONG IN THINGS
!     OPEN(FILE...) AND SIMILAR STATEMENTS
!
!##
      DO J=1,16
      CHKNAM(J:J)=VARNAM(J)
      END DO
      DO J=1,30
      IF(CHKNAM.EQ.SKIPIT(J))ISVAR=.FALSE.
      END DO
!
      IF(ISVAR)THEN
!
!    SEE IF THIS VARNAM IS ALREADY IN THE LIST
!
         DO J=1,NUMVAR
!##
      DO K=1,16
      OLDNAM(K:K)=VARLST(J,K)
      END DO
      IF(OLDNAM.EQ.CHKNAM)THEN
         ISVAR=.FALSE.
         GO TO 140
      END IF
         END DO
!
!
         NUMVAR=NUMVAR+1
         IF(NUMVAR.GT.400)THEN
      WRITE(*,*)'VARIABLE NAME LIST TRUNCATED AT 400 ENTRIES.'
      GO TO 140
         END IF
!##
         DO J=1,16
         VARLST(NUMVAR,J)=VARNAM(J)
         END DO
      END IF
  140 RETURN
      END SUBROUTINE VARCHK
! *********************************************************************
      SUBROUTINE MAKEDO(IBELNG,NDLEVL,NKEEP)
      USE RENCOM
      IMPLICIT NONE
      integer(2) :: III, IIJ
      INTEGER(2), INTENT(INOUT) :: IBELNG
      INTEGER(2), INTENT(INOUT) :: NDLEVL
      INTEGER(2), INTENT(INOUT) :: NKEEP
      CHARACTER(LEN=72) :: MYENDO
   10 FORMAT(1X,72A1)
      IF(IBELNG.EQ.0)THEN
         IIJ=(NDLEVL-NKEEP)*NDSPC+5
      ELSE
         IIJ=5+(IBELNG)*NDSPC
      END IF
!
      MYENDO(1:IIJ)=' '
      III=IIJ+1
      IIJ=III+5
      MYENDO(III:IIJ+6)='END DO'
      WRITE(IOOUT,10) (MYENDO(III:III),III=1,IIJ+6)
      NLINE=NLINE+1
      RETURN
      END SUBROUTINE MAKEDO
!
      SUBROUTINE CLRABF(ATEXT)
      CHARACTER(LEN=1) :: ATEXT(80)
      INTEGER I
      DO I=1,80
         ATEXT(I)=' '
      END DO
      RETURN
      END SUBROUTINE CLRABF

!
		subroutine whopn
		logical opnd
		inquire(unit=34,opened=opnd)
		if(opnd) write(*,*) 'Unit 34 is still open'
		inquire(unit=35,opened=opnd)
		if(opnd) write(*,*) 'Unit 35 is still open'
		inquire(unit=41,opened=opnd)
		if(opnd) write(*,*) 'Unit 41 is still open'
		inquire(unit=43,opened=opnd)					
		if(opnd) write(*,*) 'Unit 43 is still open'
		inquire(unit=46,opened=opnd)
		if(opnd) write(*,*) 'Unit 46 is still open'
		inquire(unit=47,opened=opnd)
		if(opnd) write(*,*) 'Unit 47 is still open'
		inquire(unit=48,opened=opnd)
		if(opnd) write(*,*) 'Unit 48 is still open'
		inquire(unit=77,opened=opnd)
		if(opnd) write(*,*) 'Unit 77 is still open'
		inquire(unit=78,opened=opnd)
		if(opnd) write(*,*) 'Unit 78 is still open'
		open(unit=8,file='commvars.tmp',status='old')
		close(unit=8,status='delete')
		open(unit=9,file='varnames.tmp',status='old')
		close(unit=9,status='DELETE')
		end subroutine whopn
